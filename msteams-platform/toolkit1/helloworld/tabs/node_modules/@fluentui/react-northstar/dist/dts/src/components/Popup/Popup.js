"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Popup = exports.popupClassName = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_nesting_registry_1 = require("@fluentui/react-component-nesting-registry");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var dom_utilities_1 = require("@fluentui/dom-utilities");
var utils_1 = require("../../utils");
var positioner_1 = require("../../utils/positioner");
var PopupContent_1 = require("./PopupContent");
var factories_1 = require("../../utils/factories");
var isRightClick_1 = require("../../utils/isRightClick");
var PortalInner_1 = require("../Portal/PortalInner");
var Animation_1 = require("../Animation/Animation");
function getRealEventProps(element) {
    if (element.type === react_component_ref_1.Ref || element.type === react_component_ref_1.RefFindNode || element.type === react_component_ref_1.RefForward) {
        return getRealEventProps(element.props.children);
    }
    return Object.keys(element.props).reduce(function (acc, propName) {
        var _a;
        return propName.startsWith('on') ? __assign(__assign({}, acc), (_a = {}, _a[propName] = element.props[propName], _a)) : acc;
    }, {});
}
exports.popupClassName = 'ui-popup';
/**
 * A Popup displays a non-modal, often rich content, on top of its target element.
 */
var Popup = function (props) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Popup.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, align = props.align, autoFocus = props.autoFocus, inline = props.inline, contentRef = props.contentRef, flipBoundary = props.flipBoundary, on = props.on, mountNode = props.mountNode, mouseLeaveDelay = props.mouseLeaveDelay, offset = props.offset, overflowBoundary = props.overflowBoundary, pointing = props.pointing, popperRef = props.popperRef, position = props.position, positionFixed = props.positionFixed, renderContent = props.renderContent, tabbableTrigger = props.tabbableTrigger, target = props.target, trapFocus = props.trapFocus, trigger = props.trigger, unstable_disableTether = props.unstable_disableTether, unstable_pinned = props.unstable_pinned, autoSize = props.autoSize;
    var _b = react_bindings_1.useAutoControlled({
        initialValue: false,
        defaultValue: props.defaultOpen,
        value: props.open,
    }), open = _b[0], setOpen = _b[1];
    var _c = React.useState(false), isOpenedByRightClick = _c[0], setIsOpenedByRightClick = _c[1];
    var closeTimeoutId = React.useRef();
    var mouseDownEventRef = React.useRef();
    var popupContentRef = React.useRef();
    var pointerTargetRef = React.useRef();
    var triggerRef = React.useRef();
    // focusable element which has triggered Popup, can be either triggerDomElement or the element inside it
    var triggerFocusableRef = React.useRef();
    var rightClickReferenceObject = React.useRef();
    react_bindings_1.useOnIFrameFocus(open, context.target, function (e) {
        var iframeInsidePopup = dom_utilities_1.elementContains(popupContentRef.current, e.target);
        if (iframeInsidePopup) {
            return;
        }
        setOpen(function (__) {
            _.invoke(props, 'onOpenChange', e, __assign(__assign({}, props), { open: false }));
            return false;
        });
    });
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: exports.Popup.displayName,
        actionHandlers: {
            closeAndFocusTrigger: function (e) {
                e.preventDefault();
                close(e, function () { return _.invoke(triggerFocusableRef.current, 'focus'); });
            },
            close: function (e) {
                close(e);
            },
            toggle: function (e) {
                e.preventDefault();
                trySetOpen(!open, e);
            },
            open: function (e) {
                e.preventDefault();
                setPopupOpen(true, e);
            },
            click: function (e) {
                _.invoke(triggerRef.current, 'click');
            },
            preventScroll: function (e) {
                e.preventDefault();
            },
            stopPropagation: function (e) {
                e.stopPropagation();
            },
        },
        mapPropsToBehavior: function () { return ({
            isOpenedByRightClick: isOpenedByRightClick,
            on: on,
            trapFocus: trapFocus,
            tabbableTrigger: tabbableTrigger,
            trigger: trigger,
            inline: inline,
        }); },
        rtl: context.rtl,
    });
    var handleDocumentClick = function (getRefs) { return function (e) {
        var currentMouseDownEvent = mouseDownEventRef.current;
        mouseDownEventRef.current = null;
        if (currentMouseDownEvent && !isOutsidePopupElement(getRefs(), currentMouseDownEvent)) {
            return;
        }
        if (isOpenedByRightClick && isOutsidePopupElement(getRefs(), e)) {
            trySetOpen(false, e);
            rightClickReferenceObject.current = null;
            return;
        }
        if (isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
            trySetOpen(false, e);
        }
    }; };
    var handleMouseDown = function (e) {
        mouseDownEventRef.current = e;
    };
    var handleDocumentKeyDown = function (getRefs) { return function (e) {
        var keyCode = accessibility_1.getCode(e);
        var isMatchingKey = keyCode === accessibility_1.keyboardKey.Enter || keyCode === accessibility_1.SpacebarKey;
        if (isMatchingKey && isOutsidePopupElementAndOutsideTriggerElement(getRefs(), e)) {
            trySetOpen(false, e);
        }
        // if focus was lost from Popup and moved to body, for e.g. when click on popup content
        // and ESC is pressed, the last opened Popup should get closed and the trigger should get focus
        var lastContentRef = getRefs().pop();
        var isLastOpenedPopup = lastContentRef && lastContentRef.current === popupContentRef.current;
        var activeDocument = context.target;
        var bodyHasFocus = activeDocument.activeElement === activeDocument.body;
        if (keyCode === accessibility_1.keyboardKey.Escape && bodyHasFocus && isLastOpenedPopup) {
            close(e, function () { return _.invoke(triggerFocusableRef.current, 'focus'); });
        }
    }; };
    var isOutsidePopupElementAndOutsideTriggerElement = function (refs, e) {
        var isOutsidePopup = isOutsidePopupElement(refs, e);
        var isInsideTrigger = triggerRef.current && utils_1.doesNodeContainClick(triggerRef.current, e, context.target);
        return isOutsidePopup && !isInsideTrigger;
    };
    var isOutsidePopupElement = function (refs, e) {
        var isInsideNested = _.some(refs, function (childRef) {
            return utils_1.doesNodeContainClick(childRef.current, e, context.target);
        });
        var isOutsidePopup = popupContentRef.current && !isInsideNested;
        return isOutsidePopup;
    };
    var getTriggerProps = function (triggerElement) {
        var triggerElementEventProps = triggerElement ? getRealEventProps(triggerElement) : {};
        var triggerProps = {};
        var normalizedOn = _.isArray(on) ? on : [on];
        /**
         * The focus is adding the focus, blur and click event (always opening on click)
         * If focus and context are provided, there is no need to add onClick
         */
        if (_.includes(normalizedOn, 'focus')) {
            triggerProps.onFocus = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (utils_1.isFromKeyboard()) {
                    trySetOpen(true, e);
                }
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onFocus', e], args));
            };
            triggerProps.onBlur = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (shouldBlurClose(e)) {
                    trySetOpen(false, e);
                }
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onBlur', e], args));
            };
            if (!_.includes(normalizedOn, 'context')) {
                triggerProps.onClick = function (e) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    setPopupOpen(true, e);
                    _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onClick', e], args));
                };
            }
        }
        /**
         * The click is toggling the open state of the popup
         */
        if (_.includes(normalizedOn, 'click')) {
            triggerProps.onClick = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                trySetOpen(!open, e);
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onClick', e], args));
            };
        }
        /**
         * The context is opening the popup
         */
        if (_.includes(normalizedOn, 'context')) {
            triggerProps.onContextMenu = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                setPopupOpen(!open, e);
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onContextMenu', e], args));
                e.preventDefault();
            };
        }
        /**
         * The hover is adding the mouseEnter, mouseLeave, blur and click event (always opening on click)
         * If hover and context are provided, there is no need to add onClick
         */
        if (_.includes(normalizedOn, 'hover')) {
            triggerProps.onMouseEnter = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                setPopupOpen(true, e);
                utils_1.setWhatInputSource(context.target, 'mouse');
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onMouseEnter', e], args));
            };
            triggerProps.onMouseLeave = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                setPopupOpen(false, e);
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onMouseLeave', e], args));
            };
            if (!_.includes(normalizedOn, 'context')) {
                triggerProps.onClick = function (e) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    setPopupOpen(true, e);
                    _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onClick', e], args));
                };
            }
            triggerProps.onBlur = function (e) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (shouldBlurClose(e)) {
                    trySetOpen(false, e);
                }
                _.invoke.apply(_, __spreadArray([triggerElementEventProps, 'onBlur', e], args));
            };
        }
        return __assign(__assign({}, triggerElementEventProps), triggerProps);
    };
    var getContentProps = function (predefinedProps) {
        var contentHandlerProps = {};
        var normalizedOn = _.isArray(on) ? on : [on];
        /**
         * The focus is adding the focus and blur events on the content
         */
        if (_.includes(normalizedOn, 'focus')) {
            contentHandlerProps.onFocus = function (e, contentProps) {
                trySetOpen(true, e);
                predefinedProps && _.invoke(predefinedProps, 'onFocus', e, contentProps);
            };
            contentHandlerProps.onBlur = function (e, contentProps) {
                if (shouldBlurClose(e)) {
                    trySetOpen(false, e);
                }
                predefinedProps && _.invoke(predefinedProps, 'onBlur', e, contentProps);
            };
        }
        /**
         * The hover is adding the mouseEnter, mouseLeave
         */
        if (_.includes(normalizedOn, 'hover')) {
            contentHandlerProps.onMouseEnter = function (e, contentProps) {
                setPopupOpen(true, e);
                predefinedProps && _.invoke(predefinedProps, 'onMouseEnter', e, contentProps);
            };
            contentHandlerProps.onMouseLeave = function (e, contentProps) {
                setPopupOpen(false, e);
                predefinedProps && _.invoke(predefinedProps, 'onMouseLeave', e, contentProps);
            };
        }
        return contentHandlerProps;
    };
    var shouldBlurClose = function (e) {
        var relatedTarget = e.relatedTarget;
        var isInsideContent = dom_utilities_1.elementContains(popupContentRef.current, relatedTarget);
        var isInsideTarget = dom_utilities_1.elementContains(e.currentTarget, relatedTarget);
        // When clicking in the popup content that has no tabIndex focus goes to body
        // We shouldn't close the popup in this case
        return relatedTarget && !(isInsideContent || isInsideTarget);
    };
    var renderPopperChildren = function (classes) { return function (_a) {
        var placement = _a.placement, scheduleUpdate = _a.scheduleUpdate;
        var content = renderContent ? renderContent(scheduleUpdate) : props.content;
        var popupContent = exports.Popup.Content.create(content || {}, {
            defaultProps: function () {
                return getA11yProps('popup', __assign(__assign({}, getContentProps()), { placement: placement, pointing: pointing, pointerRef: pointerTargetRef, trapFocus: trapFocus, autoFocus: autoFocus, autoSize: autoSize, className: classes }));
            },
            overrideProps: getContentProps,
        });
        return (React.createElement(react_component_nesting_registry_1.Unstable_NestingAuto, null, function (getRefs, nestingRef) { return (React.createElement(React.Fragment, null,
            React.createElement(react_component_ref_1.Ref, { innerRef: function (domElement) {
                    popupContentRef.current = domElement;
                    react_component_ref_1.handleRef(contentRef, domElement);
                    nestingRef.current = domElement;
                } }, popupContent),
            context.target && (React.createElement(React.Fragment, null,
                React.createElement(react_component_event_listener_1.EventListener, { listener: handleMouseDown, target: context.target, type: "mousedown" }),
                React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentClick(getRefs), target: context.target, type: "click", capture: true }),
                React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentClick(getRefs), target: context.target, type: "contextmenu", capture: true }),
                React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentKeyDown(getRefs), target: context.target, type: "keydown", capture: true }),
                isOpenedByRightClick && (React.createElement(React.Fragment, null,
                    React.createElement(react_component_event_listener_1.EventListener, { listener: dismissOnScroll, target: context.target, type: "wheel", capture: true }),
                    React.createElement(react_component_event_listener_1.EventListener, { listener: dismissOnScroll, target: context.target, type: "touchmove", capture: true }))))))); }));
    }; };
    var dismissOnScroll = function (e) {
        // we only need to dismiss if the scroll happens outside the popup
        if (!popupContentRef.current.contains(e.target)) {
            trySetOpen(false, e);
        }
    };
    var trySetOpen = function (newValue, event) {
        var isOpenedByRightClick = newValue && isRightClick_1.isRightClick(event);
        // when new state 'open' === 'true', save the last focused element
        if (newValue) {
            updateTriggerFocusableRef();
            updateContextPosition(isOpenedByRightClick && event.nativeEvent);
        }
        setOpen(newValue);
        setIsOpenedByRightClick(isOpenedByRightClick);
        _.invoke(props, 'onOpenChange', event, __assign(__assign({}, props), { open: newValue }));
    };
    var setPopupOpen = function (newOpen, e) {
        clearTimeout(closeTimeoutId.current);
        newOpen ? trySetOpen(true, e) : schedulePopupClose(e);
    };
    var schedulePopupClose = function (e) {
        closeTimeoutId.current = setTimeout(function () {
            trySetOpen(false, e);
        }, mouseLeaveDelay);
    };
    var close = function (e, onClose) {
        if (open) {
            trySetOpen(false, e);
            onClose && onClose();
            e.stopPropagation();
        }
    };
    /**
     * Save DOM element which had focus before Popup opens.
     * Can be either trigger DOM element itself or the element inside it.
     */
    var updateTriggerFocusableRef = function () {
        var _a;
        var activeElement = (_a = context.target) === null || _a === void 0 ? void 0 : _a.activeElement;
        if (activeElement) {
            triggerFocusableRef.current =
                triggerRef.current && dom_utilities_1.elementContains(triggerRef.current, activeElement)
                    ? activeElement
                    : triggerRef.current;
        }
    };
    var updateContextPosition = function (nativeEvent) {
        rightClickReferenceObject.current = nativeEvent ? positioner_1.createReferenceFromClick(nativeEvent) : null;
    };
    if (process.env.NODE_ENV !== 'production') {
        // This is fine to violate there conditional rule as environment variables will never change during component
        // lifecycle
        // eslint-disable-next-line react-hooks/rules-of-hooks
        React.useEffect(function () {
            if (inline && trapFocus) {
                // eslint-disable-next-line no-console
                console.warn('Using "trapFocus" in inline popup leads to broken behavior for screen reader users.');
            }
            if (!inline && autoFocus) {
                // eslint-disable-next-line no-console
                console.warn('Beware, "autoFocus" prop will just grab focus at the moment of mount and will not trap it. As user is able to TAB out from popup, better use "inline" prop to keep correct tab order.');
            }
        }, [autoFocus, inline, trapFocus]);
    }
    React.useEffect(function () {
        if (open) {
            // when new state 'open' === 'true', save the last focused element
            updateTriggerFocusableRef();
        }
    });
    var triggerNode = react_bindings_1.useTriggerElement(props);
    var triggerProps = getTriggerProps(triggerNode);
    React.useEffect(function () {
        if (open) {
            dom_utilities_1.setVirtualParent(popupContentRef.current, triggerRef.current);
        }
        return function () {
            if (open && popupContentRef.current) {
                dom_utilities_1.setVirtualParent(popupContentRef.current, null);
            }
        };
    }, [open]);
    var contentElement = (React.createElement(Animation_1.Animation, { mountOnEnter: true, unmountOnExit: true, visible: open, name: open ? 'popup-show' : 'popup-hide' }, function (_a) {
        var classes = _a.classes;
        var content = (React.createElement(positioner_1.Popper, { pointerTargetRef: pointerTargetRef, align: align, flipBoundary: flipBoundary, popperRef: popperRef, position: position, positionFixed: positionFixed, offset: offset, overflowBoundary: overflowBoundary, rtl: context.rtl, unstable_disableTether: unstable_disableTether, unstable_pinned: unstable_pinned, autoSize: autoSize, targetRef: rightClickReferenceObject.current || target || triggerRef }, renderPopperChildren(classes)));
        return inline ? content : React.createElement(PortalInner_1.PortalInner, { mountNode: mountNode }, content);
    }));
    var triggerElement = triggerNode && (React.createElement(react_component_ref_1.Ref, { innerRef: triggerRef }, React.cloneElement(triggerNode, getA11yProps('trigger', triggerProps))));
    var element = (React.createElement(React.Fragment, null,
        triggerElement,
        contentElement));
    setEnd();
    return element;
};
exports.Popup = Popup;
exports.Popup.displayName = 'Popup';
exports.Popup.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    as: false,
    content: false,
})), { align: PropTypes.oneOf(positioner_1.ALIGNMENTS), defaultOpen: PropTypes.bool, inline: PropTypes.bool, mountNode: customPropTypes.domNode, mouseLeaveDelay: PropTypes.number, offset: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.arrayOf(PropTypes.number),
    ]), popperRef: customPropTypes.ref, flipBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), overflowBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), on: PropTypes.oneOfType([
        PropTypes.oneOf(['hover', 'click', 'focus', 'context']),
        PropTypes.arrayOf(PropTypes.oneOf(['click', 'focus', 'context'])),
        PropTypes.arrayOf(PropTypes.oneOf(['hover', 'focus', 'context'])),
    ]), open: PropTypes.bool, onOpenChange: PropTypes.func, pointing: PropTypes.bool, position: PropTypes.oneOf(positioner_1.POSITIONS), positionFixed: PropTypes.bool, renderContent: PropTypes.func, target: PropTypes.any, trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.any]), tabbableTrigger: PropTypes.bool, unstable_disableTether: PropTypes.oneOf([true, false, 'all']), unstable_pinned: PropTypes.bool, autoSize: PropTypes.oneOf(positioner_1.AUTOSIZES), content: customPropTypes.shorthandAllowingChildren, contentRef: customPropTypes.ref, trapFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]), autoFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]) });
exports.Popup.defaultProps = {
    accessibility: accessibility_1.popupBehavior,
    align: 'start',
    position: 'above',
    on: 'click',
    mouseLeaveDelay: 500,
    tabbableTrigger: true,
};
exports.Popup.handledProps = Object.keys(exports.Popup.propTypes);
exports.Popup.Content = PopupContent_1.PopupContent;
exports.Popup.create = factories_1.createShorthandFactory({ Component: exports.Popup, mappedProp: 'content' });
exports.Popup.shorthandConfig = {
    mappedProp: 'content',
};
