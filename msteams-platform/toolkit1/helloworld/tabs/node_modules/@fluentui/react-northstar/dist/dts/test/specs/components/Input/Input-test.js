"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var accessibility_1 = require("@fluentui/accessibility");
var faker = require("faker");
var _ = require("lodash");
var React = require("react");
var utils_1 = require("src/utils");
var Box_1 = require("src/components/Box/Box");
var Input_1 = require("src/components/Input/Input");
var utils_2 = require("test/utils");
var commonTests_1 = require("test/specs/commonTests");
var testValue = 'test value';
var getInputDomNode = function (inputComp) {
    return inputComp.find('input').getDOMNode();
};
var setUserInputValue = function (inputComp, value) {
    inputComp.find('input').simulate('change', { target: { value: value } });
};
describe('Input', function () {
    commonTests_1.isConformant(Input_1.Input, {
        testPath: __filename,
        constructorName: 'Input',
        eventTargets: {
            onChange: 'input',
            onKeyDown: 'input',
            onKeyPress: 'input',
            onKeyUp: 'input',
        },
        disabledTests: ['component-has-root-ref'],
        autoControlledProps: ['value'],
        forwardsRefTo: "Box[className~=\"" + Input_1.inputSlotClassNames.input + "\"]",
    });
    commonTests_1.implementsShorthandProp(Input_1.Input)('input', Box_1.Box, { mapsValueToProp: 'type' });
    describe('wrapper', function () {
        commonTests_1.implementsShorthandProp(Input_1.Input)('wrapper', Box_1.Box, { mapsValueToProp: 'children' });
        commonTests_1.implementsWrapperProp(Input_1.Input, { wrapppedComponentSelector: 'input' });
    });
    it('renders a text <input> by default', function () {
        var inputComp = utils_2.mountWithProvider(React.createElement(Input_1.Input, null));
        expect(inputComp.find('input[type="text"]').length).toBeGreaterThan(0);
    });
    describe('input related HTML attribute', function () {
        // `input` will be always controlled component so there is no need to pass down `defaultValue`
        _.without(utils_1.htmlInputAttrs, 'defaultValue').forEach(function (attr) {
            it("'" + attr + "' is set correctly to '" + testValue + "'", function () {
                var _a;
                // as `testValue` is a string it can cause propTypes errors on `Input`
                utils_2.consoleUtil.disableOnce();
                var wrapper = utils_2.mountWithProvider(React.createElement(Input_1.Input, __assign({}, (_a = {}, _a[attr] = testValue, _a)))).find('input');
                expect(wrapper.prop(attr)).toBe(testValue);
            });
        });
    });
    describe('clearable', function () {
        it('calls onChange on Clearable icon click with an `empty` value', function () {
            var onChange = jest.fn();
            var wrapper = utils_2.mountWithProvider(React.createElement(Input_1.Input, { clearable: true, defaultValue: faker.lorem.word(), onChange: onChange }));
            wrapper.find("." + Input_1.inputSlotClassNames.icon).first().simulate('click');
            expect(onChange).toBeCalledTimes(1);
            expect(onChange).toHaveBeenCalledWith(expect.objectContaining({ type: 'click' }), expect.objectContaining({ value: '' }));
        });
        it('calls onChange on Escape key with an `empty` value and stops propagation when has content', function () {
            var onChange = jest.fn();
            var stopPropagation = jest.fn();
            var nativeEventStopPropagation = jest.fn();
            var wrapper = utils_2.mountWithProvider(React.createElement(Input_1.Input, { clearable: true, defaultValue: faker.lorem.word(), onChange: onChange }));
            wrapper.find('input').simulate('keydown', {
                keyCode: accessibility_1.keyboardKey.Escape,
                key: 'Escape',
                stopPropagation: stopPropagation,
                nativeEvent: { stopPropagation: nativeEventStopPropagation },
            });
            expect(onChange).toBeCalledTimes(1);
            expect(onChange).toHaveBeenCalledWith(expect.objectContaining({ type: 'keydown' }), expect.objectContaining({ value: '' }));
            expect(stopPropagation).toHaveBeenCalledTimes(1);
            expect(nativeEventStopPropagation).toHaveBeenCalledTimes(1);
        });
        it('does not call onChange and does not stop propagation if is already empty', function () {
            var onChange = jest.fn();
            var stopPropagation = jest.fn();
            var nativeEventStopPropagation = jest.fn();
            var wrapper = utils_2.mountWithProvider(React.createElement(Input_1.Input, { clearable: true, defaultValue: '', onChange: onChange }));
            wrapper.find('input').simulate('keydown', {
                keyCode: accessibility_1.keyboardKey.Escape,
                key: 'Escape',
                stopPropagation: stopPropagation,
                nativeEvent: { stopPropagation: nativeEventStopPropagation },
            });
            expect(onChange).not.toBeCalled();
            expect(stopPropagation).not.toBeCalled();
            expect(nativeEventStopPropagation).not.toBeCalled();
        });
    });
    describe('icon', function () {
        var SearchIcon = function () { return React.createElement("span", null); };
        it('creates the Icon component when the icon shorthand is provided', function () {
            var inputComp = utils_2.mountWithProvider(React.createElement(Input_1.Input, { icon: React.createElement(SearchIcon, null) }));
            expect(inputComp.find('SearchIcon').length).toBeGreaterThan(0);
        });
        it('creates an empty Icon component when the clearable prop is provided and the input has content, removes the icon and value when the icon is clicked', function () {
            var inputComp = utils_2.mountWithProvider(React.createElement(Input_1.Input, { clearable: true }));
            var domNode = getInputDomNode(inputComp);
            setUserInputValue(inputComp, testValue); // user types into the input
            var iconComp = inputComp.find("Box[className~=\"" + Input_1.inputSlotClassNames.icon + "\"]");
            expect(domNode.value).toEqual(testValue); // input value is the one typed by the user
            expect(iconComp.length).toBeGreaterThan(0); // the 'x' icon appears
            iconComp.simulate('click'); // user clicks on 'x' icon
            expect(domNode.value).toEqual(''); // input value gets cleared
            expect(inputComp.find("Box[className~=\"" + Input_1.inputSlotClassNames.icon + "\"]").length).toEqual(0); // the 'x' icon disappears
        });
    });
    it('disabled prop makes the input un-actionable', function () {
        var inputComp = utils_2.mountWithProvider(React.createElement(Input_1.Input, { disabled: true }));
        var domNode = getInputDomNode(inputComp);
        expect(domNode).toHaveAttribute('disabled');
        setUserInputValue(inputComp, testValue); // user types into the input
        expect(domNode.value).toEqual(''); // but nothing happens
        domNode.focus();
        expect(domNode).not.toHaveFocus();
        domNode.click();
        expect(domNode).not.toHaveFocus();
    });
});
