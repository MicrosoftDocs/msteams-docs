"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useVirtualTree = void 0;
var React = require("react");
var useTree_1 = require("./useTree");
function useVirtualTree(props) {
    var baseTree = useTree_1.useTree(props);
    var baseRegisterItemRef = baseTree.registerItemRef, baseExpandSiblings = baseTree.expandSiblings, getItemById = baseTree.getItemById, getItemRef = baseTree.getItemRef, visibleItemIds = baseTree.visibleItemIds;
    var listRef = React.useRef();
    var focusIdRef = React.useRef();
    var focusItemById = React.useCallback(function (id) {
        var _a, _b, _c;
        var itemRef = getItemRef(id);
        // item is not mounted yet
        if (itemRef == null) {
            // set focusIdRef so item can be focused on mount; then scroll to item
            focusIdRef.current = id;
            var focusIndex = visibleItemIds.indexOf(focusIdRef.current);
            if (focusIndex >= 0) {
                (_a = listRef.current) === null || _a === void 0 ? void 0 : _a.scrollToItem(focusIndex, 'center');
            }
            return;
        }
        // item is mounted, set focus
        if ((_b = getItemById(id)) === null || _b === void 0 ? void 0 : _b.hasSubtree) {
            itemRef.focus();
        }
        else {
            // when tree item is leaf, need to focus on the inner treeTitle
            (_c = itemRef.firstElementChild) === null || _c === void 0 ? void 0 : _c.focus();
        }
    }, [getItemById, getItemRef, visibleItemIds]);
    var registerItemRef = React.useCallback(function (id, node) {
        var _a, _b;
        baseRegisterItemRef(id, node);
        if (node && focusIdRef.current === id) {
            // focus on this tree item
            if ((_a = getItemById(id)) === null || _a === void 0 ? void 0 : _a.hasSubtree) {
                node.focus();
            }
            else {
                // when node is leaf, need to focus on the inner treeTitle
                (_b = node.firstElementChild) === null || _b === void 0 ? void 0 : _b.focus();
            }
            focusIdRef.current = null;
        }
    }, [baseRegisterItemRef, getItemById]);
    var expandSiblings = React.useCallback(function (e, id) {
        baseExpandSiblings(e, id);
        focusIdRef.current = id;
    }, [baseExpandSiblings]);
    React.useLayoutEffect(function () {
        var _a;
        /**
         * Reason for scroll in useLayoutEffect:
         * Without useLayoutEffect, scrolling works for focus parent and focus first child, but it is problematic for expanding sibings.
         * When focus parent/child, the number of items (itemCount) in the virtual list does not change. But when sibling expand, itemCount could change.
         * When siblings are expanded:
         *  without useLayoutEffect, react window uses the itemCount before siblings are expanded, causing it to compute wrong scroll offset.
         *  with useLayoutEffect, the scrolling happens after the new itemCount passed into list as props. Therefore the computed scroll offset is correct.
         */
        if (focusIdRef.current != null && getItemRef(focusIdRef.current) == null) {
            var focusIndex = visibleItemIds.indexOf(focusIdRef.current);
            if (focusIndex >= 0) {
                (_a = listRef.current) === null || _a === void 0 ? void 0 : _a.scrollToItem(focusIndex, 'center');
            }
        }
    }, [getItemRef, visibleItemIds]);
    var searchByFirstChar = React.useCallback(function (startIndex, endIndex, char) {
        var _a, _b, _c;
        var itemToString = props.itemToString || (function (item) { return item.content || ''; });
        for (var i = startIndex; i < endIndex; ++i) {
            var itemFirstChar = (_c = (_b = (_a = itemToString(getItemById(visibleItemIds[i]).item)) === null || _a === void 0 ? void 0 : _a.trim()) === null || _b === void 0 ? void 0 : _b.charAt(0)) === null || _c === void 0 ? void 0 : _c.toLowerCase();
            if (itemFirstChar === char.toLowerCase()) {
                return i;
            }
        }
        return -1;
    }, [getItemById, props.itemToString, visibleItemIds]);
    var getToFocusIDByFirstCharacter = React.useCallback(function (e, idToStartSearch) {
        // Get start index for search
        var starIndex = visibleItemIds.indexOf(idToStartSearch) + 1;
        if (starIndex === visibleItemIds.length) {
            starIndex = 0;
        }
        // Check following nodes in tree
        var toFocusIndex = searchByFirstChar(starIndex, visibleItemIds.length, e.key);
        // If not found in following nodes, check from beginning
        if (toFocusIndex === -1) {
            toFocusIndex = searchByFirstChar(0, starIndex - 1, e.key);
        }
        if (toFocusIndex === -1) {
            return idToStartSearch;
        }
        return visibleItemIds[toFocusIndex];
    }, [searchByFirstChar, visibleItemIds]);
    return __assign(__assign({}, baseTree), { registerItemRef: registerItemRef, focusItemById: focusItemById, expandSiblings: expandSiblings, getToFocusIDByFirstCharacter: getToFocusIDByFirstCharacter, listRef: listRef });
}
exports.useVirtualTree = useVirtualTree;
