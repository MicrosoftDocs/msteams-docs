import _extends from "@babel/runtime/helpers/esm/extends";
import _some from "lodash/some";
import _invoke from "lodash/invoke";
import { toolbarItemBehavior } from '@fluentui/accessibility';
import { compose, getElementType, mergeVariablesOverrides, useUnhandledProps, useFluentContext, useAccessibility, useStyles, useTelemetry, useContextSelectors } from '@fluentui/react-bindings';
import { handleRef, Ref } from '@fluentui/react-component-ref';
import { EventListener } from '@fluentui/react-component-event-listener';
import { Unstable_NestingAuto } from '@fluentui/react-component-nesting-registry';
import * as customPropTypes from '@fluentui/react-proptypes';
import * as PropTypes from 'prop-types';
import * as React from 'react';
import { createShorthand, doesNodeContainClick, commonPropTypes, childrenExist } from '../../utils';
import { partitionPopperPropsFromShorthand, Popper } from '../../utils/positioner';
import { ToolbarMenu } from './ToolbarMenu';
import { Popup } from '../Popup/Popup';
import { ToolbarVariablesContext, ToolbarVariablesProvider } from './toolbarVariablesContext';
import { ToolbarItemWrapper } from './ToolbarItemWrapper';
import { ToolbarItemIcon } from './ToolbarItemIcon';
import { ToolbarMenuContext } from './toolbarMenuContext';
export var toolbarItemClassName = 'ui-toolbar__item';
/**
 * A ToolbarItem renders Toolbar item as a button with an icon.
 */

export var ToolbarItem = /*#__PURE__*/function () {
  var ToolbarItem = compose(function (props, ref, composeOptions) {
    var context = useFluentContext();

    var _useTelemetry = useTelemetry(composeOptions.displayName, context.telemetry),
        setStart = _useTelemetry.setStart,
        setEnd = _useTelemetry.setEnd;

    setStart();
    var accessibility = props.accessibility,
        active = props.active,
        className = props.className,
        design = props.design,
        icon = props.icon,
        children = props.children,
        disabled = props.disabled,
        disabledFocusable = props.disabledFocusable,
        popup = props.popup,
        menuOpen = props.menuOpen,
        wrapper = props.wrapper,
        styles = props.styles,
        variables = props.variables;

    var _partitionPopperProps = partitionPopperPropsFromShorthand(props.menu),
        menu = _partitionPopperProps[0],
        positioningProps = _partitionPopperProps[1];

    var itemRef = React.useRef();
    var menuRef = React.useRef();
    var parentVariables = React.useContext(ToolbarVariablesContext);
    var mergedVariables = mergeVariablesOverrides(parentVariables, variables);

    var _ref = useContextSelectors(ToolbarMenuContext, {
      menuSlot: function menuSlot(v) {
        return v.slots.menu;
      }
    }),
        menuSlot = _ref.menuSlot; // TODO: we should improve typings for the useContextSelectors


    // TODO: we should improve typings for the useContextSelectors
    var getA11yProps = useAccessibility(accessibility, {
      debugName: composeOptions.displayName,
      actionHandlers: {
        performClick: function performClick(event) {
          event.preventDefault();
          handleClick(event);
        },
        performWrapperClick: function performWrapperClick(event) {
          handleWrapperClick(event);
        },
        closeMenuAndFocusTrigger: function closeMenuAndFocusTrigger(event) {
          trySetMenuOpen(false, event);

          _invoke(itemRef.current, 'focus');
        },
        doNotNavigateNextToolbarItem: function doNotNavigateNextToolbarItem(event) {
          event.stopPropagation();
        }
      },
      mapPropsToBehavior: function mapPropsToBehavior() {
        return {
          as: String(props.as),
          disabled: disabled,
          disabledFocusable: disabledFocusable,
          hasMenu: !!menu,
          hasPopup: !!popup,
          menuOpen: menuOpen,
          active: active
        };
      },
      rtl: context.rtl
    });

    var _useStyles = useStyles(composeOptions.displayName, {
      className: composeOptions.className,
      composeOptions: composeOptions,
      mapPropsToStyles: function mapPropsToStyles() {
        return {
          active: active,
          disabled: disabled || disabledFocusable
        };
      },
      mapPropsToInlineStyles: function mapPropsToInlineStyles() {
        return {
          className: className,
          design: design,
          styles: styles,
          variables: mergedVariables
        };
      },
      rtl: context.rtl,
      unstable_props: props
    }),
        classes = _useStyles.classes;

    var handleBlur = function handleBlur(e) {
      _invoke(props, 'onBlur', e, props);
    };

    var handleFocus = function handleFocus(e) {
      _invoke(props, 'onFocus', e, props);
    };

    var handleClick = function handleClick(e) {
      if (disabled || disabledFocusable) {
        e.preventDefault();
        return;
      }

      if (menu) {
        trySetMenuOpen(!menuOpen, e);
      }

      _invoke(props, 'onClick', e, props);
    };

    var handleWrapperClick = function handleWrapperClick(e) {
      if (menu) {
        if (doesNodeContainClick(menuRef.current, e.nativeEvent, context.target, false)) {
          trySetMenuOpen(false, e);
        }
      }
    };

    var handleOutsideClick = function handleOutsideClick(getRefs) {
      return function (e) {
        var isItemClick = doesNodeContainClick(itemRef.current, e, context.target);

        var isNestedClick = _some(getRefs(), function (childRef) {
          return doesNodeContainClick(childRef.current, e, context.target);
        });

        var isInside = isItemClick || isNestedClick;

        if (!isInside) {
          trySetMenuOpen(false, e);
        }
      };
    };

    var trySetMenuOpen = function trySetMenuOpen(newValue, e) {
      _invoke(props, 'onMenuOpenChange', e, Object.assign({}, props, {
        menuOpen: newValue
      }));
    };

    var handleMenuOverrides = function handleMenuOverrides(getRefs) {
      return function (predefinedProps) {
        return {
          onBlur: function onBlur(e) {
            var isInsideOrMenuTrigger = _some(getRefs(), function (childRef) {
              return childRef.current.contains(e.relatedTarget) || itemRef.current.contains(e.relatedTarget);
            });

            if (!isInsideOrMenuTrigger) {
              trySetMenuOpen(false, e);
            }
          },
          onItemClick: function onItemClick(e, itemProps) {
            var popup = itemProps.popup,
                menuOpen = itemProps.menuOpen;

            _invoke(predefinedProps, 'onItemClick', e, itemProps);

            if (popup) {
              return;
            } // TODO: should we pass toolbarMenuItem to the user callback so he can decide if he wants to close the menu?


            // TODO: should we pass toolbarMenuItem to the user callback so he can decide if he wants to close the menu?
            trySetMenuOpen(menuOpen, e);
          }
        };
      };
    };

    var ElementType = getElementType(props);
    var slotProps = composeOptions.resolveSlotProps(props);
    var unhandledProps = useUnhandledProps(composeOptions.handledProps, props);
    var itemElement = /*#__PURE__*/React.createElement(Ref, {
      innerRef: function innerRef(node) {
        itemRef.current = node;
        handleRef(ref, node);
      }
    }, /*#__PURE__*/React.createElement(ElementType, getA11yProps('root', Object.assign({}, unhandledProps, {
      disabled: disabled,
      className: classes.root,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onClick: handleClick
    })), childrenExist(children) ? children : createShorthand(composeOptions.slots.icon, icon, slotProps.icon)));
    var submenuElement = menuOpen ? /*#__PURE__*/React.createElement(Unstable_NestingAuto, null, function (getRefs, nestingRef) {
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Ref, {
        innerRef: function innerRef(node) {
          nestingRef.current = node;
          menuRef.current = node;
        }
      }, /*#__PURE__*/React.createElement(Popper, _extends({
        align: "start",
        position: "above",
        targetRef: itemRef
      }, positioningProps), /*#__PURE__*/React.createElement(ToolbarVariablesProvider, {
        value: mergedVariables
      }, createShorthand(composeOptions.slots.menu || menuSlot || ToolbarMenu, menu, {
        defaultProps: function defaultProps() {
          return slotProps.menu;
        },
        overrideProps: handleMenuOverrides(getRefs)
      })))), /*#__PURE__*/React.createElement(EventListener, {
        listener: handleOutsideClick(getRefs),
        target: context.target,
        type: "click",
        capture: true
      }));
    }) : null;

    if (popup) {
      var popupElement = createShorthand(composeOptions.slots.popup, popup, {
        defaultProps: function defaultProps() {
          return slotProps.popup;
        },
        overrideProps: {
          trigger: itemElement,
          children: undefined // force-reset `children` defined for `Popup` as it collides with the `trigger`

        }
      });
      setEnd();
      return popupElement;
    } // wrap the item if it has menu (even if it is closed = not rendered)


    // wrap the item if it has menu (even if it is closed = not rendered)
    if (menu) {
      var contentElement = /*#__PURE__*/React.createElement(React.Fragment, null, itemElement, submenuElement);

      if (wrapper) {
        var wrapperElement = createShorthand(composeOptions.slots.wrapper, wrapper, {
          defaultProps: function defaultProps() {
            return getA11yProps('wrapper', slotProps.wrapper || {});
          },
          overrideProps: function overrideProps(predefinedProps) {
            return {
              children: contentElement,
              onClick: function onClick(e) {
                handleWrapperClick(e);

                _invoke(predefinedProps, 'onClick', e);
              }
            };
          }
        });
        setEnd();
        return wrapperElement;
      }

      setEnd();
      return contentElement;
    }

    setEnd();
    return itemElement;
  }, {
    className: toolbarItemClassName,
    displayName: 'ToolbarItem',
    slots: {
      icon: ToolbarItemIcon,
      wrapper: ToolbarItemWrapper,
      popup: Popup // TODO: compose Popup to ToolbarItemPopup once it has compose functionality

    },
    slotProps: function slotProps() {
      return {
        popup: {
          trapFocus: true
        }
      };
    },
    shorthandConfig: {
      mappedProp: 'content'
    },
    handledProps: ['accessibility', 'as', 'children', 'className', 'content', 'design', 'styles', 'disabledFocusable', 'variables', 'active', 'disabled', 'icon', 'menu', 'menuOpen', 'onMenuOpenChange', 'onClick', 'onFocus', 'onBlur', 'popup', 'wrapper']
  });
  ToolbarItem.propTypes = Object.assign({}, commonPropTypes.createCommon(), {
    active: PropTypes.bool,
    disabled: PropTypes.bool,
    disabledFocusable: PropTypes.bool,
    icon: customPropTypes.shorthandAllowingChildren,
    menu: PropTypes.oneOfType([customPropTypes.shorthandAllowingChildren, PropTypes.arrayOf(customPropTypes.shorthandAllowingChildren)]),
    menuOpen: PropTypes.bool,
    onMenuOpenChange: PropTypes.func,
    onClick: PropTypes.func,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func,
    popup: PropTypes.oneOfType([PropTypes.shape(Object.assign({}, Popup.propTypes, {
      trigger: customPropTypes.never,
      children: customPropTypes.never
    })), PropTypes.string]),
    wrapper: customPropTypes.shorthandAllowingChildren
  });
  ToolbarItem.defaultProps = {
    as: 'button',
    accessibility: toolbarItemBehavior,
    wrapper: {}
  };
  return ToolbarItem;
}();
//# sourceMappingURL=ToolbarItem.js.map
