"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenTree = void 0;
// Fluent UI Tree component does not have a root item.
// Adding a 'secret' root (level=0) helps traversing among the top level (level=1) tree items.
// This 'secret' root should NOT be returned as part of orderedItemIds, because it is not an item from user props
var SECRET_ROOT_ID = 'FLUENT_UI_SECRET_ROOT_ID';
/**
 * @returns returns the flattened tree, and an array of all visible tree item ids in a Depth First order.
 */
function flattenTree(items, activeItemIds, selectedItemIds) {
    var _a;
    var flatTree = (_a = {},
        _a[SECRET_ROOT_ID] = {
            index: 1,
            level: 0,
            expanded: true,
            treeSize: 1,
            hasSubtree: true,
        },
        _a);
    // returns an extra array of orderedItemIds because flattened tree object does not keep the order of insertion
    return flattenSubTree(items, 1, SECRET_ROOT_ID, flatTree, true, activeItemIds, [], selectedItemIds);
}
exports.flattenTree = flattenTree;
function flattenSubTree(items, level, parent, flatTree, isParentVisible, activeItemIds, visibleItemIds, selectedItemIds) {
    if (level === void 0) { level = 1; }
    if (isParentVisible === void 0) { isParentVisible = true; }
    if (!items) {
        return { flatTree: flatTree, visibleItemIds: visibleItemIds, selectedChildrenNum: 0, selectableChildrenNum: 0 };
    }
    var itemsInLeaf = items.length;
    var selectedNum = 0;
    var selectableNum = 0;
    items.forEach(function (item, indexAmongSiblings) {
        var id = item.id, childrenItems = item.items;
        var selectable = item.selectable !== false; // by default item is selectable, unless selectable=false specified
        var hasSubtree = childrenItems ? !!childrenItems.length : false;
        var expanded = hasSubtree && activeItemIds.indexOf(id) !== -1;
        flatTree[id] = {
            item: item,
            index: indexAmongSiblings + 1,
            level: level,
            expanded: expanded,
            parent: parent == null ? undefined : parent,
            treeSize: itemsInLeaf,
            hasSubtree: hasSubtree,
            selected: false,
        };
        if (isParentVisible) {
            visibleItemIds.push(id);
        }
        var _a = flattenSubTree(childrenItems, level + 1, id, flatTree, isParentVisible && expanded, // parent being visible and expanded means subtree is visible
        activeItemIds, visibleItemIds, selectedItemIds), selectedChildrenNum = _a.selectedChildrenNum, selectableChildrenNum = _a.selectableChildrenNum;
        if (selectable) {
            selectableNum++;
            if ((hasSubtree && selectedChildrenNum === selectableChildrenNum) ||
                (!hasSubtree && selectedItemIds.indexOf(id) >= 0) // selectedItemIds only make sense for leaf nodes
            ) {
                flatTree[id].selected = true;
                selectedNum++;
            }
            else if (selectedChildrenNum > 0) {
                flatTree[id].selected = 'indeterminate';
                selectedNum += 0.5; // trick to propagate indeterminate state to ancestors
            }
        }
        if (flatTree[parent].childrenIds) {
            flatTree[parent].childrenIds.push(id);
        }
        else {
            flatTree[parent].childrenIds = [id];
        }
    });
    return { flatTree: flatTree, visibleItemIds: visibleItemIds, selectedChildrenNum: selectedNum, selectableChildrenNum: selectableNum };
}
