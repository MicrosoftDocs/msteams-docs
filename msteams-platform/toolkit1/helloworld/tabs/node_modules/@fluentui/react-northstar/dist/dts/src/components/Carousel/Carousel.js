"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Carousel = exports.carouselSlotClassNames = exports.carouselClassName = void 0;
var customPropTypes = require("@fluentui/react-proptypes");
var accessibility_1 = require("@fluentui/accessibility");
var React = require("react");
var _ = require("lodash");
var PropTypes = require("prop-types");
var classnames_1 = require("classnames");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var Animation_1 = require("../Animation/Animation");
var utils_1 = require("../../utils");
var CarouselItem_1 = require("./CarouselItem");
var Text_1 = require("../Text/Text");
var CarouselNavigation_1 = require("./CarouselNavigation");
var CarouselNavigationItem_1 = require("./CarouselNavigationItem");
var CarouselPaddle_1 = require("./CarouselPaddle");
var react_bindings_1 = require("@fluentui/react-bindings");
var state_1 = require("@fluentui/state");
var CarouselPaddlesContainer_1 = require("./CarouselPaddlesContainer");
exports.carouselClassName = 'ui-carousel';
exports.carouselSlotClassNames = {
    itemsContainer: exports.carouselClassName + "__itemscontainer",
    paddleNext: exports.carouselClassName + "__paddlenext",
    paddlePrevious: exports.carouselClassName + "__paddleprevious",
    pagination: exports.carouselClassName + "__pagination",
    navigation: exports.carouselClassName + "__navigation",
};
/**
 * A Carousel displays data organised as a gallery.
 *
 * @accessibility
 * Implements [ARIA Carousel](https://www.w3.org/WAI/tutorials/carousels/structure/) design pattern.
 * @accessibilityIssues
 * [VoiceOver doens't narrate label referenced by aria-labelledby attribute, when role is "tabpanel"](https://bugs.chromium.org/p/chromium/issues/detail?id=1040924)
 */
exports.Carousel = React.forwardRef(function (props, ref) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Carousel.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, items = props.items, circular = props.circular, getItemPositionText = props.getItemPositionText, paddlePrevious = props.paddlePrevious, paddleNext = props.paddleNext, navigation = props.navigation, thumbnails = props.thumbnails, children = props.children, ariaRoleDescription = props["aria-roledescription"], ariaLabel = props["aria-label"], className = props.className, design = props.design, styles = props.styles, variables = props.variables, disableClickableNav = props.disableClickableNav;
    var ElementType = react_bindings_1.getElementType(props);
    var _b = react_bindings_1.useStateManager(state_1.createCarouselManager, {
        mapPropsToInitialState: function () { return ({
            activeIndex: props.defaultActiveIndex,
        }); },
        mapPropsToState: function () { return ({
            activeIndex: props.activeIndex,
        }); },
    }), state = _b.state, actions = _b.actions;
    var ariaLiveOn = state.ariaLiveOn, shouldFocusContainer = state.shouldFocusContainer, isFromKeyboard = state.isFromKeyboard, activeIndex = state.activeIndex;
    var prevActiveIndex = react_bindings_1.usePrevious(activeIndex);
    var itemRefs = React.useMemo(function () { return Array.from({ length: items === null || items === void 0 ? void 0 : items.length }, function () { return React.createRef(); }); }, 
    // As we are using "panels.length" it's fine to have dependency on them
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [items === null || items === void 0 ? void 0 : items.length]);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Carousel.handledProps, props);
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: exports.Carousel.displayName,
        actionHandlers: {
            showNextSlideByKeyboardNavigation: function (e) {
                e.preventDefault();
                showNextSlide(e, true);
            },
            showPreviousSlideByKeyboardNavigation: function (e) {
                e.preventDefault();
                showPreviousSlide(e, true);
            },
            showNextSlideByPaddlePress: function (e) {
                e.preventDefault();
                showNextSlide(e, false);
                handleNextPaddleFocus();
            },
            showPreviousSlideByPaddlePress: function (e) {
                e.preventDefault();
                showPreviousSlide(e, false);
                handlePreviousPaddleFocus();
            },
        },
        mapPropsToBehavior: function () { return ({
            navigation: navigation,
            ariaLiveOn: ariaLiveOn,
            'aria-roledescription': ariaRoleDescription,
            'aria-label': ariaLabel,
        }); },
    });
    var classes = react_bindings_1.useStyles(exports.Carousel.displayName, {
        className: exports.carouselClassName,
        mapPropsToStyles: function () { return ({
            shouldFocusContainer: shouldFocusContainer,
            isFromKeyboard: isFromKeyboard,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }).classes;
    var paddleNextRef = React.useRef();
    var paddlePreviousRef = React.useRef();
    var focusItemAtIndex = React.useMemo(function () {
        return _.debounce(function (index) {
            var _a;
            (_a = itemRefs[index].current) === null || _a === void 0 ? void 0 : _a.focus();
        }, 400);
    }, [itemRefs]);
    React.useEffect(function () {
        return function () {
            focusItemAtIndex.cancel();
        };
    }, [focusItemAtIndex, items]);
    var setActiveIndex = function (e, index, focusItem) {
        var lastItemIndex = items.length - 1;
        var nextActiveIndex = index;
        if (index < 0) {
            if (!circular) {
                return;
            }
            nextActiveIndex = lastItemIndex;
        }
        if (index > lastItemIndex) {
            if (!circular) {
                return;
            }
            nextActiveIndex = 0;
        }
        actions.setIndexes(nextActiveIndex);
        _.invoke(props, 'onActiveIndexChange', e, __assign(__assign({}, props), { activeIndex: index }));
        if (focusItem) {
            focusItemAtIndex(nextActiveIndex);
        }
    };
    var overrideItemProps = function (predefinedProps) { return ({
        onFocus: function (e, itemProps) {
            actions.setShouldFocusContainer(e.currentTarget === e.target);
            actions.setIsFromKeyboard(utils_1.isFromKeyboard());
            _.invoke(predefinedProps, 'onFocus', e, itemProps);
        },
        onBlur: function (e, itemProps) {
            actions.setShouldFocusContainer(e.currentTarget.contains(e.relatedTarget));
            actions.setIsFromKeyboard(false);
            _.invoke(predefinedProps, 'onBlur', e, itemProps);
        },
    }); };
    var renderContent = function () {
        return (React.createElement("div", __assign({}, getA11yProps('itemsContainerWrapper', {
            className: classes.itemsContainerWrapper,
        })),
            React.createElement("div", __assign({}, getA11yProps('itemsContainer', {
                className: classnames_1.default(exports.carouselSlotClassNames.itemsContainer, classes.itemsContainer),
            })), items &&
                items.map(function (item, index) {
                    var itemRef = itemRefs[index];
                    var active = activeIndex === index;
                    var slideToNext = prevActiveIndex < activeIndex;
                    var initialMounting = prevActiveIndex === -1;
                    if (circular && prevActiveIndex === items.length - 1 && activeIndex === 0) {
                        slideToNext = true;
                    }
                    else if (circular && prevActiveIndex === 0 && activeIndex === items.length - 1) {
                        slideToNext = false;
                    }
                    return (React.createElement(Animation_1.Animation, { key: item['key'] || index, mountOnEnter: true, unmountOnExit: true, visible: active, name: initialMounting || !active || prevActiveIndex === index
                            ? ''
                            : slideToNext
                                ? 'carousel-slide-to-next-enter'
                                : 'carousel-slide-to-previous-enter' },
                        React.createElement(react_component_ref_1.Ref, { innerRef: itemRef }, CarouselItem_1.CarouselItem.create(item, {
                            defaultProps: function () { return (__assign({ active: active, navigation: !!navigation }, (getItemPositionText && {
                                itemPositionText: getItemPositionText(index, items.length),
                            }))); },
                            overrideProps: overrideItemProps,
                        }))));
                }))));
    };
    var handleNextPaddleFocus = function () {
        // if 'next' paddle will disappear, will focus 'previous' one.
        if (!navigation && activeIndex >= props.items.length - 2 && !circular) {
            paddlePreviousRef.current.focus();
        }
    };
    var handlePreviousPaddleFocus = function () {
        // if 'previous' paddle will disappear, will focus 'next' one.
        if (!navigation && activeIndex <= 1 && !circular) {
            paddleNextRef.current.focus();
        }
    };
    var showPreviousSlide = function (e, focusItem) {
        setActiveIndex(e, +activeIndex - 1, focusItem);
    };
    var showNextSlide = function (e, focusItem) {
        setActiveIndex(e, +activeIndex + 1, focusItem);
    };
    var handlePaddleOverrides = function (predefinedProps, paddleName) { return ({
        variables: react_bindings_1.mergeVariablesOverrides(variables, predefinedProps.variables),
        onClick: function (e, paddleProps) {
            if (disableClickableNav)
                return;
            _.invoke(predefinedProps, 'onClick', e, paddleProps);
            if (paddleName === 'paddleNext') {
                showNextSlide(e, false);
                handleNextPaddleFocus();
            }
            else if (paddleName === 'paddlePrevious') {
                showPreviousSlide(e, false);
                handlePreviousPaddleFocus();
            }
        },
        onBlur: function (e, paddleProps) {
            if (e.relatedTarget !== paddleNextRef.current) {
                actions.setAriaLiveOn(false);
            }
        },
        onFocus: function (e, paddleProps) {
            _.invoke(predefinedProps, 'onFocus', e, paddleProps);
            actions.setAriaLiveOn(true);
        },
    }); };
    var paddles = (React.createElement(React.Fragment, null,
        React.createElement(react_component_ref_1.Ref, { innerRef: paddlePreviousRef }, CarouselPaddle_1.CarouselPaddle.create(paddlePrevious, {
            defaultProps: function () {
                return getA11yProps('paddlePrevious', {
                    className: exports.carouselSlotClassNames.paddlePrevious,
                    previous: true,
                    hidden: items !== undefined && !circular && activeIndex === 0,
                    disableClickableNav: disableClickableNav,
                });
            },
            overrideProps: function (predefinedProps) {
                return handlePaddleOverrides(predefinedProps, 'paddlePrevious');
            },
        })),
        React.createElement(react_component_ref_1.Ref, { innerRef: paddleNextRef }, CarouselPaddle_1.CarouselPaddle.create(paddleNext, {
            defaultProps: function () {
                return getA11yProps('paddleNext', {
                    className: exports.carouselSlotClassNames.paddleNext,
                    next: true,
                    hidden: items !== undefined && !circular && activeIndex === items.length - 1,
                    disableClickableNav: disableClickableNav,
                });
            },
            overrideProps: function (predefinedProps) { return handlePaddleOverrides(predefinedProps, 'paddleNext'); },
        }))));
    var renderPaddles = function () {
        return utils_1.createShorthand(CarouselPaddlesContainer_1.CarouselPaddlesContainer, {}, {
            overrideProps: function () { return ({
                children: paddles,
            }); },
        });
    };
    var renderNavigation = function () {
        if (!items || !items.length) {
            return null;
        }
        return navigation ? (CarouselNavigation_1.CarouselNavigation.create(navigation, {
            defaultProps: function () { return ({
                className: exports.carouselSlotClassNames.navigation,
                iconOnly: true,
                activeIndex: activeIndex,
                thumbnails: thumbnails,
                disableClickableNav: disableClickableNav,
            }); },
            overrideProps: function (predefinedProps) { return ({
                onItemClick: function (e, itemProps) {
                    if (disableClickableNav)
                        return;
                    var index = itemProps.index;
                    setActiveIndex(e, index, true);
                    _.invoke(predefinedProps, 'onClick', e, itemProps);
                },
            }); },
        })) : getItemPositionText ? (React.createElement(Text_1.Text, { "aria-hidden": "true", align: "center", as: "div", className: exports.carouselSlotClassNames.pagination, content: getItemPositionText(+activeIndex, items.length) })) : null;
    };
    var element = (React.createElement(ElementType, __assign({}, getA11yProps('root', __assign({ className: classes.root, ref: ref }, unhandledProps))), utils_1.childrenExist(children) ? (children) : (React.createElement(React.Fragment, null,
        renderPaddles(),
        renderContent(),
        renderNavigation()))));
    setEnd();
    return element;
});
exports.Carousel.displayName = 'Carousel';
exports.Carousel.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    content: false,
})), { activeIndex: PropTypes.number, 'aria-roledescription': PropTypes.string, 'aria-label': PropTypes.string, circular: PropTypes.bool, defaultActiveIndex: PropTypes.number, getItemPositionText: PropTypes.func, items: customPropTypes.collectionShorthand, navigation: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]), navigationPosition: PropTypes.oneOf(['below', 'above', 'start', 'end']), onActiveIndexChange: PropTypes.func, paddleNext: customPropTypes.itemShorthand, paddlesPosition: PropTypes.oneOf(['inside', 'outside', 'inline']), paddlePrevious: customPropTypes.itemShorthand, thumbnails: PropTypes.bool, disableClickableNav: PropTypes.bool });
exports.Carousel.defaultProps = {
    accessibility: accessibility_1.carouselBehavior,
    paddlePrevious: {},
    paddleNext: {},
};
exports.Carousel.Item = CarouselItem_1.CarouselItem;
exports.Carousel.Navigation = CarouselNavigation_1.CarouselNavigation;
exports.Carousel.NavigationItem = CarouselNavigationItem_1.CarouselNavigationItem;
exports.Carousel.Paddle = CarouselPaddle_1.CarouselPaddle;
exports.Carousel.PaddlesContainer = CarouselPaddlesContainer_1.CarouselPaddlesContainer;
exports.Carousel.handledProps = Object.keys(exports.Carousel.propTypes);
exports.Carousel.create = utils_1.createShorthandFactory({
    Component: exports.Carousel,
    mappedArrayProp: 'items',
});
