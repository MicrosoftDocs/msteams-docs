{"version":3,"sources":["utils/positioner/Popper.tsx"],"names":["useIsomorphicLayoutEffect","useMergedRefs","Ref","isRefObject","React","getPlacement","usePopper","Popper","props","usesRenderProps","children","proposedPlacement","align","position","rtl","latestPlacement","useRef","useState","computedPlacement","setComputedPlacement","popperRef","onStateUpdate","state","placement","current","targetRef","containerRef","arrowRef","pointerTargetRef","scheduleUpdate","useCallback","updatePosition","child","Children","only","defaultProps","enabled","modifiers","positionFixed","positioningDependencies"],"mappings":"AAAA,SAASA,yBAAT,EAAoCC,aAApC,QAAyD,0BAAzD;AACA,SAASC,GAAT,EAAcC,WAAd,QAAiC,+BAAjC;AAEA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AAEA,SAASC,YAAT,QAA6B,qBAA7B;AAEA,SAASC,SAAT,QAA0B,aAA1B;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,MAAN;AAAA,MAAMA,MAA4C,GAAG,SAA/CA,MAA+C,CAAAC,KAAK,EAAI;AACnE,QAAMC,eAAwB,GAAG,OAAOD,KAAK,CAACE,QAAb,KAA0B,UAA3D;AAEA,QAAMC,iBAAiB,GAAGN,YAAY,CAACG,KAAK,CAACI,KAAP,EAAcJ,KAAK,CAACK,QAApB,EAA8BL,KAAK,CAACM,GAApC,CAAtC;AACA,QAAMC,eAAe,GAAGX,KAAK,CAACY,MAAN,CAAiCL,iBAAjC,CAAxB;;AACA,0BAAkDP,KAAK,CAACa,QAAN,CAAmCN,iBAAnC,CAAlD;AAAA,QAAOO,iBAAP;AAAA,QAA0BC,oBAA1B;;AAEA,QAAMC,SAAS,GAAGhB,KAAK,CAACY,MAAN,CAAqC,IAArC,CAAlB;;AACA,qBAA8CV,SAAS,mBAClDE,KADkD;AAGrDY,MAAAA,SAAS,EAAEnB,aAAa,CAACO,KAAK,CAACY,SAAP,EAAkBA,SAAlB,CAH6B;AAIrDC,MAAAA,aAAa,EAAE,uBAAAC,KAAK,EAAI;AACtB;AACA;AACA,YAAIA,KAAK,CAACC,SAAN,KAAoBR,eAAe,CAACS,OAAxC,EAAiD;AAC/CT,UAAAA,eAAe,CAACS,OAAhB,GAA0BF,KAAK,CAACC,SAAhC,CAD+C,CAG/C;;AAAA;AACA,cAAId,eAAJ,EAAqB;AACnBU,YAAAA,oBAAoB,CAACG,KAAK,CAACC,SAAP,CAApB;AACD;AACF;AACF;AAfoD,OAAvD;AAAA,QAAQE,SAAR,cAAQA,SAAR;AAAA,QAAmBC,YAAnB,cAAmBA,YAAnB;AAAA,QAAiCC,QAAjC,cAAiCA,QAAjC;;AAkBA3B,IAAAA,yBAAyB,CAAC,YAAM;AAAA;;AAC9B;AACA;AACAyB,MAAAA,SAAS,CAACD,OAAV,GAAoBrB,WAAW,CAACK,KAAK,CAACiB,SAAP,CAAX,GACfjB,KAAK,CAACiB,SAAP,CAA8CD,OAD9B,GAEfhB,KAAK,CAACiB,SAFX;AAGAE,MAAAA,QAAQ,CAACH,OAAT,4BAAmBhB,KAAK,CAACoB,gBAAzB,qBAAmB,sBAAwBJ,OAA3C;AACD,KAPwB,CAAzB;AASA,QAAMK,cAAc,GAAGzB,KAAK,CAAC0B,WAAN,CAAkB,YAAM;AAAA;;AAC7C,4BAAAV,SAAS,CAACI,OAAV,wCAAmBO,cAAnB;AACD,KAFsB,EAEpB,EAFoB,CAAvB;AAIA,QAAMC,KAAK,GAAGvB,eAAe,GACxBD,KAAK,CAACE,QAAP,CAAqC;AACnCa,MAAAA,SAAS,EAAEL,iBADwB;AAEnCW,MAAAA,cAAc,EAAdA;AAFmC,KAArC,CADyB,GAKxBrB,KAAK,CAACE,QALX;AAOA,WAAOsB,KAAK,gBAAG,oBAAC,GAAD;AAAK,MAAA,QAAQ,EAAEN;AAAf,OAA8BtB,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAAoBF,KAApB,CAA9B,CAAH,GAAqE,IAAjF;AACD,GA/CM;;AAiDPzB,EAAAA,MAAM,CAAC4B,YAAP,GAAsB;AACpBC,IAAAA,OAAO,EAAE,IADW;AAEpBC,IAAAA,SAAS,EAAE,EAFS;AAGpBC,IAAAA,aAAa,EAAE,KAHK;AAIpBC,IAAAA,uBAAuB,EAAE;AAJL,GAAtB;AAjDO,SAAMhC,MAAN;AAAA","sourcesContent":["import { useIsomorphicLayoutEffect, useMergedRefs } from '@fluentui/react-bindings';\nimport { Ref, isRefObject } from '@fluentui/react-component-ref';\nimport * as PopperJs from '@popperjs/core';\nimport * as React from 'react';\n\nimport { getPlacement } from './positioningHelper';\nimport { PopperChildrenFn, PopperProps, PopperRefHandle } from './types';\nimport { usePopper } from './usePopper';\n\n/**\n * Popper relies on the 3rd party library [Popper.js](https://github.com/FezVrasta/popper.js) for positioning.\n *\n * @deprecated Please use \"usePopper()\" hook instead.\n */\nexport const Popper: React.FunctionComponent<PopperProps> = props => {\n  const usesRenderProps: boolean = typeof props.children === 'function';\n\n  const proposedPlacement = getPlacement(props.align, props.position, props.rtl);\n  const latestPlacement = React.useRef<PopperJs.Placement>(proposedPlacement);\n  const [computedPlacement, setComputedPlacement] = React.useState<PopperJs.Placement>(proposedPlacement);\n\n  const popperRef = React.useRef<PopperRefHandle | null>(null);\n  const { targetRef, containerRef, arrowRef } = usePopper({\n    ...props,\n\n    popperRef: useMergedRefs(props.popperRef, popperRef),\n    onStateUpdate: state => {\n      // PopperJS performs computations that might update the computed placement: auto positioning, flipping the\n      // placement in case the popper box should be rendered at the edge of the viewport and does not fit\n      if (state.placement !== latestPlacement.current) {\n        latestPlacement.current = state.placement;\n\n        // A state change has sense only if renderProps are passed, otherwise a state value is unused\n        if (usesRenderProps) {\n          setComputedPlacement(state.placement);\n        }\n      }\n    },\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    // A way to sync refs, is needed as Popper component accepts refs as params\n    // Does not make anything worse as Popper component does not have proper handing for ref updates ¯\\_(ツ)_/¯\n    targetRef.current = isRefObject(props.targetRef)\n      ? (props.targetRef as React.RefObject<Element>).current\n      : (props.targetRef as PopperJs.VirtualElement);\n    arrowRef.current = props.pointerTargetRef?.current as HTMLElement;\n  });\n\n  const scheduleUpdate = React.useCallback(() => {\n    popperRef.current?.updatePosition();\n  }, []);\n\n  const child = usesRenderProps\n    ? (props.children as PopperChildrenFn)({\n        placement: computedPlacement,\n        scheduleUpdate,\n      })\n    : (props.children as React.ReactElement);\n\n  return child ? <Ref innerRef={containerRef}>{React.Children.only(child)}</Ref> : null;\n};\n\nPopper.defaultProps = {\n  enabled: true,\n  modifiers: [],\n  positionFixed: false,\n  positioningDependencies: [],\n};\n"],"file":"Popper.js"}