"use strict";
/**
 * Synthetic Event
 *
 * Names of all synthetic events and their event shape.
 * Methods are also included for comparing and validated event objects.
 *
 * https://facebook.github.io/react/docs/events.html
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasShape = exports.types = void 0;
var noop = function () { return undefined; };
var baseShape = {
    bubbles: null,
    cancelable: null,
    currentTarget: null,
    defaultPrevented: null,
    eventPhase: null,
    isTrusted: null,
    nativeEvent: null,
    persist: noop,
    preventDefault: noop,
    isDefaultPrevented: noop,
    stopPropagation: noop,
    isPropagationStopped: noop,
    target: null,
    timeStamp: null,
    type: null,
};
// ------------------------------------
// Event Types
// ------------------------------------
exports.types = {
    clipboard: {
        listeners: ['onCopy', 'onCut', 'onPaste'],
        eventShape: __assign(__assign({}, baseShape), { clipboardData: null }),
    },
    composition: {
        listeners: ['onCompositionEnd', 'onCompositionStart', 'onCompositionUpdate'],
        eventShape: __assign(__assign({}, baseShape), { data: null }),
    },
    keyboard: {
        listeners: ['onKeyDown', 'onKeyPress', 'onKeyUp'],
        eventShape: __assign(__assign({}, baseShape), { altKey: null, charCode: null, ctrlKey: null, getModifierState: noop, key: null, keyCode: null, locale: null, location: null, metaKey: null, repeat: null, shiftKey: null, which: null }),
    },
    focus: {
        listeners: ['onFocus', 'onBlur'],
        eventShape: __assign(__assign({}, baseShape), { relatedTarget: null }),
    },
    form: {
        listeners: ['onChange', 'onInput', 'onSubmit'],
        eventShape: __assign({}, baseShape),
    },
    mouse: {
        listeners: [
            'onClick',
            'onContextMenu',
            'onDoubleClick',
            'onDrag',
            'onDragEnd',
            'onDragEnter',
            'onDragExit',
            'onDragLeave',
            'onDragOver',
            'onDragStart',
            'onDrop',
            'onMouseDown',
            'onMouseEnter',
            'onMouseLeave',
            'onMouseMove',
            'onMouseOut',
            'onMouseOver',
            'onMouseUp',
        ],
        eventShape: __assign(__assign({}, baseShape), { altKey: null, button: null, buttons: null, clientX: null, clientY: null, ctrlKey: null, getModifierState: noop, metaKey: null, pageX: null, pageY: null, relatedTarget: null, screenX: null, screenY: null, shiftKey: null }),
    },
    selection: {
        listeners: ['onSelect'],
        eventShape: __assign({}, baseShape),
    },
    touch: {
        listeners: ['onTouchCancel', 'onTouchEnd', 'onTouchMove', 'onTouchStart'],
        eventShape: __assign(__assign({}, baseShape), { altKey: null, changedTouches: null, ctrlKey: null, getModifierState: noop, metaKey: null, shiftKey: null, targetTouches: null, touches: null }),
    },
    ui: {
        listeners: ['onScroll'],
        eventShape: __assign(__assign({}, baseShape), { detail: null, view: null }),
    },
    wheel: {
        listeners: ['onWheel'],
        eventShape: __assign(__assign({}, baseShape), { deltaMode: null, deltaX: null, deltaY: null, deltaZ: null }),
    },
    media: {
        listeners: [
            'onAbort',
            'onCanPlay',
            'onCanPlayThrough',
            'onDurationChange',
            'onEmptied',
            'onEncrypted',
            'onEnded',
            'onError',
            'onLoadedData',
            'onLoadedMetadata',
            'onLoadStart',
            'onPause',
            'onPlay',
            'onPlaying',
            'onProgress',
            'onRateChange',
            'onSeeked',
            'onSeeking',
            'onStalled',
            'onSuspend',
            'onTimeUpdate',
            'onVolumeChange',
            'onWaiting',
        ],
        eventShape: __assign({}, baseShape),
    },
    image: {
        listeners: ['onLoad', 'onError'],
        eventShape: __assign({}, baseShape),
    },
    animation: {
        listeners: ['onAnimationStart', 'onAnimationEnd', 'onAnimationIteration'],
        eventShape: __assign(__assign({}, baseShape), { animationName: null, pseudoElement: null, elapsedTime: null }),
    },
    transition: {
        listeners: ['onTransitionEnd'],
        eventShape: __assign(__assign({}, baseShape), { propertyName: null, pseudoElement: null, elapsedTime: null }),
    },
};
// ------------------------------------
// Methods
// ------------------------------------
/**
 * Determine if an event object has the shape of the event type specified.
 * @param event - The event object to test.
 * @param type - The string name of the event shape or actual event shape to compare against.
 */
var hasShape = function (event, type) {
    var shape = typeof type === 'string' ? exports.types[type].shape : type;
    return Object.keys(event).every(function (key) { return key in shape; });
};
exports.hasShape = hasShape;
