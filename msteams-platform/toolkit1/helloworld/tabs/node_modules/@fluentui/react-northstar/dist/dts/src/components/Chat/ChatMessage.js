"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatMessage = exports.chatMessageSlotClassNames = exports.chatMessageClassName = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var classnames_1 = require("classnames");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var positioner_1 = require("../../utils/positioner");
var Box_1 = require("../Box/Box");
var Flex_1 = require("../Flex/Flex");
var Label_1 = require("../Label/Label");
var Menu_1 = require("../Menu/Menu");
var PortalInner_1 = require("../Portal/PortalInner");
var Reaction_1 = require("../Reaction/Reaction");
var Text_1 = require("../Text/Text");
var chatContext_1 = require("./chatContext");
var chatItemContext_1 = require("./chatItemContext");
var ChatMessageDetails_1 = require("./ChatMessageDetails");
var ChatMessageHeader_1 = require("./ChatMessageHeader");
var ChatMessageReadStatus_1 = require("./ChatMessageReadStatus");
exports.chatMessageClassName = 'ui-chat__message';
exports.chatMessageSlotClassNames = {
    actionMenu: exports.chatMessageClassName + "__actions",
    author: exports.chatMessageClassName + "__author",
    badge: exports.chatMessageClassName + "__badge",
    bar: exports.chatMessageClassName + "__bar",
    compactBody: exports.chatMessageClassName + "__compact-body",
    content: exports.chatMessageClassName + "__content",
    reactionGroup: exports.chatMessageClassName + "__reactions",
    timestamp: exports.chatMessageClassName + "__timestamp",
};
function partitionActionMenuPropsFromShorthand(value) {
    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        var _a = value, inline = _a.inline, showActionMenu = _a.showActionMenu, props = __rest(_a, ["inline", "showActionMenu"]);
        return [props, inline !== null && inline !== void 0 ? inline : true, showActionMenu];
    }
    return [value, true, false];
}
/**
 * A ChatMessage represents a single message in chat.
 */
exports.ChatMessage = React.forwardRef(function (inputProps, ref) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.ChatMessage.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var parentAttached = react_bindings_1.useContextSelector(chatItemContext_1.ChatItemContext, function (v) { return v.attached; });
    var chatProps = chatContext_1.useChatContextSelectors({
        density: function (v) { return v.density; },
        accessibility: function (v) { return v.behaviors.message; },
    });
    var props = __assign(__assign({}, inputProps), { density: inputProps.density === undefined ? chatProps.density : inputProps.density, accessibility: inputProps.accessibility === undefined
            ? chatProps.accessibility || accessibility_1.chatMessageBehavior
            : inputProps.accessibility });
    var accessibility = props.accessibility, _b = props.attached, attached = _b === void 0 ? parentAttached : _b, author = props.author, badge = props.badge, badgePosition = props.badgePosition, children = props.children, className = props.className, compactBody = props.compactBody, content = props.content, density = props.density, design = props.design, details = props.details, header = props.header, mine = props.mine, positionActionMenu = props.positionActionMenu, reactionGroup = props.reactionGroup, reactionGroupPosition = props.reactionGroupPosition, readStatus = props.readStatus, styles = props.styles, timestamp = props.timestamp, overflow = props.unstable_overflow, variables = props.variables;
    var _c = positioner_1.partitionPopperPropsFromShorthand(props.actionMenu), actionMenuOptions = _c[0], positioningProps = _c[1];
    var _d = partitionActionMenuPropsFromShorthand(actionMenuOptions), actionMenu = _d[0], inlineActionMenu = _d[1], controlledShowActionMenu = _d[2];
    var _e = react_bindings_1.useAutoControlled({
        defaultValue: false,
        value: controlledShowActionMenu,
    }), showActionMenu = _e[0], setShowActionMenu = _e[1];
    var hasActionMenu = !_.isNil(actionMenu);
    var hasHeaderReactionGroup = !!reactionGroup && reactionGroupPosition === 'start';
    var actionMenuId = React.useRef();
    actionMenuId.current = utils_1.getOrGenerateIdFromShorthand(exports.chatMessageClassName + "-", actionMenu, actionMenuId.current);
    var modifiers = React.useCallback(function (target, container) {
        return (positionActionMenu && [
            // https://popper.js.org/docs/v2/modifiers/flip/
            // Forces to flip only in "top-*" positions
            { name: 'flip', options: { fallbackPlacements: ['top'] } },
            overflow && {
                name: 'preventOverflow',
                options: { boundary: positioner_1.getScrollParent(container) },
            },
        ]);
    }, [positionActionMenu, overflow]);
    var popperRef = React.useRef();
    var _f = positioner_1.usePopper(__assign(__assign({ align: 'end', position: 'above', positionFixed: overflow, enabled: hasActionMenu && positionActionMenu, modifiers: modifiers }, positioningProps), { popperRef: react_bindings_1.useMergedRefs(positioningProps === null || positioningProps === void 0 ? void 0 : positioningProps.popperRef, popperRef) })), messageRef = _f.targetRef, actionsMenuRef = _f.containerRef;
    // `focused` state is used for show/hide actionMenu
    var _g = React.useState(false), focused = _g[0], setFocused = _g[1];
    var getA11Props = react_bindings_1.useAccessibility(accessibility, {
        actionHandlers: {
            // prevents default FocusZone behavior, e.g., in ChatMessageBehavior, it prevents FocusZone from using arrow keys
            // as navigation (only Tab key should work)
            preventDefault: function (event) {
                // preventDefault only if event coming from inside the message
                if (event.currentTarget !== event.target) {
                    event.preventDefault();
                }
            },
            focus: function (event) {
                if (messageRef.current) {
                    messageRef.current.focus();
                    event.stopPropagation();
                }
            },
        },
        debugName: exports.ChatMessage.displayName,
        mapPropsToBehavior: function () { return ({
            hasActionMenu: hasActionMenu,
            inlineActionMenu: inlineActionMenu,
            actionMenuId: actionMenuId.current,
        }); },
        rtl: context.rtl,
    });
    var _h = react_bindings_1.useStyles(exports.ChatMessage.displayName, {
        className: exports.chatMessageClassName,
        mapPropsToStyles: function () { return ({
            attached: attached,
            badgePosition: badgePosition,
            density: density,
            focused: focused,
            hasActionMenu: hasActionMenu,
            hasBadge: !!badge,
            hasHeaderReactionGroup: hasHeaderReactionGroup,
            mine: mine,
            showActionMenu: showActionMenu,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }), classes = _h.classes, resolvedStyles = _h.styles;
    var handleFocus = function (e) {
        var _a;
        (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition();
        // react onFocus is called even when nested component receives focus (i.e. it bubbles)
        // so when focus moves within actionMenu, the `focus` state in chatMessage remains true, and keeps actionMenu visible
        setFocused(true);
        _.invoke(props, 'onFocus', e, props);
    };
    var handleBlur = function (e) {
        // `focused` controls is focused the whole `ChatMessage` or any of its children. When we're navigating
        // with keyboard the focused element will be changed and there is no way to use `:focus` selector
        var shouldPreserveFocusState = _.invoke(e, 'currentTarget.contains', e.relatedTarget);
        setFocused(shouldPreserveFocusState);
        setShowActionMenu(false);
        _.invoke(props, 'onBlur', e, props);
    };
    var handleMouseEnter = function (e) {
        var _a;
        (_a = popperRef.current) === null || _a === void 0 ? void 0 : _a.updatePosition();
        if (hasActionMenu && !inlineActionMenu) {
            setShowActionMenu(true);
        }
        _.invoke(props, 'onMouseEnter', e, props);
    };
    var handleMouseLeave = function (e) {
        if (!focused && hasActionMenu && !inlineActionMenu) {
            setShowActionMenu(false);
        }
        _.invoke(props, 'onMouseLeave', e, props);
    };
    var renderActionMenu = function () {
        var actionMenuElement = Menu_1.Menu.create(actionMenu, {
            defaultProps: function () {
                var _a;
                return (_a = {},
                    _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = true,
                    _a.accessibility = accessibility_1.menuAsToolbarBehavior,
                    _a.className = exports.chatMessageSlotClassNames.actionMenu,
                    _a.styles = resolvedStyles.actionMenu,
                    _a);
            },
            overrideProps: {
                id: actionMenuId.current,
            },
        });
        var content = actionMenuElement ? React.createElement(react_component_ref_1.Ref, { innerRef: actionsMenuRef }, actionMenuElement) : actionMenuElement;
        return inlineActionMenu || !content ? content : React.createElement(PortalInner_1.PortalInner, null, content);
    };
    var handleKeyDown = function (e) {
        var _a, _b, _c;
        if (hasActionMenu && !inlineActionMenu) {
            // reference: https://github.com/microsoft/fluentui/pull/17329
            var toFocusItemInActionMenu = (_b = (_a = actionsMenuRef.current) === null || _a === void 0 ? void 0 : _a.querySelector('[tabindex="0"]')) !== null && _b !== void 0 ? _b : (_c = actionsMenuRef.current) === null || _c === void 0 ? void 0 : _c.querySelectorAll('[tabindex="-1"]:not([data-is-focusable="false"])')[0];
            if (e.keyCode === accessibility_1.keyboardKey.Enter) {
                toFocusItemInActionMenu === null || toFocusItemInActionMenu === void 0 ? void 0 : toFocusItemInActionMenu.focus();
                e.stopPropagation();
                e.preventDefault();
            }
            if (e.keyCode === accessibility_1.keyboardKey.Tab) {
                // TAB/SHIFT+TAB cycles focus among actionMenu and focusable elements within chat message
                var isShift = !!e.shiftKey;
                var focusableElementsInsideMessage = e.currentTarget.querySelectorAll('[tabindex="-1"]:not([data-is-focusable="false"])');
                var firstFocusableInsideMessage = focusableElementsInsideMessage[0];
                var lastFocusableInsideMessage = focusableElementsInsideMessage[focusableElementsInsideMessage.length - 1];
                if (e.target === toFocusItemInActionMenu) {
                    // focus is now inside action menu
                    // cycle focus into the first/last focusable element inside chat message
                    if (isShift) {
                        lastFocusableInsideMessage === null || lastFocusableInsideMessage === void 0 ? void 0 : lastFocusableInsideMessage.focus();
                    }
                    else {
                        firstFocusableInsideMessage === null || firstFocusableInsideMessage === void 0 ? void 0 : firstFocusableInsideMessage.focus();
                    }
                    e.stopPropagation();
                    e.preventDefault();
                }
                else {
                    var boundaryElementInsideMessage = isShift ? firstFocusableInsideMessage : lastFocusableInsideMessage;
                    if (e.target === boundaryElementInsideMessage) {
                        // focus is now on the first/last focusable element inside chat message
                        toFocusItemInActionMenu.focus(); // cycle focus back into action Menu
                        e.stopPropagation();
                        e.preventDefault();
                    }
                }
            }
        }
        _.invoke(props, 'onKeyDown', e, props);
    };
    var childrenPropExists = utils_1.childrenExist(children);
    var rootClasses = childrenPropExists ? classnames_1.default(classes.root, classes.content) : classes.root;
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.ChatMessage.handledProps, props);
    var badgeElement = Label_1.Label.create(badge, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.badge,
            styles: resolvedStyles.badge,
        }); },
    });
    var reactionGroupElement = Reaction_1.Reaction.Group.create(reactionGroup, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.reactionGroup,
            styles: resolvedStyles.reactionGroup,
        }); },
    });
    var actionMenuElement = renderActionMenu();
    var authorElement = Text_1.Text.create(author, {
        defaultProps: function () { return ({
            size: density === 'comfy' ? 'small' : undefined,
            styles: resolvedStyles.author,
            className: exports.chatMessageSlotClassNames.author,
        }); },
    });
    var timestampElement = Text_1.Text.create(timestamp, {
        defaultProps: function () { return ({
            size: 'small',
            styles: resolvedStyles.timestamp,
            timestamp: true,
            className: exports.chatMessageSlotClassNames.timestamp,
        }); },
    });
    var messageContent = Box_1.Box.create(content, {
        defaultProps: function () { return ({
            className: exports.chatMessageSlotClassNames.content,
            styles: resolvedStyles.content,
        }); },
    });
    var detailsElement = utils_1.createShorthand(ChatMessageDetails_1.ChatMessageDetails, details, {
        defaultProps: function () { return ({ attached: attached, density: density, hasHeaderReactionGroup: hasHeaderReactionGroup, mine: mine }); },
    });
    var readStatusElement = utils_1.createShorthand(ChatMessageReadStatus_1.ChatMessageReadStatus, readStatus, {
        defaultProps: function () { return ({ density: density }); },
    });
    var elements = React.createElement(React.Fragment, null);
    if (density === 'compact') {
        var headerElement = utils_1.createShorthand(ChatMessageHeader_1.ChatMessageHeader, header);
        var bodyElement = Box_1.Box.create(compactBody || {}, {
            defaultProps: function () {
                return getA11Props('compactBody', {
                    className: exports.chatMessageSlotClassNames.compactBody,
                    styles: resolvedStyles.compactBody,
                });
            },
            overrideProps: function () { return ({
                content: (React.createElement(React.Fragment, null,
                    React.createElement(Flex_1.Flex.Item, { grow: 1 },
                        React.createElement("div", null,
                            authorElement,
                            messageContent)),
                    timestampElement,
                    detailsElement,
                    badgeElement)),
            }); },
        });
        elements = (React.createElement(React.Fragment, null,
            actionMenuElement,
            React.createElement("div", { className: exports.chatMessageSlotClassNames.bar }),
            headerElement,
            bodyElement,
            reactionGroupElement,
            readStatusElement));
    }
    else {
        var headerElement = utils_1.createShorthand(ChatMessageHeader_1.ChatMessageHeader, header || {}, {
            overrideProps: function () { return ({
                content: (React.createElement(React.Fragment, null,
                    authorElement,
                    timestampElement,
                    detailsElement,
                    reactionGroupPosition === 'start' && reactionGroupElement)),
            }); },
        });
        elements = (React.createElement(React.Fragment, null,
            actionMenuElement,
            React.createElement("div", { className: exports.chatMessageSlotClassNames.bar }),
            badgePosition === 'start' && badgeElement,
            headerElement,
            messageContent,
            reactionGroupPosition === 'end' && reactionGroupElement,
            badgePosition === 'end' && badgeElement,
            readStatusElement));
    }
    var element = (React.createElement(react_component_ref_1.Ref, { innerRef: messageRef }, getA11Props.unstable_wrapWithFocusZone(React.createElement(ElementType, __assign({}, getA11Props('root', __assign(__assign({ className: rootClasses, onBlur: handleBlur, onFocus: handleFocus, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, onKeyDown: handleKeyDown, ref: ref }, utils_1.rtlTextContainer.getAttributes({ forElements: [children] })), unhandledProps))), childrenPropExists ? children : elements))));
    setEnd();
    return element;
});
exports.ChatMessage.displayName = 'ChatMessage';
exports.ChatMessage.defaultProps = {
    badgePosition: 'end',
    positionActionMenu: true,
    reactionGroupPosition: 'start',
};
exports.ChatMessage.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({ content: 'shorthand' })), { actionMenu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), attached: PropTypes.oneOfType([PropTypes.bool, PropTypes.oneOf(['top', 'bottom'])]), author: customPropTypes.itemShorthand, badge: customPropTypes.itemShorthand, badgePosition: PropTypes.oneOf(['start', 'end']), compactBody: customPropTypes.itemShorthand, density: PropTypes.oneOf(['comfy', 'compact']), details: customPropTypes.itemShorthand, header: customPropTypes.itemShorthand, mine: PropTypes.bool, onBlur: PropTypes.func, onFocus: PropTypes.func, onKeyDown: PropTypes.func, onMouseEnter: PropTypes.func, onMouseLeave: PropTypes.func, positionActionMenu: PropTypes.bool, reactionGroup: PropTypes.oneOfType([customPropTypes.collectionShorthand, customPropTypes.itemShorthand]), reactionGroupPosition: PropTypes.oneOf(['start', 'end']), readStatus: customPropTypes.itemShorthand, timestamp: customPropTypes.itemShorthand, unstable_overflow: PropTypes.bool });
exports.ChatMessage.handledProps = Object.keys(exports.ChatMessage.propTypes);
exports.ChatMessage.create = utils_1.createShorthandFactory({ Component: exports.ChatMessage, mappedProp: 'content' });
