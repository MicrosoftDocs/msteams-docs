"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConformant = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var react_conformance_1 = require("@fluentui/react-conformance");
var styles_1 = require("@fluentui/styles");
var faker = require("faker");
var _ = require("lodash");
var path = require("path");
var React = require("react");
var test_utils_1 = require("react-dom/test-utils");
var utils_1 = require("test/utils");
var FluentUI = require("src/index");
var eventTarget_1 = require("./eventTarget");
/**
 * Assert Component conforms to guidelines that are applicable to all components.
 * @param Component - A component that should conform.
 */
function isConformant(Component, options) {
    var _a;
    var testPath = options.testPath, _b = options.constructorName, constructorName = _b === void 0 ? Component.prototype.constructor.name : _b, _c = options.eventTargets, eventTargets = _c === void 0 ? {} : _c, _d = options.hasAccessibilityProp, hasAccessibilityProp = _d === void 0 ? true : _d, _e = options.requiredProps, requiredProps = _e === void 0 ? {} : _e, _f = options.wrapperComponent, wrapperComponent = _f === void 0 ? null : _f, _g = options.autoControlledProps, autoControlledProps = _g === void 0 ? [] : _g, targetComponent = options.targetComponent, forwardsRefTo = options.forwardsRefTo;
    var defaultConfig = {
        customMount: utils_1.mountWithProvider,
        componentPath: testPath
            .replace(/test[/\\]specs/, 'src')
            .replace('-test.', '.')
            .replace(/.ts$/, '.tsx'),
        Component: Component,
        displayName: constructorName,
        asPropHandlesRef: true,
        // TODO enable component-has-root-ref and disable test where necessary.
        // List of the components that will either require the test to be disabled or fixed: (https://hackmd.io/OAUn0pF6Qj-vc315wAHXLQ)
        disabledTests: [
            'as-renders-fc',
            'as-renders-react-class',
            'has-top-level-file',
            'consistent-callback-args',
            // Disabled as v0 has different prefix
            'component-has-static-classname',
        ],
        helperComponents: [react_component_ref_1.Ref, react_component_ref_1.RefFindNode, react_bindings_1.FocusZone],
    };
    react_conformance_1.isConformant(defaultConfig, options);
    // composed components store `handledProps` under config
    var isComposedComponent = !!Component.fluentComposeConfig;
    var handledProps = isComposedComponent
        ? (_a = Component.fluentComposeConfig) === null || _a === void 0 ? void 0 : _a.handledProps
        : Component.handledProps;
    var helperComponentNames = __spreadArray([react_component_ref_1.Ref, react_component_ref_1.RefFindNode], (wrapperComponent ? [wrapperComponent] : [])).map(utils_1.getDisplayName);
    var toNextNonTrivialChild = function (from) {
        var current = from.childAt(0);
        if (!current)
            return current;
        return helperComponentNames.indexOf(current.name()) === -1 ? current : toNextNonTrivialChild(current);
    };
    var getComponent = function (wrapper) {
        var componentElement = toNextNonTrivialChild(wrapper);
        // passing through Focus Zone wrappers
        if (componentElement.type() === react_bindings_1.FocusZone) {
            // another HOC component is added: FocusZone
            componentElement = componentElement.childAt(0); // skip through <FocusZone>
        }
        // in that case 'topLevelChildElement' we've found so far is a wrapper's topmost child
        // thus, we should continue search
        return wrapperComponent ? toNextNonTrivialChild(componentElement) : componentElement;
    };
    // ----------------------------------------
    // Props
    // ----------------------------------------
    test('spreads user props', function () {
        var _a;
        var propName = 'data-is-conformant-spread-props';
        var props = (_a = {}, _a[propName] = true, _a);
        var component = utils_1.mountWithProvider(React.createElement(Component, __assign({}, requiredProps, props)));
        // The component already has the prop, so we are testing if it's children also have the props,
        // that is why we are testing if it is greater then 1
        expect(component.find(props).length).toBeGreaterThan(1);
    });
    // ---------------------------------------
    // Autocontrolled props
    // ---------------------------------------
    test('autoControlled props should have prop, default prop and on change handler in handled props', function () {
        autoControlledProps.forEach(function (propName) {
            var capitalisedPropName = "" + propName.slice(0, 1).toUpperCase() + propName.slice(1);
            var expectedDefaultProp = "default" + capitalisedPropName;
            var expectedChangeHandler = propName === 'value' || propName === 'checked' ? 'onChange' : "on" + capitalisedPropName + "Change";
            expect(handledProps).toContain(propName);
            expect(handledProps).toContain(expectedDefaultProp);
            expect(handledProps).toContain(expectedChangeHandler);
        });
    });
    // ---------------------------------------
    // Handled props
    // ---------------------------------------
    describe('handles props', function () {
        var _a;
        test('defines handled props in handledProps', function () {
            expect(handledProps).toBeDefined();
            expect(Array.isArray(handledProps)).toEqual(true);
        });
        test("has 'styles' as handled prop", function () {
            expect(handledProps).toContain('styles');
        });
        test("has 'variables' as handled prop", function () {
            expect(handledProps).toContain('variables');
        });
        test('handledProps includes props defined in autoControlledProps, defaultProps or propTypes', function () {
            var computedProps = _.union(Component.autoControlledProps, _.keys(Component.defaultProps), _.keys(Component.propTypes));
            var expectedProps = _.uniq(computedProps).sort();
            var message = 'Not all handled props were defined correctly. All props defined in handled props, must be defined' +
                'either in static autoControlledProps, static defaultProps or static propTypes.';
            expect({
                message: message,
                handledProps: handledProps.sort(),
            }).toEqual(expect.objectContaining({
                message: message,
                handledProps: expect.arrayContaining(expectedProps),
            }));
        });
        var isClassComponent = !!((_a = Component.prototype) === null || _a === void 0 ? void 0 : _a.isReactComponent);
        if (!isClassComponent) {
            test('uses "useUnhandledProps" hook', function () {
                var wrapper = targetComponent
                    ? utils_1.mountWithProvider(React.createElement(Component, __assign({}, requiredProps))).find(targetComponent)
                    : utils_1.mountWithProvider(React.createElement(Component, __assign({}, requiredProps)));
                var element = getComponent(wrapper);
                expect(element.prop('data-uses-unhanded-props')).toBeTruthy();
            });
        }
    });
    if (hasAccessibilityProp) {
        var role_1 = faker.lorem.word();
        var noopBehavior_1 = function () {
            var _a;
            return ({
                attributes: {
                    root: (_a = {},
                        _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = true,
                        _a.role = role_1,
                        _a),
                },
            });
        };
        test('defines an "accessibility" prop in handledProps', function () {
            expect(handledProps).toContain('accessibility');
        });
        test('spreads "attributes" on root', function () {
            var wrapper = utils_1.mountWithProvider(React.createElement(Component, __assign({}, requiredProps, { accessibility: noopBehavior_1 })));
            var element = getComponent(wrapper);
            expect(element.prop(accessibility_1.IS_FOCUSABLE_ATTRIBUTE)).toBe(true);
            expect(element.prop('role')).toBe(role_1);
        });
        test("client's attributes override the ones provided by Fluent UI", function () {
            var _a;
            var wrapperProps = __assign(__assign({}, requiredProps), (_a = {}, _a[accessibility_1.IS_FOCUSABLE_ATTRIBUTE] = false, _a));
            var wrapper = targetComponent
                ? utils_1.mountWithProvider(React.createElement(Component, __assign({}, wrapperProps, { accessibility: noopBehavior_1 }))).find(targetComponent)
                : utils_1.mountWithProvider(React.createElement(Component, __assign({}, wrapperProps, { accessibility: noopBehavior_1 })));
            var element = getComponent(wrapper);
            expect(element.prop(accessibility_1.IS_FOCUSABLE_ATTRIBUTE)).toBe(false);
        });
        _.forEach(['onKeyDown', 'onKeyPress', 'onKeyUp'], function (listenerName) {
            test("handles " + listenerName + " transparently", function () {
                var _a;
                // onKeyDown => keyDown
                var eventName = _.camelCase(listenerName.replace('on', ''));
                var handler = jest.fn();
                var wrapperProps = __assign(__assign({}, requiredProps), (_a = {}, _a[eventTarget_1.EVENT_TARGET_ATTRIBUTE] = true, _a[listenerName] = handler, _a));
                var wrapper = utils_1.mountWithProvider(React.createElement(Component, __assign({}, wrapperProps)));
                eventTarget_1.getEventTargetComponent(wrapper, listenerName, eventTargets).simulate(eventName);
                expect(handler).toBeCalledTimes(1);
            });
        });
    }
    // ----------------------------------------
    // Events
    // ----------------------------------------
    test('handles events transparently', function () {
        // Events should be handled transparently, working just as they would in vanilla React.
        // Example, both of these handler()s should be called with the same event:
        //
        //   <Button onClick={handler} />
        //   <button onClick={handler} />
        //
        // This test catches the case where a developer forgot to call the event prop
        // after handling it internally. It also catch cases where the synthetic event was not passed back.
        _.each(utils_1.syntheticEvent.types, function (_a) {
            var eventShape = _a.eventShape, listeners = _a.listeners;
            _.each(listeners, function (listenerName) {
                var _a;
                // onKeyDown => keyDown
                var eventName = _.camelCase(listenerName.replace('on', ''));
                var handlerSpy = jest.fn();
                var props = __assign(__assign({}, requiredProps), (_a = {}, _a[listenerName] = handlerSpy, _a[eventTarget_1.EVENT_TARGET_ATTRIBUTE] = true, _a));
                var component = utils_1.mountWithProvider(React.createElement(Component, __assign({}, props)));
                var eventTarget = eventTarget_1.getEventTargetComponent(component, listenerName, eventTargets);
                var customHandler = eventTarget.prop(listenerName);
                if (customHandler) {
                    test_utils_1.act(function () {
                        customHandler(eventShape);
                    });
                }
                else {
                    if (Component.propTypes[listenerName]) {
                        throw new Error("Handler for '" + listenerName + "' is not passed to child event emitter element <" + eventTarget.type() + " />");
                    }
                    // We are checking only props handled by component
                    return;
                }
                // give event listeners opportunity to cleanup
                if (component.instance() && component.instance().componentWillUnmount) {
                    component.instance().componentWillUnmount();
                }
                // <Dropdown onBlur={handleBlur} />
                //                   ^ was not called once on "blur"
                var leftPad = ' '.repeat(constructorName.length + listenerName.length + 3);
                // onKeyDown => handleKeyDown
                var handlerName = _.camelCase(listenerName.replace('on', 'handle'));
                try {
                    expect(handlerSpy).toHaveBeenCalled();
                }
                catch (err) {
                    throw new Error([
                        "<" + constructorName + " " + listenerName + "={" + handlerName + "} />\n",
                        leftPad + " ^ was not called once on \"" + eventName + "\".",
                        'You may need to hoist your event handlers up to the root element.\n',
                    ].join(''));
                }
                var expectedArgs = [eventShape];
                var errorMessage = 'was not called with (event)';
                if (_.has(Component.propTypes, listenerName)) {
                    expectedArgs = [eventShape, expect.objectContaining(component.props())];
                    errorMessage = [
                        'was not called with (event, data).\n',
                        "Ensure that 'props' object is passed to '" + listenerName + "'\n",
                        "event handler of <" + Component.displayName + " />.",
                    ].join('');
                }
                // Components should return the event first, then any data
                try {
                    var lastHandlerCall_1 = _.last(handlerSpy.mock.calls);
                    // We are using there a manual assert instead of `toHaveBeenLastCalledWith()` to
                    // run a comparison based on `expectedArgs` instead of comparing actual args from
                    // a function call.
                    expectedArgs.forEach(function (expectedArg, argI) {
                        expect(lastHandlerCall_1[argI]).toEqual(expectedArg);
                    });
                }
                catch (err) {
                    throw new Error([
                        "<" + constructorName + " " + listenerName + "={" + handlerName + "} />\n",
                        leftPad + " ^ " + errorMessage,
                        'It was called with args:',
                        JSON.stringify(handlerSpy.mock.calls[0], null, 2),
                    ].join('\n'));
                }
            });
        });
    });
    // ----------------------------------------
    // Handles className
    // ----------------------------------------
    describe('className const (common)', function () {
        // This className calculation is duplicated from scripts/gulp/plugins/util/getComponentInfo.ts.
        // The duplication isn't ideal, but the speed benefit from removing the requirement to build
        // component info before running tests is worth it.
        var componentPath = defaultConfig.componentPath;
        var dirname = path.basename(path.dirname(componentPath));
        var filenameWithoutExt = path.basename(componentPath, path.extname(componentPath));
        var isParent = filenameWithoutExt === dirname;
        var parentDisplayName = isParent ? null : dirname;
        // for example, "Menu" for "ToolbarMenu" since it is accessed as "Toolbar.Menu" in the API
        var subcomponentName = isParent ? null : constructorName.replace(parentDisplayName, '');
        var componentClassName = (!isParent
            ? _.includes(subcomponentName, 'Group')
                ? "ui-" + parentDisplayName + "s"
                : "ui-" + parentDisplayName + "__" + subcomponentName
            : "ui-" + constructorName.toLowerCase()).toLowerCase();
        var constClassName = _.camelCase(Component.displayName + "ClassName");
        test("exports a const equal to \"" + componentClassName + "\"", function () {
            expect(FluentUI[constClassName]).toEqual(componentClassName);
        });
    });
    // ---------------------------------------
    // Telemetry
    // ---------------------------------------
    describe('telemetry', function () {
        test('reports telemetry to its Provider', function () {
            var telemetry = new react_bindings_1.Telemetry();
            var wrapper = utils_1.mountWithProvider(React.createElement(Component, __assign({}, requiredProps)), {
                wrappingComponentProps: { telemetry: telemetry },
            });
            wrapper.unmount();
            expect(telemetry.performance).toHaveProperty(Component.displayName);
        });
    });
    // ---------------------------------------
    // compose()
    // ---------------------------------------
    if (isComposedComponent) {
        describe('compose', function () {
            describe('debug', function () {
                var displayName = 'ComposedComponent';
                var ComposedComponent = react_bindings_1.compose(Component, {
                    displayName: displayName,
                });
                it('overrides default "displayName"', function () {
                    expect(ComposedComponent.displayName).toBe(displayName);
                });
                it('overrides default debug name for accessibility', function () {
                    var noopBehavior = function () { return ({
                        attributes: {
                            root: { 'aria-label': 'test' },
                        },
                    }); };
                    var wrapper = utils_1.mountWithProvider(React.createElement(ComposedComponent, __assign({}, requiredProps, { accessibility: noopBehavior })));
                    var element = getComponent(wrapper);
                    expect(element.prop('data-aa-class')).toBe(displayName);
                });
                it('overrides default name for telemetry', function () {
                    var telemetry = new react_bindings_1.Telemetry();
                    var wrapper = utils_1.mountWithProvider(React.createElement(ComposedComponent, __assign({}, requiredProps)), {
                        wrappingComponentProps: { telemetry: telemetry },
                    });
                    wrapper.unmount();
                    expect(telemetry.performance).toHaveProperty(displayName);
                });
            });
            describe('styles', function () {
                var ComposedComponent = react_bindings_1.compose(Component, {
                    className: 'ui-composed',
                    mapPropsToStylesProps: function (props) { return ({ stylesTest: props.test }); },
                    handledProps: ['test'],
                });
                it('overrides default "className"', function () {
                    var wrapper = utils_1.mountWithProvider(React.createElement(ComposedComponent, __assign({}, requiredProps, { test: true })));
                    var element = getComponent(wrapper);
                    expect(element.prop('className')).toContain('ui-composed');
                });
                it('allows to define additional styles props', function () {
                    var renderer = {
                        renderRule: function (styles) {
                            var props = styles;
                            return props.stylesTest ? 'has-test' : 'has-not-test';
                        },
                    };
                    var theme = __assign(__assign({}, styles_1.emptyTheme), { 
                        // Noop to pass all props as styles to `renderRule()`
                        componentStyles: new Proxy({}, { get: function () { return ({ root: function (_a) {
                                    var props = _a.props;
                                    return props;
                                } }); } }) });
                    var wrapper = utils_1.mountWithProvider(React.createElement(ComposedComponent, __assign({}, requiredProps)), {
                        wrappingComponentProps: { renderer: renderer, theme: theme },
                    });
                    expect(getComponent(wrapper).prop('className')).toContain('has-not-test');
                    wrapper.setProps({ test: true });
                    expect(getComponent(wrapper).prop('className')).toContain('has-test');
                });
            });
            if (forwardsRefTo !== false) {
                it('passes a ref to "root" element', function () {
                    var ComposedComponent = react_bindings_1.compose(Component);
                    var rootRef = jest.fn();
                    var wrapper = forwardsRefTo
                        ? utils_1.mountWithProvider(React.createElement(ComposedComponent, __assign({}, requiredProps, { ref: rootRef }))).find(forwardsRefTo)
                        : utils_1.mountWithProvider(React.createElement(ComposedComponent, __assign({}, requiredProps, { ref: rootRef })));
                    var element = getComponent(wrapper);
                    expect(typeof element.type()).toBe('string');
                    expect(rootRef).toBeCalledWith(expect.objectContaining({ tagName: _.upperCase(element.type()) }));
                });
            }
        });
    }
}
exports.isConformant = isConformant;
