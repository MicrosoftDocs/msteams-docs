"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.Dropdown = exports.dropdownSlotClassNames = exports.dropdownClassName = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _findIndex2 = _interopRequireDefault(require("lodash/findIndex"));

var _isNil2 = _interopRequireDefault(require("lodash/isNil"));

var _isEmpty2 = _interopRequireDefault(require("lodash/isEmpty"));

var _isNumber2 = _interopRequireDefault(require("lodash/isNumber"));

var _invoke2 = _interopRequireDefault(require("lodash/invoke"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _uniqueId2 = _interopRequireDefault(require("lodash/uniqueId"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _isFunction2 = _interopRequireDefault(require("lodash/isFunction"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _differenceBy2 = _interopRequireDefault(require("lodash/differenceBy"));

var _reactBindings = require("@fluentui/react-bindings");

var _reactComponentRef = require("@fluentui/react-component-ref");

var customPropTypes = _interopRequireWildcard(require("@fluentui/react-proptypes"));

var _accessibility = require("@fluentui/accessibility");

var React = _interopRequireWildcard(require("react"));

var PropTypes = _interopRequireWildcard(require("prop-types"));

var _classnames = _interopRequireDefault(require("classnames"));

var _computeScrollIntoView = _interopRequireDefault(require("compute-scroll-into-view"));

var _downshift = _interopRequireDefault(require("downshift"));

var _utils = require("../../utils");

var _List = require("../List/List");

var _DropdownItem = require("./DropdownItem");

var _DropdownSelectedItem = require("./DropdownSelectedItem");

var _DropdownSearchInput = require("./DropdownSearchInput");

var _Button = require("../Button/Button");

var _accessibilityStyles = require("../../utils/accessibility/Styles/accessibilityStyles");

var _Box = require("../Box/Box");

var _Portal = require("../Portal/Portal");

var _positioner = require("../../utils/positioner");

var _reactIconsNorthstar = require("@fluentui/react-icons-northstar");

var _excluded = ["onClick", "onFocus", "onBlur", "onKeyDown"],
    _excluded2 = ["innerRef"],
    _excluded3 = ["innerRef"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var dropdownClassName = 'ui-dropdown';
exports.dropdownClassName = dropdownClassName;
var dropdownSlotClassNames = {
  clearIndicator: dropdownClassName + "__clear-indicator",
  container: dropdownClassName + "__container",
  toggleIndicator: dropdownClassName + "__toggle-indicator",
  item: dropdownClassName + "__item",
  itemsList: dropdownClassName + "__items-list",
  searchInput: dropdownClassName + "__searchinput",
  selectedItem: dropdownClassName + "__selecteditem",
  selectedItems: dropdownClassName + "__selected-items",
  triggerButton: dropdownClassName + "__trigger-button"
};
exports.dropdownSlotClassNames = dropdownSlotClassNames;
var a11yStatusCleanupTime = 500;
var charKeyPressedCleanupTime = 500;
/** `normalizedValue` should be normalized always as it can be received from props */

function normalizeValue(multiple, rawValue) {
  var normalizedValue = Array.isArray(rawValue) ? rawValue : [rawValue];
  return multiple ? normalizedValue : normalizedValue.slice(0, 1);
}
/**
 * Used to compute the filtered items (by value and search query) and, if needed,
 * their string equivalents, in order to be used throughout the component.
 */


function getFilteredValues(options) {
  var items = options.items,
      itemToString = options.itemToString,
      itemToValue = options.itemToValue,
      multiple = options.multiple,
      search = options.search,
      searchQuery = options.searchQuery,
      value = options.value;
  var filteredItemsByValue = multiple ? (0, _differenceBy2.default)(items, value, itemToValue) : items;
  var filteredItemStrings = (0, _map2.default)(filteredItemsByValue, function (filteredItem) {
    return itemToString(filteredItem).toLowerCase();
  });

  if (search) {
    if ((0, _isFunction2.default)(search)) {
      return {
        filteredItems: search(filteredItemsByValue, searchQuery),
        filteredItemStrings: filteredItemStrings
      };
    }

    return {
      filteredItems: filteredItemsByValue.filter(function (item) {
        return itemToString(item).toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1;
      }),
      filteredItemStrings: filteredItemStrings
    };
  }

  return {
    filteredItems: filteredItemsByValue,
    filteredItemStrings: filteredItemStrings
  };
}

var isEmpty = function isEmpty(prop) {
  return typeof prop === 'object' && !prop.props && !(0, _get2.default)(prop, 'children') && !(0, _get2.default)(prop, 'content');
};
/**
 * A Dropdown allows user to select one or more values from a list of options.
 * Can be created with search and multi-selection capabilities.
 *
 * @accessibility
 * Implements [ARIA Combo Box](https://www.w3.org/TR/wai-aria-practices-1.1/#combobox) design pattern, uses aria-live to announce state changes.
 * @accessibilityIssues
 * [Issue 991203: VoiceOver doesn't narrate properly elements in the input/combobox](https://bugs.chromium.org/p/chromium/issues/detail?id=991203)
 * [JAWS - ESC (ESCAPE) not closing collapsible listbox (dropdown) on first time #528](https://github.com/FreedomScientific/VFO-standards-support/issues/528)
 */


var Dropdown = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var _context$target3;

  var context = (0, _reactBindings.useFluentContext)();

  var _useTelemetry = (0, _reactBindings.useTelemetry)(Dropdown.displayName, context.telemetry),
      setStart = _useTelemetry.setStart,
      setEnd = _useTelemetry.setEnd;

  setStart();
  var ariaLabelledby = props['aria-labelledby'],
      ariaInvalid = props['aria-invalid'],
      clearable = props.clearable,
      clearIndicator = props.clearIndicator,
      checkable = props.checkable,
      checkableIndicator = props.checkableIndicator,
      className = props.className,
      design = props.design,
      disabled = props.disabled,
      error = props.error,
      fluid = props.fluid,
      getA11ySelectionMessage = props.getA11ySelectionMessage,
      a11ySelectedItemsMessage = props.a11ySelectedItemsMessage,
      getA11yStatusMessage = props.getA11yStatusMessage,
      inline = props.inline,
      inverted = props.inverted,
      itemToString = props.itemToString,
      itemToValue = props.itemToValue,
      items = props.items,
      highlightFirstItemOnOpen = props.highlightFirstItemOnOpen,
      multiple = props.multiple,
      headerMessage = props.headerMessage,
      moveFocusOnTab = props.moveFocusOnTab,
      noResultsMessage = props.noResultsMessage,
      loading = props.loading,
      loadingMessage = props.loadingMessage,
      placeholder = props.placeholder,
      renderItem = props.renderItem,
      renderSelectedItem = props.renderSelectedItem,
      search = props.search,
      searchInput = props.searchInput,
      styles = props.styles,
      toggleIndicator = props.toggleIndicator,
      triggerButton = props.triggerButton,
      variables = props.variables;
  var align = props.align,
      flipBoundary = props.flipBoundary,
      overflowBoundary = props.overflowBoundary,
      popperRef = props.popperRef,
      position = props.position,
      positionFixed = props.positionFixed,
      offset = props.offset,
      unstable_disableTether = props.unstable_disableTether,
      unstable_pinned = props.unstable_pinned,
      autoSize = props.autoSize; // PositioningProps passed directly to Dropdown

  var _partitionPopperProps = (0, _positioner.partitionPopperPropsFromShorthand)(props.list),
      list = _partitionPopperProps[0],
      positioningProps = _partitionPopperProps[1]; // PositioningProps passed to Dropdown `list` prop's `popper` key


  var buttonRef = React.useRef();

  var _inputRef = React.useRef();

  var listRef = React.useRef();
  var selectedItemsRef = React.useRef();
  var containerRef = React.useRef();
  var defaultTriggerButtonId = React.useMemo(function () {
    return (0, _uniqueId2.default)('dropdown-trigger-button-');
  }, []);
  var ElementType = (0, _reactBindings.getElementType)(props);
  var unhandledProps = (0, _reactBindings.useUnhandledProps)(Dropdown.handledProps, props);

  var _useAutoControlled = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultActiveSelectedIndex,
    initialValue: multiple ? null : undefined,
    value: props.activeSelectedIndex
  }),
      activeSelectedIndex = _useAutoControlled[0],
      setActiveSelectedIndex = _useAutoControlled[1];

  var _useAutoControlled2 = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultHighlightedIndex,
    initialValue: highlightFirstItemOnOpen ? 0 : null,
    value: props.highlightedIndex
  }),
      highlightedIndex = _useAutoControlled2[0],
      setHighlightedIndex = _useAutoControlled2[1];

  var _useAutoControlled3 = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultOpen,
    initialValue: false,
    value: props.open
  }),
      open = _useAutoControlled3[0],
      setOpen = _useAutoControlled3[1];

  var _useAutoControlled4 = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultSearchQuery,
    initialValue: search ? '' : undefined,
    value: props.searchQuery
  }),
      searchQuery = _useAutoControlled4[0],
      setSearchQuery = _useAutoControlled4[1];

  var _useAutoControlled5 = (0, _reactBindings.useAutoControlled)({
    defaultValue: props.defaultValue,
    initialValue: [],
    value: props.value
  }),
      rawValue = _useAutoControlled5[0],
      setValue = _useAutoControlled5[1];

  var value = normalizeValue(multiple, rawValue);

  var _React$useState = React.useState(''),
      a11ySelectionStatus = _React$useState[0],
      setA11ySelectionStatus = _React$useState[1];

  var _React$useState2 = React.useState(false),
      focused = _React$useState2[0],
      setFocused = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      isFromKeyboard = _React$useState3[0],
      setIsFromKeyboard = _React$useState3[1];

  var _React$useState4 = React.useState(false),
      itemIsFromKeyboard = _React$useState4[0],
      setItemIsFromKeyboard = _React$useState4[1];

  var _React$useState5 = React.useState(search ? undefined : ''),
      startingString = _React$useState5[0],
      setStartingString = _React$useState5[1];

  var _getFilteredValues = getFilteredValues({
    itemToString: itemToString,
    itemToValue: itemToValue,
    items: items,
    multiple: multiple,
    search: search,
    searchQuery: searchQuery,
    value: value
  }),
      filteredItems = _getFilteredValues.filteredItems,
      filteredItemStrings = _getFilteredValues.filteredItemStrings;

  var _useStyles = (0, _reactBindings.useStyles)(Dropdown.displayName, {
    className: dropdownClassName,
    mapPropsToStyles: function mapPropsToStyles() {
      var _positioningProps$pos;

      return {
        disabled: disabled,
        error: error,
        fluid: fluid,
        focused: focused,
        isEmptyClearIndicator: isEmpty(clearIndicator),
        hasToggleIndicator: !!toggleIndicator,
        inline: inline,
        inverted: inverted,
        isFromKeyboard: isFromKeyboard,
        multiple: multiple,
        open: open,
        position: (_positioningProps$pos = positioningProps == null ? void 0 : positioningProps.position) != null ? _positioningProps$pos : position,
        search: !!search,
        hasItemsSelected: value.length > 0
      };
    },
    mapPropsToInlineStyles: function mapPropsToInlineStyles() {
      return {
        className: className,
        design: design,
        styles: styles,
        variables: variables
      };
    },
    rtl: context.rtl
  }),
      classes = _useStyles.classes,
      resolvedStyles = _useStyles.styles;

  var clearA11ySelectionMessage = React.useMemo(function () {
    return (0, _debounce2.default)(function () {
      setA11ySelectionStatus('');
    }, a11yStatusCleanupTime);
  }, []);
  var clearStartingString = React.useMemo(function () {
    return (0, _debounce2.default)(function () {
      setStartingString('');
    }, charKeyPressedCleanupTime);
  }, []);

  var handleChange = function handleChange(e) {
    // Dropdown component doesn't present any `input` component in markup, however all of our
    // components should handle events transparently.
    (0, _invoke2.default)(props, 'onChange', e, Object.assign({}, props, {
      value: value
    }));
  };

  var handleOnBlur = function handleOnBlur(e) {
    // Dropdown component doesn't present any `input` component in markup, however all of our
    // components should handle events transparently.
    if (e.target !== buttonRef.current) {
      (0, _invoke2.default)(props, 'onBlur', e, props);
    }
  };

  var renderTriggerButton = function renderTriggerButton(getToggleButtonProps) {
    var content = getSelectedItemAsString(value[0]);
    var triggerButtonId = triggerButton['id'] || defaultTriggerButtonId;
    var triggerButtonProps = getToggleButtonProps(Object.assign({
      disabled: disabled,
      onFocus: handleTriggerButtonOrListFocus,
      onBlur: handleTriggerButtonBlur,
      onKeyDown: function onKeyDown(e) {
        handleTriggerButtonKeyDown(e);
      },
      'aria-invalid': ariaInvalid,
      'aria-label': undefined,
      'aria-labelledby': [ariaLabelledby, triggerButtonId].filter(function (l) {
        return !!l;
      }).join(' ')
    }, open && {
      'aria-expanded': true
    }));
    var _onClick = triggerButtonProps.onClick,
        _onFocus = triggerButtonProps.onFocus,
        _onBlur = triggerButtonProps.onBlur,
        _onKeyDown = triggerButtonProps.onKeyDown,
        restTriggerButtonProps = (0, _objectWithoutPropertiesLoose2.default)(triggerButtonProps, _excluded);
    return /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
      innerRef: buttonRef
    }, (0, _utils.createShorthand)(_Button.Button, triggerButton, {
      defaultProps: function defaultProps() {
        return Object.assign({
          className: dropdownSlotClassNames.triggerButton,
          content: content,
          disabled: disabled,
          id: triggerButtonId,
          fluid: true,
          styles: resolvedStyles.triggerButton
        }, restTriggerButtonProps);
      },
      overrideProps: function overrideProps(predefinedProps) {
        return {
          onClick: function onClick(e) {
            _onClick(e);

            (0, _invoke2.default)(predefinedProps, 'onClick', e, predefinedProps);
          },
          onFocus: function onFocus(e) {
            _onFocus(e);

            (0, _invoke2.default)(predefinedProps, 'onFocus', e, predefinedProps);
          },
          onBlur: function onBlur(e) {
            if (!disabled) {
              _onBlur(e);
            }

            (0, _invoke2.default)(predefinedProps, 'onBlur', e, predefinedProps);
          },
          onKeyDown: function onKeyDown(e) {
            if (!disabled) {
              _onKeyDown(e);
            }

            (0, _invoke2.default)(predefinedProps, 'onKeyDown', e, predefinedProps);
          }
        };
      }
    }));
  };

  var renderSearchInput = function renderSearchInput(accessibilityComboboxProps, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) {
    var noPlaceholder = searchQuery.length > 0 || multiple && value.length > 0;
    return _DropdownSearchInput.DropdownSearchInput.create(searchInput || {}, {
      defaultProps: function defaultProps() {
        return {
          className: dropdownSlotClassNames.searchInput,
          placeholder: noPlaceholder ? '' : placeholder,
          inline: inline,
          variables: variables,
          disabled: disabled
        };
      },
      overrideProps: handleSearchInputOverrides(highlightedIndex, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps)
    });
  };

  var renderItemsList = function renderItemsList(highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps) {
    var items = open ? renderItems(getItemProps) : [];

    var _getMenuProps = getMenuProps({
      refKey: 'innerRef'
    }, {
      suppressRefError: true
    }),
        _innerRef = _getMenuProps.innerRef,
        accessibilityMenuProps = (0, _objectWithoutPropertiesLoose2.default)(_getMenuProps, _excluded2); // If it's just a selection, some attributes and listeners from Downshift input need to go on the menu list.


    if (!search) {
      var accessibilityInputProps = getInputProps();
      accessibilityMenuProps['aria-activedescendant'] = accessibilityInputProps['aria-activedescendant'];

      accessibilityMenuProps['onKeyDown'] = function (e) {
        handleListKeyDown(e, highlightedIndex, accessibilityInputProps['onKeyDown'], toggleMenu, selectItemAtIndex);
      };
    }

    return /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
      innerRef: function innerRef(listElement) {
        (0, _reactComponentRef.handleRef)(listRef, listElement);
        (0, _reactComponentRef.handleRef)(_innerRef, listElement);
      }
    }, /*#__PURE__*/React.createElement(_positioner.Popper, (0, _extends2.default)({
      rtl: context.rtl,
      enabled: open,
      targetRef: containerRef,
      positioningDependencies: [items.length] // positioning props:
      ,
      align: align,
      flipBoundary: flipBoundary,
      overflowBoundary: overflowBoundary,
      popperRef: popperRef,
      position: position,
      positionFixed: positionFixed,
      offset: offset,
      unstable_disableTether: unstable_disableTether,
      unstable_pinned: unstable_pinned,
      autoSize: autoSize
    }, positioningProps), _List.List.create(list, {
      defaultProps: function defaultProps() {
        return Object.assign({
          className: dropdownSlotClassNames.itemsList
        }, accessibilityMenuProps, {
          styles: resolvedStyles.list,
          items: items,
          tabIndex: search ? undefined : -1,
          // needs to be focused when trigger button is activated.
          'aria-hidden': !open
        });
      },
      overrideProps: function overrideProps(predefinedProps) {
        return {
          onFocus: function onFocus(e, listProps) {
            handleTriggerButtonOrListFocus();
            (0, _invoke2.default)(predefinedProps, 'onClick', e, listProps);
          },
          onBlur: function onBlur(e, listProps) {
            handleListBlur(e);
            (0, _invoke2.default)(predefinedProps, 'onBlur', e, listProps);
          }
        };
      }
    })));
  };

  var renderItems = function renderItems(getItemProps) {
    var footerItem = renderItemsListFooter();
    var headerItem = renderItemsListHeader();
    var items = (0, _map2.default)(filteredItems, function (item, index) {
      return {
        children: function children() {
          var selected = value.indexOf(item) !== -1;
          return _DropdownItem.DropdownItem.create(item, {
            defaultProps: function defaultProps() {
              return Object.assign({
                className: dropdownSlotClassNames.item,
                active: highlightedIndex === index,
                selected: selected,
                checkable: checkable,
                checkableIndicator: checkableIndicator,
                isFromKeyboard: itemIsFromKeyboard,
                variables: variables
              }, typeof item === 'object' && !item.hasOwnProperty('key') && {
                key: item.header
              });
            },
            overrideProps: handleItemOverrides(item, index, getItemProps, selected),
            render: renderItem
          });
        }
      };
    });

    if (footerItem) {
      items.push(footerItem);
    }

    return headerItem ? [headerItem].concat(items) : items;
  };

  var renderItemsListHeader = function renderItemsListHeader() {
    if (headerMessage) {
      return {
        children: function children() {
          return _DropdownItem.DropdownItem.create(headerMessage, {
            defaultProps: function defaultProps() {
              return {
                key: 'items-list-footer-message',
                styles: resolvedStyles.headerMessage
              };
            }
          });
        }
      };
    }

    return null;
  };

  var renderItemsListFooter = function renderItemsListFooter() {
    if (loading) {
      return {
        children: function children() {
          return _DropdownItem.DropdownItem.create(loadingMessage, {
            defaultProps: function defaultProps() {
              return {
                key: 'loading-message',
                styles: resolvedStyles.loadingMessage
              };
            }
          });
        }
      };
    }

    if (filteredItems && filteredItems.length === 0) {
      return {
        children: function children() {
          return _DropdownItem.DropdownItem.create(noResultsMessage, {
            defaultProps: function defaultProps() {
              return {
                key: 'no-results-message',
                styles: resolvedStyles.noResultsMessage
              };
            }
          });
        }
      };
    }

    return null;
  };

  var renderSelectedItems = function renderSelectedItems() {
    if (value.length === 0) {
      return null;
    }

    var selectedItems = value.map(function (item, index) {
      return (// (!) an item matches DropdownItemProps
        _DropdownSelectedItem.DropdownSelectedItem.create(item, {
          defaultProps: function defaultProps() {
            return Object.assign({
              className: dropdownSlotClassNames.selectedItem,
              active: isSelectedItemActive(index),
              variables: variables
            }, typeof item === 'object' && !item.hasOwnProperty('key') && {
              key: item.header
            });
          },
          overrideProps: handleSelectedItemOverrides(item),
          render: renderSelectedItem
        })
      );
    });
    return /*#__PURE__*/React.createElement("div", {
      role: "listbox",
      tabIndex: -1,
      "aria-label": a11ySelectedItemsMessage
    }, selectedItems);
  };

  var downshiftStateReducer = function downshiftStateReducer(state, changes) {
    var activeElement = context.target.activeElement;

    switch (changes.type) {
      case _downshift.default.stateChangeTypes.blurButton:
        // Downshift closes the list by default on trigger blur. It does not support the case when dropdown is
        // single selection and focuses list on trigger click/up/down/space/enter. Treating that here.
        if (state.isOpen && activeElement === listRef.current) {
          return {}; // won't change state in this case.
        }

        (0, _invoke2.default)(props, 'onBlur', null);

      default:
        return changes;
    }
  };

  var handleInputValueChange = function handleInputValueChange(inputValue, stateAndHelpers) {
    var itemSelected = stateAndHelpers.selectedItem && inputValue === itemToString(stateAndHelpers.selectedItem);

    if (inputValue !== searchQuery && !itemSelected // when item is selected, `handleStateChange` will update searchQuery.
    ) {
      setStateAndInvokeHandler(['onSearchQueryChange'], null, {
        searchQuery: inputValue
      });
    }
  };

  var handleStateChange = function handleStateChange(changes) {
    var _context$target2;

    var type = changes.type;
    var newState = {};

    switch (type) {
      case _downshift.default.stateChangeTypes.changeInput:
        {
          var shouldValueChange = changes.inputValue === '' && !multiple && value.length > 0;
          newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;

          if (shouldValueChange) {
            newState.value = [];
          }

          if (open) {
            // we clear value when in single selection user cleared the query.
            var shouldMenuClose = changes.inputValue === '' || changes.selectedItem !== undefined;

            if (shouldMenuClose) {
              newState.open = false;
            }
          } else {
            newState.open = true;
          }

          break;
        }

      case _downshift.default.stateChangeTypes.keyDownEnter:
      case _downshift.default.stateChangeTypes.clickItem:
        var shouldAddHighlightedIndex = !multiple && items && items.length > 0;
        var isSameItemSelected = changes.selectedItem === undefined;
        var newValue = isSameItemSelected ? value[0] : changes.selectedItem;
        newState.searchQuery = getSelectedItemAsString(newValue);
        newState.open = false;
        newState.highlightedIndex = shouldAddHighlightedIndex ? items.indexOf(newValue) : null;

        if (!isSameItemSelected) {
          newState.value = multiple ? [].concat(value, [changes.selectedItem]) : [changes.selectedItem];

          if (getA11ySelectionMessage && getA11ySelectionMessage.onAdd) {
            setA11ySelectionMessage(getA11ySelectionMessage.onAdd(newValue));
          }
        }

        if (multiple) {
          var _context$target;

          (_context$target = context.target) == null ? void 0 : _context$target.defaultView.setTimeout(function () {
            return selectedItemsRef.current.scrollTop = selectedItemsRef.current.scrollHeight;
          }, 0);
        } // timeout because of NVDA, otherwise it narrates old button value/state


        (_context$target2 = context.target) == null ? void 0 : _context$target2.defaultView.setTimeout(function () {
          return tryFocusTriggerButton();
        }, 100);
        break;

      case _downshift.default.stateChangeTypes.keyDownEscape:
        if (search && !multiple) {
          newState.value = [];
        }

        newState.open = false;
        newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;
        break;

      case _downshift.default.stateChangeTypes.keyDownArrowDown:
      case _downshift.default.stateChangeTypes.keyDownArrowUp:
        if (changes.isOpen !== undefined) {
          newState.open = changes.isOpen;
          newState.highlightedIndex = changes.highlightedIndex;

          if (changes.isOpen) {
            var highlightedIndexOnArrowKeyOpen = getHighlightedIndexOnArrowKeyOpen(changes);

            if ((0, _isNumber2.default)(highlightedIndexOnArrowKeyOpen)) {
              newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
            }

            if (!search) {
              listRef.current.focus();
            }
          } else {
            newState.highlightedIndex = null;
          }
        }

      case _downshift.default.stateChangeTypes['keyDownHome']:
      case _downshift.default.stateChangeTypes['keyDownEnd']:
        if (open && (0, _isNumber2.default)(changes.highlightedIndex)) {
          newState.highlightedIndex = changes.highlightedIndex;
          newState.itemIsFromKeyboard = true;
        }

        break;

      case _downshift.default.stateChangeTypes.mouseUp:
        if (open) {
          newState.open = false;
          newState.highlightedIndex = null;
        }

        break;

      case _downshift.default.stateChangeTypes.clickButton:
      case _downshift.default.stateChangeTypes.keyDownSpaceButton:
        newState.open = changes.isOpen;

        if (changes.isOpen) {
          var _highlightedIndexOnArrowKeyOpen = getHighlightedIndexOnArrowKeyOpen(changes);

          if ((0, _isNumber2.default)(_highlightedIndexOnArrowKeyOpen)) {
            newState.highlightedIndex = _highlightedIndexOnArrowKeyOpen;
          }

          if (!search) {
            listRef.current.focus();
          }
        } else {
          newState.highlightedIndex = null;
        }

        break;

      case _downshift.default.stateChangeTypes.itemMouseEnter:
        newState.highlightedIndex = changes.highlightedIndex;
        newState.itemIsFromKeyboard = false;
        break;

      case _downshift.default.stateChangeTypes.unknown:
        if (changes.selectedItem) {
          newState.value = multiple ? [].concat(value, [changes.selectedItem]) : [changes.selectedItem];
          newState.searchQuery = multiple ? '' : changes.inputValue;
          newState.open = false;
          newState.highlightedIndex = changes.highlightedIndex;
          tryFocusTriggerButton();
        } else {
          newState.open = changes.isOpen;
        }

      default:
        break;
    }

    if ((0, _isEmpty2.default)(newState)) {
      return;
    }

    var handlers = [newState.highlightedIndex !== undefined && 'onHighlightedIndexChange', newState.open !== undefined && 'onOpenChange', newState.searchQuery !== undefined && 'onSearchQueryChange', newState.value !== undefined && 'onChange'].filter(Boolean);
    setStateAndInvokeHandler(handlers, null, newState);
  };

  var isSelectedItemActive = function isSelectedItemActive(index) {
    return index === activeSelectedIndex;
  };

  var handleItemOverrides = function handleItemOverrides(item, index, getItemProps, selected) {
    return function (predefinedProps) {
      return {
        accessibilityItemProps: Object.assign({}, getItemProps({
          item: item,
          index: index,
          disabled: item['disabled'],
          onClick: function onClick(e) {
            e.stopPropagation();
            e.nativeEvent.stopImmediatePropagation();
            (0, _invoke2.default)(predefinedProps, 'onClick', e, predefinedProps);
          }
        }), !multiple && {
          'aria-selected': selected
        })
      };
    };
  };

  var handleSelectedItemOverrides = function handleSelectedItemOverrides(item) {
    return function (predefinedProps) {
      return {
        onRemove: function onRemove(e, dropdownSelectedItemProps) {
          handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
        },
        onClick: function onClick(e, dropdownSelectedItemProps) {
          setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
            activeSelectedIndex: value.indexOf(item)
          });
          e.stopPropagation();
          (0, _invoke2.default)(predefinedProps, 'onClick', e, dropdownSelectedItemProps);
        },
        onKeyDown: function onKeyDown(e, dropdownSelectedItemProps) {
          handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps);
        }
      };
    };
  };

  var handleSearchInputOverrides = function handleSearchInputOverrides(highlightedIndex, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps) {
    return function (predefinedProps) {
      var handleInputBlur = function handleInputBlur(e, searchInputProps) {
        if (!disabled) {
          setFocused(false);
          setIsFromKeyboard((0, _utils.isFromKeyboard)());
          e.nativeEvent['preventDownshiftDefault'] = true;
        }

        (0, _invoke2.default)(predefinedProps, 'onInputBlur', e, searchInputProps);
      };

      var handleInputKeyDown = function handleInputKeyDown(e, searchInputProps) {
        if (!disabled) {
          switch ((0, _accessibility.getCode)(e)) {
            // https://github.com/downshift-js/downshift/issues/1097
            // Downshift skips Home/End if Deopdown is opened
            case _accessibility.keyboardKey.Home:
              e.nativeEvent['preventDownshiftDefault'] = filteredItems.length === 0;
              break;

            case _accessibility.keyboardKey.End:
              e.nativeEvent['preventDownshiftDefault'] = filteredItems.length === 0;
              break;

            case _accessibility.keyboardKey.Tab:
              e.stopPropagation();
              handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);
              break;

            case _accessibility.keyboardKey.ArrowLeft:
              e.stopPropagation();

              if (!context.rtl) {
                trySetLastSelectedItemAsActive();
              }

              break;

            case _accessibility.keyboardKey.ArrowRight:
              e.stopPropagation();

              if (context.rtl) {
                trySetLastSelectedItemAsActive();
              }

              break;

            case _accessibility.keyboardKey.Backspace:
              e.stopPropagation();
              tryRemoveItemFromValue();
              break;

            case _accessibility.keyboardKey.Escape:
              // If dropdown list is open ESC should close it and not propagate to the parent
              // otherwise event should propagate
              if (open) {
                e.stopPropagation();
              }

            default:
              break;
          }
        }

        (0, _invoke2.default)(predefinedProps, 'onInputKeyDown', e, Object.assign({}, searchInputProps, {
          highlightedIndex: highlightedIndex,
          selectItemAtIndex: selectItemAtIndex
        }));
      };

      return {
        // getInputProps adds Downshift handlers. We also add our own by passing them as params to that function.
        // user handlers were also added to our handlers previously, at the beginning of this function.
        accessibilityInputProps: Object.assign({}, getInputProps({
          disabled: disabled,
          onBlur: function onBlur(e) {
            handleInputBlur(e, predefinedProps);
          },
          onKeyDown: function onKeyDown(e) {
            handleInputKeyDown(e, predefinedProps);
          },
          onChange: function onChange(e) {
            // we prevent the onChange input event to bubble up to our Dropdown handler,
            // since in Dropdown it gets handled as onSearchQueryChange.
            e.stopPropagation(); // A state modification should be triggered there otherwise it will go to an another frame and will break
            // cursor position:
            // https://github.com/facebook/react/issues/955#issuecomment-469352730

            setSearchQuery(e.target.value);
          },
          'aria-labelledby': ariaLabelledby
        })),
        // same story as above for getRootProps.
        accessibilityComboboxProps: accessibilityComboboxProps,
        inputRef: function inputRef(node) {
          (0, _reactComponentRef.handleRef)(predefinedProps.inputRef, node);
          _inputRef.current = node;
        },
        onFocus: function onFocus(e, searchInputProps) {
          if (!disabled) {
            setFocused(true);
            setIsFromKeyboard((0, _utils.isFromKeyboard)());
          }

          (0, _invoke2.default)(predefinedProps, 'onFocus', e, searchInputProps);
        },
        onInputBlur: function onInputBlur(e, searchInputProps) {
          handleInputBlur(e, searchInputProps);
        },
        onInputKeyDown: function onInputKeyDown(e, searchInputProps) {
          handleInputKeyDown(e, searchInputProps);
        }
      };
    };
  };
  /**
   * Custom Tab selection logic, at least until Downshift will implement selection on blur.
   * Also keeps focus on multiple selection dropdown when selecting by Tab.
   */


  var handleTabSelection = function handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu) {
    if (open) {
      if (!(0, _isNil2.default)(highlightedIndex) && filteredItems.length && !items[highlightedIndex]['disabled']) {
        selectItemAtIndex(highlightedIndex);

        if (multiple && !moveFocusOnTab) {
          e.preventDefault();
        }
      } else {
        toggleMenu();
      }
    }
  };

  var trySetLastSelectedItemAsActive = function trySetLastSelectedItemAsActive() {
    if (!multiple || _inputRef.current && _inputRef.current.selectionStart !== 0) {
      return;
    }

    if (value.length > 0) {
      // If last element was already active, perform a 'reset' of activeSelectedIndex.
      if (activeSelectedIndex === value.length - 1) {
        setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
          activeSelectedIndex: value.length - 1
        });
      } else {
        setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
          activeSelectedIndex: value.length - 1
        });
      }
    }
  };

  var tryRemoveItemFromValue = function tryRemoveItemFromValue() {
    if (multiple && (searchQuery === '' || _inputRef.current.selectionStart === 0 && _inputRef.current.selectionEnd === 0) && value.length > 0) {
      removeItemFromValue();
    }
  };

  var handleClear = function handleClear(e) {
    setStateAndInvokeHandler(['onChange', 'onActiveSelectedIndexChange', 'onHighlightedIndexChange'], e, {
      activeSelectedIndex: multiple ? null : undefined,
      highlightedIndex: highlightFirstItemOnOpen ? 0 : null,
      open: false,
      searchQuery: search ? '' : undefined,
      value: []
    });
    tryFocusSearchInput();
    tryFocusTriggerButton();
  };

  var handleContainerClick = function handleContainerClick() {
    tryFocusSearchInput();
  };

  var handleTriggerButtonKeyDown = function handleTriggerButtonKeyDown(e) {
    switch ((0, _accessibility.getCode)(e)) {
      case _accessibility.keyboardKey.ArrowLeft:
        if (!context.rtl) {
          trySetLastSelectedItemAsActive();
        }

        return;

      case _accessibility.keyboardKey.ArrowRight:
        if (context.rtl) {
          trySetLastSelectedItemAsActive();
        }

        return;

      default:
        return;
    }
  };

  var handleListKeyDown = function handleListKeyDown(e, highlightedIndex, accessibilityInputPropsKeyDown, toggleMenu, selectItemAtIndex) {
    var keyCode = (0, _accessibility.getCode)(e);

    switch (keyCode) {
      case _accessibility.keyboardKey.Tab:
        handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);
        return;

      case _accessibility.keyboardKey.Escape:
        accessibilityInputPropsKeyDown(e);
        tryFocusTriggerButton();
        e.stopPropagation();
        return;

      default:
        var keyString = String.fromCharCode(keyCode);

        if (/[a-zA-Z0-9]/.test(keyString)) {
          setHighlightedIndexOnCharKeyDown(keyString);
        }

        accessibilityInputPropsKeyDown(e);
        return;
    }
  };

  var handleSelectedItemKeyDown = function handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps) {
    var previousKey = context.rtl ? _accessibility.keyboardKey.ArrowRight : _accessibility.keyboardKey.ArrowLeft;
    var nextKey = context.rtl ? _accessibility.keyboardKey.ArrowLeft : _accessibility.keyboardKey.ArrowRight;

    switch ((0, _accessibility.getCode)(e)) {
      case _accessibility.keyboardKey.Delete:
      case _accessibility.keyboardKey.Backspace:
        handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
        break;

      case previousKey:
        if (value.length > 0 && !(0, _isNil2.default)(activeSelectedIndex) && activeSelectedIndex > 0) {
          setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
            activeSelectedIndex: activeSelectedIndex - 1
          });
        }

        break;

      case nextKey:
        if (value.length > 0 && !(0, _isNil2.default)(activeSelectedIndex)) {
          if (activeSelectedIndex < value.length - 1) {
            setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
              activeSelectedIndex: activeSelectedIndex + 1
            });
          } else {
            setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
              activeSelectedIndex: null
            });

            if (search) {
              e.preventDefault(); // prevents caret to forward one position in input.

              _inputRef.current.focus();
            } else {
              buttonRef.current.focus();
            }
          }
        }

        break;

      default:
        break;
    }

    (0, _invoke2.default)(predefinedProps, 'onKeyDown', e, dropdownSelectedItemProps);
  };

  var handleTriggerButtonOrListFocus = function handleTriggerButtonOrListFocus() {
    setFocused(true);
    setIsFromKeyboard((0, _utils.isFromKeyboard)());
  };

  var handleTriggerButtonBlur = function handleTriggerButtonBlur(e) {
    if (listRef.current !== e.relatedTarget) {
      setFocused(false);
      setIsFromKeyboard((0, _utils.isFromKeyboard)());
    }
  };

  var handleListBlur = function handleListBlur(e) {
    if (buttonRef.current !== e.relatedTarget) {
      setFocused(false);
      setIsFromKeyboard((0, _utils.isFromKeyboard)());
    }
  };
  /**
   * Sets highlightedIndex to be the item that starts with the character keys the
   * user has typed. Only used in non-search dropdowns.
   *
   * @param keystring - The string the item needs to start with. It is composed by typing keys in fast succession.
   */


  var setHighlightedIndexOnCharKeyDown = function setHighlightedIndexOnCharKeyDown(keyString) {
    var newStartingString = "" + startingString + keyString.toLowerCase();
    var newHighlightedIndex = -1;
    setStartingString(newStartingString);
    clearStartingString();

    if ((0, _isNumber2.default)(highlightedIndex)) {
      newHighlightedIndex = (0, _findIndex2.default)(filteredItemStrings, function (item) {
        return item.startsWith(newStartingString);
      }, highlightedIndex + (startingString.length > 0 ? 0 : 1));
    }

    if (newHighlightedIndex < 0) {
      newHighlightedIndex = (0, _findIndex2.default)(filteredItemStrings, function (item) {
        return item.startsWith(newStartingString);
      });
    }

    if (newHighlightedIndex >= 0) {
      setStateAndInvokeHandler(['onHighlightedIndexChange'], null, {
        highlightedIndex: newHighlightedIndex
      });
    }
  };

  var handleSelectedItemRemove = function handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps) {
    setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
      activeSelectedIndex: null
    });
    removeItemFromValue(item);
    tryFocusSearchInput();
    tryFocusTriggerButton();
    (0, _invoke2.default)(predefinedProps, 'onRemove', e, dropdownSelectedItemProps);
  };

  var removeItemFromValue = function removeItemFromValue(item) {
    var poppedItem = item;
    var newValue = [].concat(value);

    if (poppedItem) {
      newValue = newValue.filter(function (currentElement) {
        return currentElement !== item;
      });
    } else {
      poppedItem = newValue.pop();
    }

    if (getA11ySelectionMessage && getA11ySelectionMessage.onRemove) {
      setA11ySelectionMessage(getA11ySelectionMessage.onRemove(poppedItem));
    }

    setStateAndInvokeHandler(['onChange'], null, {
      value: newValue
    });
  };
  /**
   * Calls setState and invokes event handler exposed to user.
   * We don't have the event object for most events coming from Downshift se we send an empty event
   * because we want to keep the event handling interface
   */


  var setStateAndInvokeHandler = function setStateAndInvokeHandler(handlerNames, event, newState) {
    var proposedValue = (0, _isNil2.default)(newState.value) ? value : newState.value; // `proposedValue` should be normalized for single/multiple variations, `null` condition is
    // required as first item can be undefined

    var newValue = multiple ? proposedValue : proposedValue[0] || null;

    if (newState.hasOwnProperty('activeSelectedIndex')) {
      setActiveSelectedIndex(newState.activeSelectedIndex);
    }

    if (newState.hasOwnProperty('highlightedIndex')) {
      setHighlightedIndex(newState.highlightedIndex);
    }

    if (newState.hasOwnProperty('itemIsFromKeyboard')) {
      setItemIsFromKeyboard(newState.itemIsFromKeyboard);
    }

    if (newState.hasOwnProperty('open')) {
      setOpen(newState.open);
    }

    if (newState.hasOwnProperty('searchQuery')) {
      setSearchQuery(newState.searchQuery);
    }

    if (newState.hasOwnProperty('value')) {
      setValue(newState.value);
    }

    handlerNames.forEach(function (handlerName) {
      (0, _invoke2.default)(props, handlerName, event, Object.assign({}, props, newState, {
        value: newValue
      }));
    });
  };

  var tryFocusTriggerButton = function tryFocusTriggerButton() {
    if (!search && buttonRef.current) {
      buttonRef.current.focus();
    }
  };

  var tryFocusSearchInput = function tryFocusSearchInput() {
    if (search && _inputRef.current) {
      _inputRef.current.focus();
    }
  };
  /**
   * If there is no value we use the placeholder value
   * otherwise, for single selection we convert the value with itemToString
   * and for multiple selection we return empty string, the values are rendered by renderSelectedItems
   */


  var getSelectedItemAsString = function getSelectedItemAsString(value) {
    if (!value) {
      return search ? '' : placeholder;
    }

    if (multiple) {
      return '';
    }

    return itemToString(value);
  };

  var getHighlightedIndexOnArrowKeyOpen = function getHighlightedIndexOnArrowKeyOpen(changes) {
    var isArrowUp = changes.type === _downshift.default.stateChangeTypes.keyDownArrowUp;
    var isArrowDown = changes.type === _downshift.default.stateChangeTypes.keyDownArrowDown;
    var itemsLength = filteredItems.length;

    if (highlightedIndex) {
      return highlightedIndex;
    }

    if (highlightFirstItemOnOpen) {
      // otherwise, if highlightFirstItemOnOpen prop is provied, highlight first item.
      return 0;
    }

    if (!multiple && !search && value.length > 0) {
      // in single selection, if there is a selected item, highlight it.
      var _offset = isArrowUp ? -1 : isArrowDown ? 1 : 0;

      var newHighlightedIndex = items.indexOf(value[0]) + _offset;

      if (newHighlightedIndex >= itemsLength) {
        return 0;
      }

      if (newHighlightedIndex < 0) {
        return itemsLength - 1;
      }

      return newHighlightedIndex;
    }

    if (isArrowDown) {
      return 0;
    }

    if (isArrowUp) {
      return itemsLength - 1;
    }

    return null;
  };
  /**
   * Function that sets and cleans the selection message after it has been set,
   * so it is not read anymore via virtual cursor.
   */


  var setA11ySelectionMessage = function setA11ySelectionMessage(a11ySelectionStatus) {
    setA11ySelectionStatus(a11ySelectionStatus);
    clearA11ySelectionMessage();
  };

  React.useEffect(function () {
    return function () {
      clearStartingString.cancel();
      clearA11ySelectionMessage.cancel();
    };
  }, [clearA11ySelectionMessage, clearStartingString]);
  var element = /*#__PURE__*/React.createElement(ElementType, (0, _extends2.default)({
    className: classes.root,
    onBlur: handleOnBlur,
    onChange: handleChange,
    ref: ref
  }, unhandledProps, process.env.NODE_ENV === 'test' && {
    'data-test-focused': focused
  }), /*#__PURE__*/React.createElement(_downshift.default, {
    isOpen: open,
    inputValue: search ? searchQuery : null,
    stateReducer: downshiftStateReducer,
    itemToString: itemToString // downshift does not work with arrays as selectedItem.
    ,
    selectedItem: multiple || !value.length ? null : value[0],
    scrollIntoView: function scrollIntoView(node, menu) {
      if (node) {
        var children = menu.children;
        var nodeToScroll = node;
        /**
         * If it's loading downshift doesn't take the last node with loadingMessage
         * in consideration to scrolld so we need to check if the current is the
         * antepenultimate and is so scroll the loading into view, same for headerMessage
         */

        if (loading && children[children.length - 2] === node) {
          nodeToScroll = children[children.length - 1];
        } else if (headerMessage && children[1] === node) {
          nodeToScroll = children[0];
        } // Replicating same config that Downshift uses


        var actions = (0, _computeScrollIntoView.default)(nodeToScroll, {
          boundary: menu,
          // Explicitly set boundary to avoid unnecessary scrolling by checking all parent elements
          scrollMode: 'if-needed',
          block: 'nearest',
          inline: 'nearest'
        });
        actions.forEach(function (_ref) {
          var el = _ref.el,
              top = _ref.top,
              left = _ref.left;
          el.scrollTop = top;
          el.scrollLeft = left;
        });
      }
    },
    getA11yStatusMessage: getA11yStatusMessage,
    highlightedIndex: highlightedIndex,
    onStateChange: handleStateChange,
    onInputValueChange: handleInputValueChange,
    labelId: ariaLabelledby,
    environment: (_context$target3 = context.target) == null ? void 0 : _context$target3.defaultView,
    inputId: searchInput && searchInput['id'] ? searchInput['id'] : undefined
  }, function (_ref2) {
    var getInputProps = _ref2.getInputProps,
        getItemProps = _ref2.getItemProps,
        getMenuProps = _ref2.getMenuProps,
        getRootProps = _ref2.getRootProps,
        getToggleButtonProps = _ref2.getToggleButtonProps,
        toggleMenu = _ref2.toggleMenu,
        highlightedIndex = _ref2.highlightedIndex,
        selectItemAtIndex = _ref2.selectItemAtIndex;

    var _getRootProps = getRootProps({
      refKey: 'innerRef'
    }, {
      suppressRefError: true
    }),
        innerRef = _getRootProps.innerRef,
        accessibilityRootPropsRest = (0, _objectWithoutPropertiesLoose2.default)(_getRootProps, _excluded3);

    var showClearIndicator = clearable && value.length > 0;
    return /*#__PURE__*/React.createElement(_reactComponentRef.Ref, {
      innerRef: innerRef
    }, /*#__PURE__*/React.createElement("div", {
      ref: containerRef,
      className: (0, _classnames.default)(dropdownSlotClassNames.container, classes.container),
      onClick: search && !open ? handleContainerClick : undefined
    }, /*#__PURE__*/React.createElement("div", {
      ref: selectedItemsRef,
      className: (0, _classnames.default)(dropdownSlotClassNames.selectedItems, classes.selectedItems)
    }, !search && renderTriggerButton(getToggleButtonProps), multiple && renderSelectedItems(), search && renderSearchInput(accessibilityRootPropsRest, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables)), showClearIndicator ? _Box.Box.create(clearIndicator, {
      defaultProps: function defaultProps() {
        return Object.assign({
          className: dropdownSlotClassNames.clearIndicator,
          styles: resolvedStyles.clearIndicator,
          accessibility: _accessibility.indicatorBehavior
        }, !search && {
          tabIndex: 0,
          role: 'button'
        });
      },
      overrideProps: function overrideProps(predefinedProps) {
        return {
          onClick: function onClick(e) {
            (0, _invoke2.default)(predefinedProps, 'onClick', e);
            handleClear(e);
          }
        };
      }
    }) : _Box.Box.create(toggleIndicator, {
      defaultProps: function defaultProps() {
        return {
          className: dropdownSlotClassNames.toggleIndicator,
          styles: resolvedStyles.toggleIndicator,
          accessibility: _accessibility.indicatorBehavior
        };
      },
      overrideProps: function overrideProps(predefinedProps) {
        return {
          onClick: function onClick(e) {
            if (!disabled) {
              getToggleButtonProps({
                disabled: disabled
              }).onClick(e);
            }

            (0, _invoke2.default)(predefinedProps, 'onClick', e);
          }
        };
      }
    }), renderItemsList(highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps)));
  }), /*#__PURE__*/React.createElement(_Portal.Portal, {
    open: !!getA11ySelectionMessage
  }, /*#__PURE__*/React.createElement("div", {
    role: "status",
    "aria-live": "polite",
    "aria-relevant": "additions text",
    style: _accessibilityStyles.screenReaderContainerStyles
  }, a11ySelectionStatus)));
  setEnd();
  return element;
});
exports.Dropdown = Dropdown;
Dropdown.displayName = 'Dropdown';
Dropdown.propTypes = Object.assign({}, _utils.commonPropTypes.createCommon({
  accessibility: false,
  children: false,
  content: false
}), {
  activeSelectedIndex: PropTypes.number,
  checkable: PropTypes.bool,
  checkableIndicator: customPropTypes.shorthandAllowingChildren,
  clearable: PropTypes.bool,
  clearIndicator: customPropTypes.shorthandAllowingChildren,
  defaultActiveSelectedIndex: PropTypes.number,
  defaultOpen: PropTypes.bool,
  defaultHighlightedIndex: PropTypes.number,
  defaultSearchQuery: PropTypes.string,
  defaultValue: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  disabled: PropTypes.bool,
  error: PropTypes.bool,
  fluid: PropTypes.bool,
  getA11ySelectionMessage: PropTypes.object,
  getA11yStatusMessage: PropTypes.func,
  highlightFirstItemOnOpen: PropTypes.bool,
  highlightedIndex: PropTypes.number,
  inline: PropTypes.bool,
  inverted: PropTypes.bool,
  items: customPropTypes.collectionShorthand,
  itemToString: PropTypes.func,
  itemToValue: PropTypes.func,
  headerMessage: customPropTypes.itemShorthand,
  list: customPropTypes.itemShorthand,
  loading: PropTypes.bool,
  loadingMessage: customPropTypes.itemShorthand,
  moveFocusOnTab: PropTypes.bool,
  multiple: PropTypes.bool,
  noResultsMessage: customPropTypes.itemShorthand,
  onOpenChange: PropTypes.func,
  onSearchQueryChange: PropTypes.func,
  onBlur: PropTypes.func,
  onChange: PropTypes.func,
  onActiveSelectedIndexChange: PropTypes.func,
  onHighlightedIndexChange: PropTypes.func,
  open: PropTypes.bool,
  placeholder: PropTypes.string,
  renderItem: PropTypes.func,
  renderSelectedItem: PropTypes.func,
  search: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
  searchQuery: PropTypes.string,
  searchInput: customPropTypes.itemShorthand,
  toggleIndicator: customPropTypes.shorthandAllowingChildren,
  triggerButton: customPropTypes.itemShorthand,
  value: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]),
  'aria-labelledby': PropTypes.string,
  'aria-invalid': PropTypes.bool,
  a11ySelectedItemsMessage: PropTypes.string,
  // positioning props
  align: PropTypes.oneOf(_positioner.ALIGNMENTS),
  flipBoundary: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object), PropTypes.oneOf(['clippingParents', 'window', 'scrollParent'])]),
  overflowBoundary: PropTypes.oneOfType([PropTypes.object, PropTypes.arrayOf(PropTypes.object), PropTypes.oneOf(['clippingParents', 'window', 'scrollParent'])]),
  popperRef: customPropTypes.ref,
  position: PropTypes.oneOf(_positioner.POSITIONS),
  positionFixed: PropTypes.bool,
  offset: PropTypes.oneOfType([PropTypes.func, PropTypes.arrayOf(PropTypes.number)]),
  unstable_disableTether: PropTypes.oneOf([true, false, 'all']),
  unstable_pinned: PropTypes.bool,
  autoSize: PropTypes.oneOf(_positioner.AUTOSIZES)
});
Dropdown.handledProps = Object.keys(Dropdown.propTypes);
Dropdown.defaultProps = {
  align: 'start',
  clearIndicator: /*#__PURE__*/React.createElement(_reactIconsNorthstar.CloseIcon, {
    outline: true
  }),
  itemToString: function itemToString(item) {
    if (!item || /*#__PURE__*/React.isValidElement(item)) {
      return '';
    } // targets DropdownItem shorthand objects


    return item.header || String(item);
  },
  itemToValue: function itemToValue(item) {
    if (!item || /*#__PURE__*/React.isValidElement(item)) {
      return '';
    } // targets DropdownItem shorthand objects


    return item.header || String(item);
  },
  list: {},
  position: 'below',
  toggleIndicator: /*#__PURE__*/React.createElement(_reactIconsNorthstar.ChevronDownIcon, {
    outline: true
  }),
  triggerButton: {}
};
Dropdown.Item = _DropdownItem.DropdownItem;
Dropdown.SearchInput = _DropdownSearchInput.DropdownSearchInput;
Dropdown.SelectedItem = _DropdownSelectedItem.DropdownSelectedItem;
//# sourceMappingURL=Dropdown.js.map
