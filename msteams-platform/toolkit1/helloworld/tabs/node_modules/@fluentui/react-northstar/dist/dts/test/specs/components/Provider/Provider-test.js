"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_bindings_1 = require("@fluentui/react-bindings");
var react_northstar_styles_renderer_1 = require("@fluentui/react-northstar-styles-renderer");
var enzyme_1 = require("enzyme");
var React = require("react");
var Provider_1 = require("src/components/Provider/Provider");
var ProviderConsumer_1 = require("src/components/Provider/ProviderConsumer");
var PortalInner_1 = require("src/components/Portal/PortalInner");
var createDocumentMock = function () {
    var externalDocument = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);
    var externalWindow = {
        ontouchstart: function () { },
        addEventListener: function () { },
        removeEventListener: function () { },
    };
    externalDocument.documentElement.appendChild(externalDocument.createElement('body'));
    // `defaultView` is read-only by spec, getter is used as workaround
    // https://github.com/facebook/jest/issues/2227#issuecomment-430435133
    jest.spyOn(externalDocument, 'defaultView', 'get').mockReturnValue(externalWindow);
    return externalDocument;
};
describe('Provider', function () {
    test('is exported', function () {
        expect(require('src/index.ts').Provider).toEqual(Provider_1.Provider);
    });
    test('has a ProviderConsumer subcomponent', function () {
        expect(require('src/index.ts').Provider.Consumer).toEqual(ProviderConsumer_1.ProviderConsumer);
    });
    describe('overwrite', function () {
        var outerTheme = { siteVariables: { brand: 'blue' } };
        var innerTheme = { siteVariables: { secondary: 'yellow' } };
        test('do not overwrite by default', function () {
            var getContext = jest.fn();
            var Consumer = function () {
                getContext(react_bindings_1.useFluentContext());
                return null;
            };
            enzyme_1.mount(React.createElement(Provider_1.Provider, { theme: outerTheme },
                React.createElement(Provider_1.Provider, { theme: innerTheme },
                    React.createElement(Consumer, null))));
            expect(getContext).toBeCalledWith(expect.objectContaining({
                theme: expect.objectContaining({
                    siteVariables: {
                        brand: 'blue',
                        secondary: 'yellow',
                        fontSizes: {},
                    },
                }),
            }));
        });
        test('does overwrite when is true', function () {
            var getContext = jest.fn();
            var Consumer = function () {
                getContext(react_bindings_1.useFluentContext());
                return null;
            };
            enzyme_1.mount(React.createElement(Provider_1.Provider, { theme: outerTheme },
                React.createElement(Provider_1.Provider, { overwrite: true, theme: innerTheme },
                    React.createElement(Consumer, null))));
            expect(getContext).toBeCalledWith(expect.objectContaining({
                theme: expect.objectContaining({
                    siteVariables: {
                        secondary: 'yellow',
                        fontSizes: {},
                    },
                }),
            }));
        });
    });
    describe('staticStyles', function () {
        test('are executed with the merged siteVariables', function () {
            var staticStyle = jest.fn();
            enzyme_1.mount(React.createElement(Provider_1.Provider, { theme: { siteVariables: { brand: 'blue', background: 'red' } } },
                React.createElement(Provider_1.Provider, { theme: {
                        siteVariables: { brand: 'yellow', gray: '#868686' },
                        staticStyles: [staticStyle],
                    } },
                    React.createElement("span", null))));
            expect(staticStyle).toHaveBeenCalledWith(expect.objectContaining({
                background: 'red',
                brand: 'yellow',
                gray: '#868686',
            }));
        });
        test('are executed only once', function () {
            var firstStaticStyle = jest.fn();
            var secondStaticStyle = jest.fn();
            var providerInstance = enzyme_1.mount(React.createElement(Provider_1.Provider, { theme: { staticStyles: [firstStaticStyle] } },
                React.createElement("span", null)));
            providerInstance.setProps({ theme: { staticStyles: [secondStaticStyle] } });
            expect(firstStaticStyle).toHaveBeenCalledTimes(1);
            expect(secondStaticStyle).not.toHaveBeenCalled();
        });
    });
    describe('RTL', function () {
        test('Sets dir="rtl" on the div for RTL theme', function () {
            var component = enzyme_1.mount(React.createElement(Provider_1.Provider, { id: "top-level-provider", rtl: true },
                React.createElement("span", null)));
            var providerDiv = component.find('div#top-level-provider');
            expect(providerDiv.exists()).toBe(true);
            expect(providerDiv.prop('dir')).toEqual('rtl');
        });
        test('Sets dir="ltr" on the div for LTR theme', function () {
            var component = enzyme_1.mount(React.createElement(Provider_1.Provider, { id: "top-level-provider" },
                React.createElement("span", null)));
            var providerDiv = component.find('div#top-level-provider');
            expect(providerDiv.exists()).toBe(true);
            expect(providerDiv.prop('dir')).toEqual('ltr');
        });
        var parentChildMatrix = [
            {
                parentIsRtl: true,
                childIsRtl: true,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: true,
                childIsRtl: undefined,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: true,
                childIsRtl: false,
                expectedChildDir: 'ltr',
            },
            {
                parentIsRtl: false,
                childIsRtl: false,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: false,
                childIsRtl: undefined,
                expectedChildDir: undefined,
            },
            {
                parentIsRtl: false,
                childIsRtl: true,
                expectedChildDir: 'rtl',
            },
        ];
        parentChildMatrix.forEach(function (_a) {
            var parentIsRtl = _a.parentIsRtl, childIsRtl = _a.childIsRtl, expectedChildDir = _a.expectedChildDir;
            test("Nested providers: parent is RTL: " + parentIsRtl + ", child is RTL: " + childIsRtl + ", expected child dir: " + expectedChildDir, function () {
                var component = enzyme_1.mount(React.createElement(Provider_1.Provider, { rtl: parentIsRtl },
                    React.createElement(Provider_1.Provider, { id: "nested-provider", rtl: childIsRtl },
                        React.createElement("span", null))));
                var nestedProviderDiv = component.find('div#nested-provider');
                expect(nestedProviderDiv.exists()).toBe(true);
                expect(nestedProviderDiv.prop('dir')).toEqual(expectedChildDir);
            });
        });
    });
    describe('calls provided renderer', function () {
        //
        // We don't support changing renderer on the fly.
        // So mocks for `target` are required to create a new renderer.
        //
        test('calls renderFont', function () {
            var theme = {
                fontFaces: [
                    {
                        name: 'Segoe UI',
                        paths: ['public/fonts/segoe-ui-regular.woff2'],
                        props: { fontWeight: 400 },
                    },
                ],
            };
            var renderFont = jest.fn();
            var createRenderer = function () { return (__assign(__assign({}, react_northstar_styles_renderer_1.noopRenderer), { renderFont: renderFont })); };
            enzyme_1.mount(React.createElement(react_bindings_1.RendererContext.Provider, { value: createRenderer },
                React.createElement(Provider_1.Provider, { theme: theme, target: createDocumentMock() },
                    React.createElement("div", null))));
            expect(renderFont).toHaveBeenCalled();
        });
    });
    test('calls renderStatic', function () {
        var theme = {
            staticStyles: [
                {
                    a: {
                        textDecoration: 'none',
                    },
                },
            ],
        };
        var renderGlobal = jest.fn();
        var createRenderer = function () { return (__assign(__assign({}, react_northstar_styles_renderer_1.noopRenderer), { renderGlobal: renderGlobal })); };
        enzyme_1.mount(React.createElement(react_bindings_1.RendererContext.Provider, { value: createRenderer },
            React.createElement(Provider_1.Provider, { theme: theme, target: createDocumentMock() },
                React.createElement("div", null))));
        expect(renderGlobal).toHaveBeenCalled();
    });
    describe('target', function () {
        test('performs whatinput init on first Provider mount', function () {
            var externalDocument = createDocumentMock();
            var addEventListener = jest.spyOn(externalDocument.defaultView, 'addEventListener');
            var setAttribute = jest.spyOn(externalDocument.documentElement, 'setAttribute');
            enzyme_1.mount(React.createElement(Provider_1.Provider, { id: "first-provider", target: externalDocument },
                React.createElement(Provider_1.Provider, { id: "second-provider", target: externalDocument },
                    React.createElement("div", null))));
            // mousedown + touchstart + touchend + keyup + keydown
            expect(addEventListener).toHaveBeenCalledTimes(5);
            expect(setAttribute).toHaveBeenCalledWith('data-whatinput', expect.any(String));
        });
        test('performs whatinput cleanup on last Provider unmount', function () {
            var externalDocument = createDocumentMock();
            var removeEventListener = jest.spyOn(externalDocument.defaultView, 'removeEventListener');
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.Provider, { id: "first-provider", target: externalDocument },
                React.createElement(Provider_1.Provider, { id: "second-provider", target: externalDocument },
                    React.createElement("div", null))));
            wrapper.unmount();
            // mousedown + touchstart + touchend + keyup + keydown
            expect(removeEventListener).toHaveBeenCalledTimes(5);
        });
    });
    describe('document.body', function () {
        it('adds an element to document.body', function () {
            var className = 'a-sample-classname';
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.Provider, { className: className },
                React.createElement("div", null)));
            expect(document.querySelector("." + className)).toBeInTheDocument();
            // element should be removed on unmount
            wrapper.unmount();
            expect(document.querySelector("." + className)).not.toBeInTheDocument();
        });
        it('reacts on "className" update and keeps node in HTML tree', function () {
            var className = 'a-sample-classname';
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.Provider, { className: className },
                React.createElement(PortalInner_1.PortalInner, null,
                    React.createElement("div", { id: "sample" }))));
            expect(document.querySelector("." + className)).toBeInTheDocument();
            expect(document.querySelector("." + className + " #sample")).toBeInTheDocument();
            var newClassName = 'an-another-classname';
            wrapper.setProps({ className: newClassName });
            expect(document.querySelector("." + className)).not.toBeInTheDocument();
            expect(document.querySelector("." + newClassName)).toBeInTheDocument();
            expect(document.querySelector("." + newClassName + " #sample")).toBeInTheDocument();
        });
    });
    describe('context', function () {
        it('should memoize passed context value', function () {
            var onRender = jest.fn();
            var Consumer = function () {
                react_bindings_1.useFluentContext();
                onRender();
                return null;
            };
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.Provider, null,
                React.createElement(Consumer, null)));
            wrapper.setProps({});
            expect(onRender).toHaveBeenCalledTimes(1);
        });
        it('should propagate props updates', function () {
            var onRender = jest.fn();
            var Consumer = function () {
                react_bindings_1.useFluentContext();
                onRender();
                return null;
            };
            var wrapper = enzyme_1.mount(React.createElement(Provider_1.Provider, null,
                React.createElement(Consumer, null)));
            wrapper.setProps({ theme: {} });
            expect(onRender).toHaveBeenCalledTimes(2);
        });
    });
});
