import { mergeThemes } from '@fluentui/styles';
import { isBrowser } from './isBrowser';
var defaultDocument = {
  document: 'document'
};
var registeredRenderers = new WeakMap();
export var getRenderer = function getRenderer(createRenderer, target) {
  var actualTarget = target || defaultDocument; // A valid comparisons, default renderer will be used

  if (!isBrowser() || typeof target === 'undefined') {
    actualTarget = defaultDocument;
  } // SSR logic will be handled by condition above
  // eslint-disable-next-line no-undef


  if (isBrowser() && target === document) {
    actualTarget = defaultDocument;
  }

  if (registeredRenderers.has(actualTarget)) {
    return registeredRenderers.get(actualTarget);
  } // To avoid errors related to SSR as `document` may not exist we are using a fake object `defaultDocument`.
  // When a value matches `defaultDocument` we will pass `undefined` to `createRenderer()` and it should handle it
  // properly.


  var createdRenderer = createRenderer(actualTarget === defaultDocument ? undefined : actualTarget);
  registeredRenderers.set(actualTarget, createdRenderer);
  return createdRenderer;
};
export var mergePerformanceOptions = function mergePerformanceOptions(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  return Object.assign.apply(Object, [target].concat(sources));
};
export var mergeBooleanValues = function mergeBooleanValues(target) {
  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    sources[_key2 - 1] = arguments[_key2];
  }

  return sources.reduce(function (acc, next) {
    return typeof next === 'boolean' ? next : acc;
  }, target);
};
export var mergeProviderContexts = function mergeProviderContexts(createRenderer) {
  var emptyContext = {
    theme: {
      siteVariables: {
        fontSizes: {}
      },
      componentVariables: {},
      componentStyles: {},
      fontFaces: [],
      staticStyles: [],
      animations: {}
    },
    rtl: false,
    disableAnimations: false,
    target: isBrowser() ? document : undefined,
    // eslint-disable-line no-undef
    performance: {
      enableSanitizeCssPlugin: process.env.NODE_ENV !== 'production',
      enableStylesCaching: true,
      enableVariablesCaching: true,
      enableBooleanVariablesCaching: false
    },
    telemetry: undefined,
    renderer: undefined
  };

  for (var _len3 = arguments.length, contexts = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    contexts[_key3 - 1] = arguments[_key3];
  }

  return contexts.reduce(function (acc, next) {
    if (!next) return acc;
    acc.theme = mergeThemes(acc.theme, next.theme); // Latest RTL value wins

    var mergedRTL = mergeBooleanValues(acc.rtl, next.rtl);

    if (typeof mergedRTL === 'boolean') {
      acc.rtl = mergedRTL;
    } // Use provided renderer if it is defined


    acc.target = next.target || acc.target;
    acc.renderer = getRenderer(createRenderer, acc.target); // Latest disableAnimations value wins

    var mergedDisableAnimations = mergeBooleanValues(acc.disableAnimations, next.disableAnimations);

    if (typeof mergedDisableAnimations === 'boolean') {
      acc.disableAnimations = mergedDisableAnimations;
    }

    acc.performance = mergePerformanceOptions(acc.performance, next.performance || {});
    acc.telemetry = next.telemetry || acc.telemetry;
    return acc;
  }, emptyContext);
};
//# sourceMappingURL=mergeProviderContexts.js.map
