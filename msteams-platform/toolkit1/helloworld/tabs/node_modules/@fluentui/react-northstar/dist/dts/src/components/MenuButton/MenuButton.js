"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuButton = exports.menuButtonSlotClassNames = exports.menuButtonClassName = void 0;
var React = require("react");
var PropTypes = require("prop-types");
var _ = require("lodash");
var accessibility_1 = require("@fluentui/accessibility");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var utils_1 = require("../../utils");
var factories_1 = require("../../utils/factories");
var Popup_1 = require("../Popup/Popup");
var Menu_1 = require("../Menu/Menu");
var focusUtils_1 = require("./focusUtils");
var positioner_1 = require("../../utils/positioner");
var react_bindings_1 = require("@fluentui/react-bindings");
exports.menuButtonClassName = 'ui-menubutton';
exports.menuButtonSlotClassNames = {
    menu: exports.menuButtonClassName + "__menu",
};
/**
 * A MenuButton displays a menu connected to trigger element.
 * @accessibility
 */
exports.MenuButton = React.forwardRef(function (props, ref) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.MenuButton.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var 
    // MenuButton props:
    contextMenu = props.contextMenu, menu = props.menu, 
    // Popup props:
    accessibility = props.accessibility, align = props.align, className = props.className, defaultOpen = props.defaultOpen, flipBoundary = props.flipBoundary, mountNode = props.mountNode, mouseLeaveDelay = props.mouseLeaveDelay, offset = props.offset, on = props.on, onOpenChange = props.onOpenChange, overflowBoundary = props.overflowBoundary, pointing = props.pointing, popperRef = props.popperRef, position = props.position, positionFixed = props.positionFixed, tabbableTrigger = props.tabbableTrigger, target = props.target, trigger = props.trigger, unstable_disableTether = props.unstable_disableTether, unstable_pinned = props.unstable_pinned, autoSize = props.autoSize, variables = props.variables;
    var _b = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultOpen,
        value: props.open,
        initialValue: false,
    }), open = _b[0], setOpen = _b[1];
    react_bindings_1.useOnIFrameFocus(open, context.target, function (e) {
        setOpen(function (__) {
            _.invoke(props, 'onOpenChange', e, __assign(__assign({}, props), { open: false }));
            return false;
        });
    });
    var menuId = React.useRef();
    menuId.current = utils_1.getOrGenerateIdFromShorthand('menubutton-menu-', menu, menuId.current);
    var triggerId = React.useRef();
    triggerId.current = utils_1.getOrGenerateIdFromShorthand('menubutton-trigger-', trigger, triggerId.current);
    var triggerRef = React.useRef();
    var menuRef = React.useRef();
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.MenuButton.handledProps, props);
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: exports.MenuButton.displayName,
        actionHandlers: {
            closeMenu: function (e) { return closeMenu(e); },
            openAndFocusFirst: function (e) { return openAndFocus(e, 'first'); },
            openAndFocusLast: function (e) { return openAndFocus(e, 'last'); },
        },
        mapPropsToBehavior: function () { return ({
            menuId: menuId.current,
            triggerId: triggerId.current,
            open: open,
            trigger: props.trigger,
            contextMenu: contextMenu,
            on: on,
            tabbableTrigger: tabbableTrigger,
        }); },
        rtl: context.rtl,
    });
    var popupProps = {
        accessibility: accessibility,
        align: align,
        defaultOpen: defaultOpen,
        mountNode: mountNode,
        mouseLeaveDelay: mouseLeaveDelay,
        flipBoundary: flipBoundary,
        offset: offset,
        on: on,
        onOpenChange: onOpenChange,
        open: open,
        overflowBoundary: overflowBoundary,
        pointing: pointing,
        popperRef: popperRef,
        position: position,
        positionFixed: positionFixed,
        tabbableTrigger: tabbableTrigger,
        target: target,
        trigger: trigger,
        unstable_disableTether: unstable_disableTether,
        unstable_pinned: unstable_pinned,
        autoSize: autoSize,
    };
    var _c = react_bindings_1.useStyles(exports.MenuButton.displayName, {
        className: exports.menuButtonClassName,
        mapPropsToInlineStyles: function () { return ({
            className: className,
            styles: props.styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }), classes = _c.classes, resolvedStyles = _c.styles;
    var closeMenu = function (e) {
        handleOpenChange(e, false);
    };
    var openAndFocus = function (e, which) {
        e.preventDefault();
        handleOpenChange(e, true, function () { return menuRef.current && focusUtils_1.focusMenuItem(menuRef.current, which); });
    };
    var handleOpenChange = function (e, open, callback) {
        _.invoke(props, 'onOpenChange', e, __assign(__assign({}, props), { open: open }));
        setOpen(open);
        callback && callback();
    };
    var handleMenuOverrides = function (predefinedProps) { return ({
        onItemClick: function (e, itemProps) {
            _.invoke(predefinedProps, 'onItemClick', e, itemProps);
            _.invoke(props, 'onMenuItemClick', e, itemProps);
            if (!itemProps || !itemProps.menu) {
                // do not close if clicked on item with submenu
                handleOpenChange(e, false);
            }
        },
        onKeyDown: function (e, itemProps) {
            _.invoke(predefinedProps, 'onKeyDown', e, itemProps);
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.stopPropagation();
            }
        },
    }); };
    var content = Menu_1.Menu.create(menu, {
        defaultProps: function () {
            return getA11yProps('menu', {
                vertical: true,
                className: exports.menuButtonSlotClassNames.menu,
            });
        },
        overrideProps: handleMenuOverrides,
    });
    var overrideProps = __assign({ accessibility: getA11yProps.unstable_behaviorDefinition, open: open, onOpenChange: function (e, _a) {
            var open = _a.open;
            handleOpenChange(e, open);
        }, content: {
            styles: resolvedStyles.popupContent,
            content: content && React.createElement(react_component_ref_1.Ref, { innerRef: menuRef }, content),
        }, children: undefined }, (contextMenu
        ? {
            on: 'context',
            trapFocus: true,
            tabbableTrigger: false,
        }
        : {
            inline: true,
            autoFocus: true,
        }));
    var popup = Popup_1.Popup.create(popupProps, { overrideProps: overrideProps });
    if (contextMenu) {
        setEnd();
        return popup;
    }
    var element = getA11yProps.unstable_wrapWithFocusZone(React.createElement(ElementType, __assign({}, getA11yProps('root', __assign({ ref: ref, className: classes.root }, unhandledProps))),
        React.createElement(react_component_ref_1.Ref, { innerRef: triggerRef }, popup)));
    setEnd();
    return element;
});
exports.MenuButton.displayName = 'MenuButton';
exports.MenuButton.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    content: false,
})), { align: PropTypes.oneOf(positioner_1.ALIGNMENTS), defaultOpen: PropTypes.bool, mountNode: customPropTypes.domNode, mouseLeaveDelay: PropTypes.number, offset: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.arrayOf(PropTypes.number),
    ]), on: PropTypes.oneOfType([
        PropTypes.oneOf(['hover', 'click', 'focus', 'context']),
        PropTypes.arrayOf(PropTypes.oneOf(['click', 'focus', 'context'])),
        PropTypes.arrayOf(PropTypes.oneOf(['hover', 'focus', 'context'])),
    ]), flipBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), overflowBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), open: PropTypes.bool, onMenuItemClick: PropTypes.func, onOpenChange: PropTypes.func, popperRef: customPropTypes.ref, position: PropTypes.oneOf(positioner_1.POSITIONS), positionFixed: PropTypes.bool, target: PropTypes.any, trigger: customPropTypes.every([customPropTypes.disallow(['children']), PropTypes.any]), tabbableTrigger: PropTypes.bool, unstable_disableTether: PropTypes.oneOf([true, false, 'all']), unstable_pinned: PropTypes.bool, autoSize: PropTypes.oneOf(positioner_1.AUTOSIZES), menu: PropTypes.oneOfType([
        customPropTypes.itemShorthandWithoutJSX,
        PropTypes.arrayOf(customPropTypes.itemShorthandWithoutJSX),
    ]), contextMenu: PropTypes.bool });
exports.MenuButton.defaultProps = {
    accessibility: accessibility_1.menuButtonBehavior,
    align: 'start',
    position: 'below',
};
exports.MenuButton.handledProps = Object.keys(exports.MenuButton.propTypes);
exports.MenuButton.create = factories_1.createShorthandFactory({ Component: exports.MenuButton, mappedProp: 'menu' });
