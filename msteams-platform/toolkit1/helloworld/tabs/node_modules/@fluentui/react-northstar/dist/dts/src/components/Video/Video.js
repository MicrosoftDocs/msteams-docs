"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Video = exports.videoClassName = void 0;
var react_component_ref_1 = require("@fluentui/react-component-ref");
var PropTypes = require("prop-types");
var React = require("react");
var accessibility_1 = require("@fluentui/accessibility");
var utils_1 = require("../../utils");
var react_bindings_1 = require("@fluentui/react-bindings");
exports.videoClassName = 'ui-video';
/**
 * A Video provides ability to embed video content.
 */
exports.Video = React.forwardRef(function (props, ref) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Video.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var controls = props.controls, autoPlay = props.autoPlay, loop = props.loop, poster = props.poster, src = props.src, muted = props.muted, variables = props.variables, className = props.className, design = props.design, styles = props.styles;
    var videoRef = React.useRef();
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Video.handledProps, props);
    var getA11yProps = react_bindings_1.useAccessibility(props.accessibility, {
        debugName: exports.Video.displayName,
    });
    React.useEffect(function () {
        // this is a workaround for a potential memory leak in Chromium which retains a Detached HTMLVideoElement when <video autoplay> is unmounted
        // https://bugs.chromium.org/p/chromium/issues/detail?id=969049
        return function () {
            if (videoRef.current) {
                // we want to perform the cleanup on the latest element rendered
                // eslint-disable-next-line react-hooks/exhaustive-deps
                videoRef.current.src = '';
            }
        };
    }, []);
    React.useEffect(function () {
        // React doesn't guaranty that props will be set:
        // https://github.com/facebook/react/issues/10389
        if (videoRef.current) {
            videoRef.current.muted = !!muted;
        }
    }, [muted]);
    var classes = react_bindings_1.useStyles(exports.Video.displayName, {
        className: exports.videoClassName,
        mapPropsToInlineStyles: function () { return ({ className: className, variables: variables, design: design, styles: styles }); },
    }).classes;
    var element = (React.createElement(react_component_ref_1.Ref, { innerRef: videoRef },
        React.createElement(ElementType, __assign({}, getA11yProps('root', __assign({ className: classes.root, autoPlay: autoPlay, controls: controls, ref: ref, loop: loop, poster: poster, src: src }, unhandledProps))))));
    setEnd();
    return element;
});
exports.Video.create = utils_1.createShorthandFactory({ Component: exports.Video, mappedProp: 'src' });
exports.Video.displayName = 'Video';
exports.Video.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    children: false,
    content: false,
})), { autoPlay: PropTypes.bool, controls: PropTypes.bool, loop: PropTypes.bool, muted: PropTypes.bool, poster: PropTypes.string, src: PropTypes.string });
exports.Video.defaultProps = {
    as: 'video',
    accessibility: accessibility_1.videoBehavior,
    controls: true,
    autoPlay: false,
    muted: false,
};
exports.Video.handledProps = Object.keys(exports.Video.propTypes);
