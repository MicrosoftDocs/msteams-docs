"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MenuItem = exports.menuItemSlotClassNames = exports.menuItemClassName = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var Menu_1 = require("./Menu");
var MenuItemIcon_1 = require("./MenuItemIcon");
var MenuItemContent_1 = require("./MenuItemContent");
var MenuItemIndicator_1 = require("./MenuItemIndicator");
var MenuItemWrapper_1 = require("./MenuItemWrapper");
var positioner_1 = require("../../utils/positioner");
var menuContext_1 = require("./menuContext");
var react_icons_northstar_1 = require("@fluentui/react-icons-northstar");
exports.menuItemClassName = 'ui-menu__item';
exports.menuItemSlotClassNames = {
    submenu: exports.menuItemClassName + "__submenu",
};
/**
 * A MenuItem is an actionable item within a Menu.
 */
exports.MenuItem = React.forwardRef(function (inputProps, ref) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.MenuItem.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var parentProps = react_bindings_1.useContextSelectors(menuContext_1.MenuContext, {
        active: function (v) { return v.activeIndex === inputProps.index; },
        onItemClick: function (v) { return v.onItemClick; },
        onItemSelect: function (v) { return v.onItemSelect; },
        variables: function (v) { return v.variables; },
        slotProps: function (v) { return v.slotProps.item; },
        accessibility: function (v) { return v.behaviors.item; },
    }); // TODO: we should improve typings for the useContextSelectors
    var props = __assign(__assign(__assign({}, parentProps.slotProps), { active: parentProps.active, variables: parentProps.variables, accessibility: parentProps.accessibility }), inputProps);
    var _b = props.accessibility, accessibility = _b === void 0 ? accessibility_1.menuItemBehavior : _b, children = props.children, content = props.content, icon = props.icon, wrapper = props.wrapper, primary = props.primary, secondary = props.secondary, active = props.active, vertical = props.vertical, indicator = props.indicator, disabled = props.disabled, underlined = props.underlined, iconOnly = props.iconOnly, inSubmenu = props.inSubmenu, pills = props.pills, pointing = props.pointing, className = props.className, design = props.design, styles = props.styles, variables = props.variables, on = props.on, index = props.index;
    var _c = positioner_1.partitionPopperPropsFromShorthand(props.menu), menu = _c[0], positioningProps = _c[1];
    var _d = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultMenuOpen,
        value: props.menuOpen,
        initialValue: false,
    }), menuOpen = _d[0], setMenuOpen = _d[1];
    react_bindings_1.useOnIFrameFocus(menuOpen, context.target, function (e) {
        setMenuOpen(function (__) {
            _.invoke(props, 'onMenuOpenChange', e, __assign(__assign({}, props), { menuOpen: false }));
            return false;
        });
    });
    var _e = React.useState(false), isFromKeyboard = _e[0], setIsFromKeyboard = _e[1];
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.MenuItem.handledProps, props);
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: Menu_1.Menu.displayName,
        actionHandlers: {
            performClick: function (event) { return !event.defaultPrevented && handleClick(event); },
            openMenu: function (event) { return openMenu(event); },
            closeAllMenusAndFocusNextParentItem: function (event) { return closeAllMenus(event); },
            closeMenu: function (event) { return closeMenu(event); },
            closeMenuAndFocusTrigger: function (event) { return closeMenu(event, true); },
            doNotNavigateNextParentItem: function (event) {
                event.stopPropagation();
            },
            closeAllMenus: function (event) { return closeAllMenus(event); },
        },
        mapPropsToBehavior: function () { return ({
            menuOpen: menuOpen,
            hasMenu: !!menu,
            disabled: disabled,
            vertical: vertical,
            active: active,
        }); },
        rtl: context.rtl,
    });
    var _f = react_bindings_1.useStyles(exports.MenuItem.displayName, {
        className: exports.menuItemClassName,
        mapPropsToStyles: function () { return ({
            primary: primary,
            underlined: underlined,
            active: active,
            vertical: vertical,
            pointing: pointing,
            secondary: secondary,
            disabled: disabled,
            iconOnly: iconOnly,
            pills: pills,
            inSubmenu: inSubmenu,
            isFromKeyboard: isFromKeyboard,
        }); },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: react_bindings_1.mergeVariablesOverrides(parentProps.variables, variables),
        }); },
        rtl: context.rtl,
    }), classes = _f.classes, resolvedStyles = _f.styles;
    var menuRef = React.useRef();
    var itemRef = React.useRef();
    var handleWrapperBlur = function (e) {
        if (!props.inSubmenu && !e.currentTarget.contains(e.relatedTarget)) {
            trySetMenuOpen(false, e);
        }
    };
    var dismissOnScroll = function (e) {
        if (!isSubmenuOpen())
            return;
        // we only need to dismiss if the scroll happens outside the menu
        if (!menuRef.current.contains(e.target)) {
            trySetMenuOpen(false, e);
        }
    };
    var outsideClickHandler = function (e) {
        if (!isSubmenuOpen())
            return;
        if (!utils_1.doesNodeContainClick(itemRef.current, e, context.target) &&
            !utils_1.doesNodeContainClick(menuRef.current, e, context.target)) {
            trySetMenuOpen(false, e);
        }
    };
    var performClick = function (e) {
        if (menu) {
            if (utils_1.doesNodeContainClick(menuRef.current, e, context.target)) {
                // submenu was clicked => close it and propagate
                trySetMenuOpen(false, e, function () { return react_bindings_1.focusAsync(itemRef.current); });
            }
            else {
                // the menuItem element was clicked => toggle the open/close and stop propagation
                trySetMenuOpen(active && on !== 'hover' ? !menuOpen : true, e);
                e.stopPropagation();
                e.preventDefault();
            }
        }
    };
    var handleClick = function (e) {
        if (disabled) {
            e.preventDefault();
            return;
        }
        performClick(e);
        _.invoke(props, 'onClick', e, props);
        _.invoke(parentProps, 'onItemClick', e, props);
    };
    var handleBlur = function (e) {
        setIsFromKeyboard(false);
        _.invoke(props, 'onBlur', e, props);
    };
    var handleFocus = function (e) {
        setIsFromKeyboard(utils_1.isFromKeyboard());
        _.invoke(props, 'onFocus', e, props);
    };
    var isSubmenuOpen = function () {
        return !!(menu && menuOpen);
    };
    var closeAllMenus = function (e) {
        if (!isSubmenuOpen()) {
            return;
        }
        trySetMenuOpen(false, e, function () {
            if (!inSubmenu) {
                react_bindings_1.focusAsync(itemRef.current);
            }
        });
        // avoid spacebar scrolling the page
        if (!inSubmenu) {
            e.preventDefault();
        }
    };
    var closeMenu = function (e, forceTriggerFocus) {
        if (!isSubmenuOpen()) {
            return;
        }
        var shouldStopPropagation = inSubmenu || props.vertical;
        trySetMenuOpen(false, e, function () {
            if (forceTriggerFocus || shouldStopPropagation) {
                react_bindings_1.focusAsync(itemRef.current);
            }
        });
        if (forceTriggerFocus || shouldStopPropagation) {
            e.stopPropagation();
        }
    };
    var openMenu = function (e) {
        if (menu && !menuOpen) {
            trySetMenuOpen(true, e);
            _.invoke(parentProps, 'onItemSelect', e, index);
            _.invoke(props, 'onActiveChanged', e, __assign(__assign({}, props), { active: true }));
            e.stopPropagation();
            e.preventDefault();
        }
    };
    var rootHandlers = __assign({}, (!wrapper && __assign({ onClick: handleClick }, (on === 'hover' && {
        onMouseEnter: function (e) {
            utils_1.setWhatInputSource(context.target, 'mouse');
            trySetMenuOpen(true, e);
            _.invoke(props, 'onMouseEnter', e, props);
            _.invoke(parentProps, 'onItemSelect', e, index);
        },
        onMouseLeave: function (e) {
            trySetMenuOpen(false, e);
            _.invoke(props, 'onMouseLeave', e, props);
        },
    }))));
    var trySetMenuOpen = function (newValue, e, onStateChanged) {
        setMenuOpen(newValue);
        // The reason why post-effect is not passed as callback to trySetState method
        // is that in 'controlled' mode the post-effect is applied before final re-rendering
        // which cause a broken behavior: for e.g. when it is needed to focus submenu trigger on ESC.
        // TODO: all DOM post-effects should be applied at componentDidMount & componentDidUpdated stages.
        onStateChanged && onStateChanged();
        _.invoke(props, 'onMenuOpenChange', e, __assign(__assign({}, props), { menuOpen: newValue }));
    };
    var menuItemInner = (React.createElement(react_component_ref_1.Ref, { innerRef: function (node) {
            itemRef.current = node;
            react_component_ref_1.handleRef(ref, node);
        } },
        React.createElement(ElementType, __assign({}, getA11yProps('root', __assign({ className: classes.root, disabled: disabled, onBlur: handleBlur, onFocus: handleFocus, onClick: handleClick }, unhandledProps)), rootHandlers), utils_1.childrenExist(children) ? (children) : (React.createElement(React.Fragment, null,
            utils_1.createShorthand(MenuItemIcon_1.MenuItemIcon, icon, {
                defaultProps: function () {
                    return getA11yProps('icon', {
                        hasContent: !!content,
                        iconOnly: iconOnly,
                    });
                },
            }),
            utils_1.createShorthand(MenuItemContent_1.MenuItemContent, content, {
                defaultProps: function () {
                    return getA11yProps('content', {
                        hasIcon: !!icon,
                        hasMenu: !!menu,
                        inSubmenu: inSubmenu,
                        vertical: vertical,
                    });
                },
            }),
            menu &&
                utils_1.createShorthand(MenuItemIndicator_1.MenuItemIndicator, indicator, {
                    defaultProps: function () {
                        return getA11yProps('indicator', {
                            iconOnly: iconOnly,
                            vertical: vertical,
                            inSubmenu: inSubmenu,
                            active: active,
                            primary: primary,
                            underlined: underlined,
                        });
                    },
                }))))));
    var handleWrapperOverrides = function (predefinedProps) { return (__assign({ onBlur: function (e) {
            handleWrapperBlur(e);
            _.invoke(predefinedProps, 'onBlur', e, props);
        } }, (on === 'hover' && {
        onMouseEnter: function (e) {
            utils_1.setWhatInputSource(context.target, 'mouse');
            trySetMenuOpen(true, e);
            _.invoke(predefinedProps, 'onMouseEnter', e, props);
            _.invoke(parentProps, 'onItemSelect', e, index);
        },
        onMouseLeave: function (e) {
            trySetMenuOpen(false, e);
            _.invoke(predefinedProps, 'onMouseLeave', e, props);
        },
    }))); };
    var maybeSubmenu = menu && menuOpen ? (React.createElement(React.Fragment, null,
        React.createElement(react_component_ref_1.Ref, { innerRef: menuRef },
            React.createElement(positioner_1.Popper, __assign({ align: vertical ? 'top' : context.rtl ? 'end' : 'start', position: vertical ? (context.rtl ? 'before' : 'after') : 'below', targetRef: itemRef }, positioningProps), utils_1.createShorthand(Menu_1.Menu, menu, {
                defaultProps: function () { return ({
                    accessibility: accessibility_1.submenuBehavior,
                    className: exports.menuItemSlotClassNames.submenu,
                    vertical: true,
                    primary: props.primary,
                    secondary: props.secondary,
                    submenu: true,
                    styles: resolvedStyles.menu,
                    indicator: props.indicator,
                }); },
                overrideProps: function (predefinedProps) { return ({
                    onClick: function (e) {
                        handleClick(e);
                        _.invoke(predefinedProps, 'onClick', e, props);
                    },
                }); },
            }))),
        React.createElement(react_component_event_listener_1.EventListener, { listener: outsideClickHandler, target: context.target, type: "click" }),
        React.createElement(react_component_event_listener_1.EventListener, { listener: dismissOnScroll, target: context.target, type: "wheel", capture: true }),
        React.createElement(react_component_event_listener_1.EventListener, { listener: dismissOnScroll, target: context.target, type: "touchmove", capture: true }))) : null;
    if (wrapper) {
        var wrapperElement = utils_1.createShorthand(MenuItemWrapper_1.MenuItemWrapper, wrapper, {
            defaultProps: function () {
                return getA11yProps('wrapper', {
                    active: active,
                    disabled: disabled,
                    iconOnly: iconOnly,
                    isFromKeyboard: isFromKeyboard,
                    pills: pills,
                    pointing: pointing,
                    secondary: secondary,
                    underlined: underlined,
                    vertical: vertical,
                    primary: primary,
                    on: on,
                    variables: variables,
                });
            },
            overrideProps: function (predefinedProps) { return (__assign({ children: (React.createElement(React.Fragment, null,
                    menuItemInner,
                    maybeSubmenu)) }, handleWrapperOverrides(predefinedProps))); },
        });
        setEnd();
        return wrapperElement;
    }
    setEnd();
    return menuItemInner;
});
exports.MenuItem.displayName = 'MenuItem';
exports.MenuItem.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    content: 'shorthand',
})), { active: PropTypes.bool, disabled: PropTypes.bool, icon: customPropTypes.shorthandAllowingChildren, on: PropTypes.oneOf(['hover']), iconOnly: PropTypes.bool, index: PropTypes.number, itemPosition: PropTypes.number, itemsCount: PropTypes.number, onClick: PropTypes.func, onFocus: PropTypes.func, onBlur: PropTypes.func, pills: PropTypes.bool, pointing: PropTypes.oneOf(['start', 'end', true, false]), primary: customPropTypes.every([customPropTypes.disallow(['secondary']), PropTypes.bool]), secondary: customPropTypes.every([customPropTypes.disallow(['primary']), PropTypes.bool]), underlined: PropTypes.bool, vertical: PropTypes.bool, wrapper: PropTypes.oneOfType([PropTypes.node, PropTypes.object]), menu: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), menuOpen: PropTypes.bool, defaultMenuOpen: PropTypes.bool, onActiveChanged: PropTypes.func, inSubmenu: PropTypes.bool, indicator: customPropTypes.shorthandAllowingChildren, onMenuOpenChange: PropTypes.func });
exports.MenuItem.handledProps = Object.keys(exports.MenuItem.propTypes);
exports.MenuItem.shorthandConfig = {
    mappedProp: 'content',
};
exports.MenuItem.defaultProps = {
    as: 'a',
    wrapper: {},
    indicator: React.createElement(react_icons_northstar_1.ChevronEndIcon, { outline: true }),
};
