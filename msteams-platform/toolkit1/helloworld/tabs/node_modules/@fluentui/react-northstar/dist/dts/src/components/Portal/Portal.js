"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Portal = void 0;
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var PropTypes = require("prop-types");
var React = require("react");
var _ = require("lodash");
var utils_1 = require("../../utils");
var PortalInner_1 = require("./PortalInner");
/**
 * (DEPRECATED) A Portal allows to render children outside of their parent.
 *
 * @deprecated Please use "Popup" or "Dialog" components instead.
 */
var Portal = function (props) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(exports.Portal.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var children = props.children, content = props.content, trapFocus = props.trapFocus, trigger = props.trigger, triggerAccessibility = props.triggerAccessibility;
    var portalRef = React.useRef();
    var triggerRef = React.useRef();
    var _b = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultOpen,
        value: props.open,
        initialValue: false,
    }), open = _b[0], setOpen = _b[1];
    var renderPortal = function () {
        var contentToRender = utils_1.childrenExist(children) ? children : content;
        var focusTrapZoneProps = (_.keys(trapFocus).length && trapFocus) || {};
        return (open && (React.createElement(react_component_ref_1.Ref, { innerRef: portalRef },
            React.createElement(PortalInner_1.PortalInner, __assign({ onMount: handleMount, onUnmount: handleUnmount }, utils_1.rtlTextContainer.getAttributes({ forElements: [contentToRender] })),
                trapFocus ? React.createElement(react_bindings_1.FocusTrapZone, __assign({}, focusTrapZoneProps), contentToRender) : contentToRender,
                React.createElement(react_component_event_listener_1.EventListener, { listener: handleDocumentClick, target: context.target, type: "click" })))));
    };
    var renderTrigger = function () {
        return (trigger && (React.createElement(react_component_ref_1.Ref, { innerRef: handleTriggerRef }, React.cloneElement(trigger, __assign(__assign({ onClick: handleTriggerClick }, triggerAccessibility.attributes), triggerAccessibility.keyHandlers)))));
    };
    var handleMount = function () {
        _.invoke(props, 'onMount', props);
    };
    var handleUnmount = function () {
        _.invoke(props, 'onUnmount', props);
    };
    var handleTriggerRef = function (node) {
        triggerRef.current = node;
        react_component_ref_1.handleRef(props.triggerRef, node);
    };
    var handleTriggerClick = function (e) {
        var unhandledProps = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            unhandledProps[_i - 1] = arguments[_i];
        }
        _.invoke(props, 'onTriggerClick', e); // Call handler from parent component
        _.invoke.apply(// Call handler from parent component
        _, __spreadArray([trigger, 'props.onClick', e], unhandledProps)); // Call original event handler
        setOpen(function (isOpen) { return !isOpen; });
    };
    var handleDocumentClick = function (e) {
        if (!portalRef || // no portal
            utils_1.doesNodeContainClick(triggerRef.current, e, context.target) || // event happened in trigger (delegate to trigger handlers)
            utils_1.doesNodeContainClick(portalRef.current, e, context.target) // event happened in the portal
        ) {
            return; // ignore the click
        }
        _.invoke(props, 'onOutsideClick', e);
        setOpen(false);
    };
    var element = (React.createElement(React.Fragment, null,
        renderPortal(),
        renderTrigger()));
    setEnd();
    return element;
};
exports.Portal = Portal;
exports.Portal.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    accessibility: false,
    as: false,
    className: false,
    styled: false,
})), { defaultOpen: PropTypes.bool, onMount: PropTypes.func, onUnmount: PropTypes.func, open: PropTypes.bool, trigger: PropTypes.element, triggerRef: customPropTypes.ref, triggerAccessibility: PropTypes.object, onTriggerClick: PropTypes.func, onOutsideClick: PropTypes.func, trapFocus: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]) });
exports.Portal.handledProps = Object.keys(exports.Portal.propTypes);
exports.Portal.create = utils_1.createShorthandFactory({
    Component: exports.Portal,
});
exports.Portal.defaultProps = {
    triggerAccessibility: {},
};
