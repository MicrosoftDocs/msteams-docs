"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolbarRadioGroup = exports.toolbarRadioGroupClassName = void 0;
var accessibility_1 = require("@fluentui/accessibility");
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var _ = require("lodash");
var PropTypes = require("prop-types");
var React = require("react");
var utils_1 = require("../../utils");
var ToolbarDivider_1 = require("./ToolbarDivider");
var ToolbarItem_1 = require("./ToolbarItem");
var toolbarVariablesContext_1 = require("./toolbarVariablesContext");
exports.toolbarRadioGroupClassName = 'ui-toolbars'; // FIXME: required by getComponentInfo/isConformant. But this is group inside a toolbar not a group of toolbars
/**
 * A ToolbarRadioGroup renders Toolbar item as a group of mutually exclusive options.
 * Component doesn't implement mutual exclusiveness, it just serves accessibility purposes.
 *
 * @accessibility
 * Implements [ARIA RadioGroup](https://www.w3.org/TR/wai-aria-practices/#radiobutton) design pattern.
 */
exports.ToolbarRadioGroup = react_bindings_1.compose(function (props, ref, composeOptions) {
    var context = react_bindings_1.useFluentContext();
    var _a = react_bindings_1.useTelemetry(composeOptions.displayName, context.telemetry), setStart = _a.setStart, setEnd = _a.setEnd;
    setStart();
    var accessibility = props.accessibility, activeIndex = props.activeIndex, children = props.children, className = props.className, design = props.design, items = props.items, variables = props.variables, styles = props.styles;
    var itemRefs = [];
    var slotProps = composeOptions.resolveSlotProps(props);
    var parentVariables = React.useContext(toolbarVariablesContext_1.ToolbarVariablesContext);
    var mergedVariables = react_bindings_1.mergeVariablesOverrides(parentVariables, variables);
    var getA11yProps = react_bindings_1.useAccessibility(accessibility, {
        debugName: composeOptions.displayName,
        actionHandlers: {
            nextItem: function (event) { return setFocusedItem(event, 1); },
            prevItem: function (event) { return setFocusedItem(event, -1); },
        },
        rtl: context.rtl,
    });
    var classes = react_bindings_1.useStyles(composeOptions.displayName, {
        className: composeOptions.className,
        composeOptions: composeOptions,
        mapPropsToInlineStyles: function () { return ({ className: className, design: design, styles: styles, variables: mergedVariables }); },
        rtl: context.rtl,
        unstable_props: props,
    }).classes;
    var setFocusedItem = function (event, direction) {
        // filter items which are not disabled
        var filteredRadioItems = _.filter(itemRefs, function (item, index) {
            var currentItem = items[index];
            return currentItem && !currentItem.disabled;
        });
        // get the index of currently focused element (w/ tabindex = 0) or the first one as default
        var currentFocusedIndex = _.findIndex(filteredRadioItems, function (item) {
            return item.current.tabIndex === 0;
        }) || 0;
        var itemsLength = filteredRadioItems.length;
        var nextIndex = currentFocusedIndex + direction;
        if (nextIndex >= itemsLength) {
            nextIndex = 0;
        }
        if (nextIndex < 0) {
            nextIndex = itemsLength - 1;
        }
        var nextItemToFocus = filteredRadioItems[nextIndex].current;
        if (nextItemToFocus) {
            nextItemToFocus.focus();
        }
        if (context.target.activeElement === nextItemToFocus) {
            event.stopPropagation();
        }
        event.preventDefault();
    };
    var renderItems = function () {
        return _.map(items, function (item, index) {
            var kind = _.get(item, 'kind', 'item');
            var ref = React.createRef();
            itemRefs[index] = ref;
            if (kind === 'divider') {
                return utils_1.createShorthand(composeOptions.slots.divider, item, {
                    defaultProps: function () { return slotProps.divider; },
                });
            }
            var toolbarItem = utils_1.createShorthand(composeOptions.slots.item, item, {
                defaultProps: function () { return (__assign(__assign({}, slotProps.item), { active: activeIndex === index })); },
            });
            return (React.createElement(react_component_ref_1.Ref, { innerRef: ref, key: toolbarItem.key }, toolbarItem));
        });
    };
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(composeOptions.handledProps, props);
    var element = (React.createElement(ElementType, __assign({}, getA11yProps('root', __assign(__assign({}, unhandledProps), { className: classes.root, ref: ref }))),
        React.createElement(toolbarVariablesContext_1.ToolbarVariablesProvider, { value: mergedVariables }, utils_1.childrenExist(children) ? children : renderItems())));
    setEnd();
    return element;
}, {
    className: exports.toolbarRadioGroupClassName,
    displayName: 'ToolbarRadioGroup',
    slots: {
        item: ToolbarItem_1.ToolbarItem,
        divider: ToolbarDivider_1.ToolbarDivider,
    },
    slotProps: function () { return ({
        item: {
            accessibility: accessibility_1.toolbarRadioGroupItemBehavior,
        },
    }); },
    shorthandConfig: { mappedProp: 'content' },
    handledProps: [
        'accessibility',
        'as',
        'children',
        'className',
        'content',
        'design',
        'styles',
        'variables',
        'activeIndex',
        'items',
    ],
});
exports.ToolbarRadioGroup.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon()), { activeIndex: PropTypes.number, items: customPropTypes.collectionShorthandWithKindProp(['divider', 'item']) });
exports.ToolbarRadioGroup.defaultProps = {
    accessibility: accessibility_1.toolbarRadioGroupBehavior,
};
