"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dropdown = exports.dropdownSlotClassNames = exports.dropdownClassName = void 0;
var react_bindings_1 = require("@fluentui/react-bindings");
var react_component_ref_1 = require("@fluentui/react-component-ref");
var customPropTypes = require("@fluentui/react-proptypes");
var accessibility_1 = require("@fluentui/accessibility");
var React = require("react");
var PropTypes = require("prop-types");
var _ = require("lodash");
var classnames_1 = require("classnames");
var compute_scroll_into_view_1 = require("compute-scroll-into-view");
var downshift_1 = require("downshift");
var utils_1 = require("../../utils");
var List_1 = require("../List/List");
var DropdownItem_1 = require("./DropdownItem");
var DropdownSelectedItem_1 = require("./DropdownSelectedItem");
var DropdownSearchInput_1 = require("./DropdownSearchInput");
var Button_1 = require("../Button/Button");
var accessibilityStyles_1 = require("../../utils/accessibility/Styles/accessibilityStyles");
var Box_1 = require("../Box/Box");
var Portal_1 = require("../Portal/Portal");
var positioner_1 = require("../../utils/positioner");
var react_icons_northstar_1 = require("@fluentui/react-icons-northstar");
exports.dropdownClassName = 'ui-dropdown';
exports.dropdownSlotClassNames = {
    clearIndicator: exports.dropdownClassName + "__clear-indicator",
    container: exports.dropdownClassName + "__container",
    toggleIndicator: exports.dropdownClassName + "__toggle-indicator",
    item: exports.dropdownClassName + "__item",
    itemsList: exports.dropdownClassName + "__items-list",
    searchInput: exports.dropdownClassName + "__searchinput",
    selectedItem: exports.dropdownClassName + "__selecteditem",
    selectedItems: exports.dropdownClassName + "__selected-items",
    triggerButton: exports.dropdownClassName + "__trigger-button",
};
var a11yStatusCleanupTime = 500;
var charKeyPressedCleanupTime = 500;
/** `normalizedValue` should be normalized always as it can be received from props */
function normalizeValue(multiple, rawValue) {
    var normalizedValue = Array.isArray(rawValue) ? rawValue : [rawValue];
    return multiple ? normalizedValue : normalizedValue.slice(0, 1);
}
/**
 * Used to compute the filtered items (by value and search query) and, if needed,
 * their string equivalents, in order to be used throughout the component.
 */
function getFilteredValues(options) {
    var items = options.items, itemToString = options.itemToString, itemToValue = options.itemToValue, multiple = options.multiple, search = options.search, searchQuery = options.searchQuery, value = options.value;
    var filteredItemsByValue = multiple ? _.differenceBy(items, value, itemToValue) : items;
    var filteredItemStrings = _.map(filteredItemsByValue, function (filteredItem) { return itemToString(filteredItem).toLowerCase(); });
    if (search) {
        if (_.isFunction(search)) {
            return {
                filteredItems: search(filteredItemsByValue, searchQuery),
                filteredItemStrings: filteredItemStrings,
            };
        }
        return {
            filteredItems: filteredItemsByValue.filter(function (item) { return itemToString(item).toLowerCase().indexOf(searchQuery.toLowerCase()) !== -1; }),
            filteredItemStrings: filteredItemStrings,
        };
    }
    return {
        filteredItems: filteredItemsByValue,
        filteredItemStrings: filteredItemStrings,
    };
}
var isEmpty = function (prop) {
    return typeof prop === 'object' && !prop.props && !_.get(prop, 'children') && !_.get(prop, 'content');
};
/**
 * A Dropdown allows user to select one or more values from a list of options.
 * Can be created with search and multi-selection capabilities.
 *
 * @accessibility
 * Implements [ARIA Combo Box](https://www.w3.org/TR/wai-aria-practices-1.1/#combobox) design pattern, uses aria-live to announce state changes.
 * @accessibilityIssues
 * [Issue 991203: VoiceOver doesn't narrate properly elements in the input/combobox](https://bugs.chromium.org/p/chromium/issues/detail?id=991203)
 * [JAWS - ESC (ESCAPE) not closing collapsible listbox (dropdown) on first time #528](https://github.com/FreedomScientific/VFO-standards-support/issues/528)
 */
exports.Dropdown = React.forwardRef(function (props, ref) {
    var _a;
    var context = react_bindings_1.useFluentContext();
    var _b = react_bindings_1.useTelemetry(exports.Dropdown.displayName, context.telemetry), setStart = _b.setStart, setEnd = _b.setEnd;
    setStart();
    var ariaLabelledby = props["aria-labelledby"], ariaInvalid = props["aria-invalid"], clearable = props.clearable, clearIndicator = props.clearIndicator, checkable = props.checkable, checkableIndicator = props.checkableIndicator, className = props.className, design = props.design, disabled = props.disabled, error = props.error, fluid = props.fluid, getA11ySelectionMessage = props.getA11ySelectionMessage, a11ySelectedItemsMessage = props.a11ySelectedItemsMessage, getA11yStatusMessage = props.getA11yStatusMessage, inline = props.inline, inverted = props.inverted, itemToString = props.itemToString, itemToValue = props.itemToValue, items = props.items, highlightFirstItemOnOpen = props.highlightFirstItemOnOpen, multiple = props.multiple, headerMessage = props.headerMessage, moveFocusOnTab = props.moveFocusOnTab, noResultsMessage = props.noResultsMessage, loading = props.loading, loadingMessage = props.loadingMessage, placeholder = props.placeholder, renderItem = props.renderItem, renderSelectedItem = props.renderSelectedItem, search = props.search, searchInput = props.searchInput, styles = props.styles, toggleIndicator = props.toggleIndicator, triggerButton = props.triggerButton, variables = props.variables;
    var align = props.align, flipBoundary = props.flipBoundary, overflowBoundary = props.overflowBoundary, popperRef = props.popperRef, position = props.position, positionFixed = props.positionFixed, offset = props.offset, unstable_disableTether = props.unstable_disableTether, unstable_pinned = props.unstable_pinned, autoSize = props.autoSize; // PositioningProps passed directly to Dropdown
    var _c = positioner_1.partitionPopperPropsFromShorthand(props.list), list = _c[0], positioningProps = _c[1]; // PositioningProps passed to Dropdown `list` prop's `popper` key
    var buttonRef = React.useRef();
    var inputRef = React.useRef();
    var listRef = React.useRef();
    var selectedItemsRef = React.useRef();
    var containerRef = React.useRef();
    var defaultTriggerButtonId = React.useMemo(function () { return _.uniqueId('dropdown-trigger-button-'); }, []);
    var ElementType = react_bindings_1.getElementType(props);
    var unhandledProps = react_bindings_1.useUnhandledProps(exports.Dropdown.handledProps, props);
    var _d = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultActiveSelectedIndex,
        initialValue: multiple ? null : undefined,
        value: props.activeSelectedIndex,
    }), activeSelectedIndex = _d[0], setActiveSelectedIndex = _d[1];
    var _e = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultHighlightedIndex,
        initialValue: highlightFirstItemOnOpen ? 0 : null,
        value: props.highlightedIndex,
    }), highlightedIndex = _e[0], setHighlightedIndex = _e[1];
    var _f = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultOpen,
        initialValue: false,
        value: props.open,
    }), open = _f[0], setOpen = _f[1];
    var _g = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultSearchQuery,
        initialValue: search ? '' : undefined,
        value: props.searchQuery,
    }), searchQuery = _g[0], setSearchQuery = _g[1];
    var _h = react_bindings_1.useAutoControlled({
        defaultValue: props.defaultValue,
        initialValue: [],
        value: props.value,
    }), rawValue = _h[0], setValue = _h[1];
    var value = normalizeValue(multiple, rawValue);
    var _j = React.useState(''), a11ySelectionStatus = _j[0], setA11ySelectionStatus = _j[1];
    var _k = React.useState(false), focused = _k[0], setFocused = _k[1];
    var _l = React.useState(false), isFromKeyboard = _l[0], setIsFromKeyboard = _l[1];
    var _m = React.useState(false), itemIsFromKeyboard = _m[0], setItemIsFromKeyboard = _m[1];
    var _o = React.useState(search ? undefined : ''), startingString = _o[0], setStartingString = _o[1];
    var _p = getFilteredValues({
        itemToString: itemToString,
        itemToValue: itemToValue,
        items: items,
        multiple: multiple,
        search: search,
        searchQuery: searchQuery,
        value: value,
    }), filteredItems = _p.filteredItems, filteredItemStrings = _p.filteredItemStrings;
    var _q = react_bindings_1.useStyles(exports.Dropdown.displayName, {
        className: exports.dropdownClassName,
        mapPropsToStyles: function () {
            var _a;
            return ({
                disabled: disabled,
                error: error,
                fluid: fluid,
                focused: focused,
                isEmptyClearIndicator: isEmpty(clearIndicator),
                hasToggleIndicator: !!toggleIndicator,
                inline: inline,
                inverted: inverted,
                isFromKeyboard: isFromKeyboard,
                multiple: multiple,
                open: open,
                position: (_a = positioningProps === null || positioningProps === void 0 ? void 0 : positioningProps.position) !== null && _a !== void 0 ? _a : position,
                search: !!search,
                hasItemsSelected: value.length > 0,
            });
        },
        mapPropsToInlineStyles: function () { return ({
            className: className,
            design: design,
            styles: styles,
            variables: variables,
        }); },
        rtl: context.rtl,
    }), classes = _q.classes, resolvedStyles = _q.styles;
    var clearA11ySelectionMessage = React.useMemo(function () {
        return _.debounce(function () {
            setA11ySelectionStatus('');
        }, a11yStatusCleanupTime);
    }, []);
    var clearStartingString = React.useMemo(function () {
        return _.debounce(function () {
            setStartingString('');
        }, charKeyPressedCleanupTime);
    }, []);
    var handleChange = function (e) {
        // Dropdown component doesn't present any `input` component in markup, however all of our
        // components should handle events transparently.
        _.invoke(props, 'onChange', e, __assign(__assign({}, props), { value: value }));
    };
    var handleOnBlur = function (e) {
        // Dropdown component doesn't present any `input` component in markup, however all of our
        // components should handle events transparently.
        if (e.target !== buttonRef.current) {
            _.invoke(props, 'onBlur', e, props);
        }
    };
    var renderTriggerButton = function (getToggleButtonProps) {
        var content = getSelectedItemAsString(value[0]);
        var triggerButtonId = triggerButton['id'] || defaultTriggerButtonId;
        var triggerButtonProps = getToggleButtonProps(__assign({ disabled: disabled, onFocus: handleTriggerButtonOrListFocus, onBlur: handleTriggerButtonBlur, onKeyDown: function (e) {
                handleTriggerButtonKeyDown(e);
            }, 'aria-invalid': ariaInvalid, 'aria-label': undefined, 'aria-labelledby': [ariaLabelledby, triggerButtonId].filter(function (l) { return !!l; }).join(' ') }, (open && { 'aria-expanded': true })));
        var onClick = triggerButtonProps.onClick, onFocus = triggerButtonProps.onFocus, onBlur = triggerButtonProps.onBlur, onKeyDown = triggerButtonProps.onKeyDown, restTriggerButtonProps = __rest(triggerButtonProps, ["onClick", "onFocus", "onBlur", "onKeyDown"]);
        return (React.createElement(react_component_ref_1.Ref, { innerRef: buttonRef }, utils_1.createShorthand(Button_1.Button, triggerButton, {
            defaultProps: function () { return (__assign({ className: exports.dropdownSlotClassNames.triggerButton, content: content, disabled: disabled, id: triggerButtonId, fluid: true, styles: resolvedStyles.triggerButton }, restTriggerButtonProps)); },
            overrideProps: function (predefinedProps) { return ({
                onClick: function (e) {
                    onClick(e);
                    _.invoke(predefinedProps, 'onClick', e, predefinedProps);
                },
                onFocus: function (e) {
                    onFocus(e);
                    _.invoke(predefinedProps, 'onFocus', e, predefinedProps);
                },
                onBlur: function (e) {
                    if (!disabled) {
                        onBlur(e);
                    }
                    _.invoke(predefinedProps, 'onBlur', e, predefinedProps);
                },
                onKeyDown: function (e) {
                    if (!disabled) {
                        onKeyDown(e);
                    }
                    _.invoke(predefinedProps, 'onKeyDown', e, predefinedProps);
                },
            }); },
        })));
    };
    var renderSearchInput = function (accessibilityComboboxProps, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables) {
        var noPlaceholder = searchQuery.length > 0 || (multiple && value.length > 0);
        return DropdownSearchInput_1.DropdownSearchInput.create(searchInput || {}, {
            defaultProps: function () { return ({
                className: exports.dropdownSlotClassNames.searchInput,
                placeholder: noPlaceholder ? '' : placeholder,
                inline: inline,
                variables: variables,
                disabled: disabled,
            }); },
            overrideProps: handleSearchInputOverrides(highlightedIndex, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps),
        });
    };
    var renderItemsList = function (highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps) {
        var items = open ? renderItems(getItemProps) : [];
        var _a = getMenuProps({ refKey: 'innerRef' }, { suppressRefError: true }), innerRef = _a.innerRef, accessibilityMenuProps = __rest(_a, ["innerRef"]);
        // If it's just a selection, some attributes and listeners from Downshift input need to go on the menu list.
        if (!search) {
            var accessibilityInputProps_1 = getInputProps();
            accessibilityMenuProps['aria-activedescendant'] = accessibilityInputProps_1['aria-activedescendant'];
            accessibilityMenuProps['onKeyDown'] = function (e) {
                handleListKeyDown(e, highlightedIndex, accessibilityInputProps_1['onKeyDown'], toggleMenu, selectItemAtIndex);
            };
        }
        return (React.createElement(react_component_ref_1.Ref, { innerRef: function (listElement) {
                react_component_ref_1.handleRef(listRef, listElement);
                react_component_ref_1.handleRef(innerRef, listElement);
            } },
            React.createElement(positioner_1.Popper, __assign({ rtl: context.rtl, enabled: open, targetRef: containerRef, positioningDependencies: [items.length], 
                // positioning props:
                align: align, flipBoundary: flipBoundary, overflowBoundary: overflowBoundary, popperRef: popperRef, position: position, positionFixed: positionFixed, offset: offset, unstable_disableTether: unstable_disableTether, unstable_pinned: unstable_pinned, autoSize: autoSize }, positioningProps), List_1.List.create(list, {
                defaultProps: function () { return (__assign(__assign({ className: exports.dropdownSlotClassNames.itemsList }, accessibilityMenuProps), { styles: resolvedStyles.list, items: items, tabIndex: search ? undefined : -1, 'aria-hidden': !open })); },
                overrideProps: function (predefinedProps) { return ({
                    onFocus: function (e, listProps) {
                        handleTriggerButtonOrListFocus();
                        _.invoke(predefinedProps, 'onClick', e, listProps);
                    },
                    onBlur: function (e, listProps) {
                        handleListBlur(e);
                        _.invoke(predefinedProps, 'onBlur', e, listProps);
                    },
                }); },
            }))));
    };
    var renderItems = function (getItemProps) {
        var footerItem = renderItemsListFooter();
        var headerItem = renderItemsListHeader();
        var items = _.map(filteredItems, function (item, index) { return ({
            children: function () {
                var selected = value.indexOf(item) !== -1;
                return DropdownItem_1.DropdownItem.create(item, {
                    defaultProps: function () { return (__assign({ className: exports.dropdownSlotClassNames.item, active: highlightedIndex === index, selected: selected, checkable: checkable, checkableIndicator: checkableIndicator, isFromKeyboard: itemIsFromKeyboard, variables: variables }, (typeof item === 'object' &&
                        !item.hasOwnProperty('key') && {
                        key: item.header,
                    }))); },
                    overrideProps: handleItemOverrides(item, index, getItemProps, selected),
                    render: renderItem,
                });
            },
        }); });
        if (footerItem) {
            items.push(footerItem);
        }
        return headerItem ? __spreadArray([headerItem], items) : items;
    };
    var renderItemsListHeader = function () {
        if (headerMessage) {
            return {
                children: function () {
                    return DropdownItem_1.DropdownItem.create(headerMessage, {
                        defaultProps: function () { return ({
                            key: 'items-list-footer-message',
                            styles: resolvedStyles.headerMessage,
                        }); },
                    });
                },
            };
        }
        return null;
    };
    var renderItemsListFooter = function () {
        if (loading) {
            return {
                children: function () {
                    return DropdownItem_1.DropdownItem.create(loadingMessage, {
                        defaultProps: function () { return ({
                            key: 'loading-message',
                            styles: resolvedStyles.loadingMessage,
                        }); },
                    });
                },
            };
        }
        if (filteredItems && filteredItems.length === 0) {
            return {
                children: function () {
                    return DropdownItem_1.DropdownItem.create(noResultsMessage, {
                        defaultProps: function () { return ({
                            key: 'no-results-message',
                            styles: resolvedStyles.noResultsMessage,
                        }); },
                    });
                },
            };
        }
        return null;
    };
    var renderSelectedItems = function () {
        if (value.length === 0) {
            return null;
        }
        var selectedItems = value.map(function (item, index) {
            // (!) an item matches DropdownItemProps
            return DropdownSelectedItem_1.DropdownSelectedItem.create(item, {
                defaultProps: function () { return (__assign({ className: exports.dropdownSlotClassNames.selectedItem, active: isSelectedItemActive(index), variables: variables }, (typeof item === 'object' &&
                    !item.hasOwnProperty('key') && {
                    key: item.header,
                }))); },
                overrideProps: handleSelectedItemOverrides(item),
                render: renderSelectedItem,
            });
        });
        return (React.createElement("div", { role: "listbox", tabIndex: -1, "aria-label": a11ySelectedItemsMessage }, selectedItems));
    };
    var downshiftStateReducer = function (state, changes) {
        var activeElement = context.target.activeElement;
        switch (changes.type) {
            case downshift_1.default.stateChangeTypes.blurButton:
                // Downshift closes the list by default on trigger blur. It does not support the case when dropdown is
                // single selection and focuses list on trigger click/up/down/space/enter. Treating that here.
                if (state.isOpen && activeElement === listRef.current) {
                    return {}; // won't change state in this case.
                }
                _.invoke(props, 'onBlur', null);
            default:
                return changes;
        }
    };
    var handleInputValueChange = function (inputValue, stateAndHelpers) {
        var itemSelected = stateAndHelpers.selectedItem && inputValue === itemToString(stateAndHelpers.selectedItem);
        if (inputValue !== searchQuery &&
            !itemSelected // when item is selected, `handleStateChange` will update searchQuery.
        ) {
            setStateAndInvokeHandler(['onSearchQueryChange'], null, {
                searchQuery: inputValue,
            });
        }
    };
    var handleStateChange = function (changes) {
        var _a, _b;
        var type = changes.type;
        var newState = {};
        switch (type) {
            case downshift_1.default.stateChangeTypes.changeInput: {
                var shouldValueChange = changes.inputValue === '' && !multiple && value.length > 0;
                newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;
                if (shouldValueChange) {
                    newState.value = [];
                }
                if (open) {
                    // we clear value when in single selection user cleared the query.
                    var shouldMenuClose = changes.inputValue === '' || changes.selectedItem !== undefined;
                    if (shouldMenuClose) {
                        newState.open = false;
                    }
                }
                else {
                    newState.open = true;
                }
                break;
            }
            case downshift_1.default.stateChangeTypes.keyDownEnter:
            case downshift_1.default.stateChangeTypes.clickItem:
                var shouldAddHighlightedIndex = !multiple && items && items.length > 0;
                var isSameItemSelected = changes.selectedItem === undefined;
                var newValue = isSameItemSelected ? value[0] : changes.selectedItem;
                newState.searchQuery = getSelectedItemAsString(newValue);
                newState.open = false;
                newState.highlightedIndex = shouldAddHighlightedIndex ? items.indexOf(newValue) : null;
                if (!isSameItemSelected) {
                    newState.value = multiple ? __spreadArray(__spreadArray([], value), [changes.selectedItem]) : [changes.selectedItem];
                    if (getA11ySelectionMessage && getA11ySelectionMessage.onAdd) {
                        setA11ySelectionMessage(getA11ySelectionMessage.onAdd(newValue));
                    }
                }
                if (multiple) {
                    (_a = context.target) === null || _a === void 0 ? void 0 : _a.defaultView.setTimeout(function () { return (selectedItemsRef.current.scrollTop = selectedItemsRef.current.scrollHeight); }, 0);
                }
                // timeout because of NVDA, otherwise it narrates old button value/state
                (_b = context.target) === null || _b === void 0 ? void 0 : _b.defaultView.setTimeout(function () { return tryFocusTriggerButton(); }, 100);
                break;
            case downshift_1.default.stateChangeTypes.keyDownEscape:
                if (search && !multiple) {
                    newState.value = [];
                }
                newState.open = false;
                newState.highlightedIndex = highlightFirstItemOnOpen ? 0 : null;
                break;
            case downshift_1.default.stateChangeTypes.keyDownArrowDown:
            case downshift_1.default.stateChangeTypes.keyDownArrowUp:
                if (changes.isOpen !== undefined) {
                    newState.open = changes.isOpen;
                    newState.highlightedIndex = changes.highlightedIndex;
                    if (changes.isOpen) {
                        var highlightedIndexOnArrowKeyOpen = getHighlightedIndexOnArrowKeyOpen(changes);
                        if (_.isNumber(highlightedIndexOnArrowKeyOpen)) {
                            newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
                        }
                        if (!search) {
                            listRef.current.focus();
                        }
                    }
                    else {
                        newState.highlightedIndex = null;
                    }
                }
            case downshift_1.default.stateChangeTypes['keyDownHome']:
            case downshift_1.default.stateChangeTypes['keyDownEnd']:
                if (open && _.isNumber(changes.highlightedIndex)) {
                    newState.highlightedIndex = changes.highlightedIndex;
                    newState.itemIsFromKeyboard = true;
                }
                break;
            case downshift_1.default.stateChangeTypes.mouseUp:
                if (open) {
                    newState.open = false;
                    newState.highlightedIndex = null;
                }
                break;
            case downshift_1.default.stateChangeTypes.clickButton:
            case downshift_1.default.stateChangeTypes.keyDownSpaceButton:
                newState.open = changes.isOpen;
                if (changes.isOpen) {
                    var highlightedIndexOnArrowKeyOpen = getHighlightedIndexOnArrowKeyOpen(changes);
                    if (_.isNumber(highlightedIndexOnArrowKeyOpen)) {
                        newState.highlightedIndex = highlightedIndexOnArrowKeyOpen;
                    }
                    if (!search) {
                        listRef.current.focus();
                    }
                }
                else {
                    newState.highlightedIndex = null;
                }
                break;
            case downshift_1.default.stateChangeTypes.itemMouseEnter:
                newState.highlightedIndex = changes.highlightedIndex;
                newState.itemIsFromKeyboard = false;
                break;
            case downshift_1.default.stateChangeTypes.unknown:
                if (changes.selectedItem) {
                    newState.value = multiple ? __spreadArray(__spreadArray([], value), [changes.selectedItem]) : [changes.selectedItem];
                    newState.searchQuery = multiple ? '' : changes.inputValue;
                    newState.open = false;
                    newState.highlightedIndex = changes.highlightedIndex;
                    tryFocusTriggerButton();
                }
                else {
                    newState.open = changes.isOpen;
                }
            default:
                break;
        }
        if (_.isEmpty(newState)) {
            return;
        }
        var handlers = [
            newState.highlightedIndex !== undefined && 'onHighlightedIndexChange',
            newState.open !== undefined && 'onOpenChange',
            newState.searchQuery !== undefined && 'onSearchQueryChange',
            newState.value !== undefined && 'onChange',
        ].filter(Boolean);
        setStateAndInvokeHandler(handlers, null, newState);
    };
    var isSelectedItemActive = function (index) {
        return index === activeSelectedIndex;
    };
    var handleItemOverrides = function (item, index, getItemProps, selected) { return function (predefinedProps) { return ({
        accessibilityItemProps: __assign(__assign({}, getItemProps({
            item: item,
            index: index,
            disabled: item['disabled'],
            onClick: function (e) {
                e.stopPropagation();
                e.nativeEvent.stopImmediatePropagation();
                _.invoke(predefinedProps, 'onClick', e, predefinedProps);
            },
        })), (!multiple && {
            'aria-selected': selected,
        })),
    }); }; };
    var handleSelectedItemOverrides = function (item) { return function (predefinedProps) { return ({
        onRemove: function (e, dropdownSelectedItemProps) {
            handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
        },
        onClick: function (e, dropdownSelectedItemProps) {
            setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                activeSelectedIndex: value.indexOf(item),
            });
            e.stopPropagation();
            _.invoke(predefinedProps, 'onClick', e, dropdownSelectedItemProps);
        },
        onKeyDown: function (e, dropdownSelectedItemProps) {
            handleSelectedItemKeyDown(e, item, predefinedProps, dropdownSelectedItemProps);
        },
    }); }; };
    var handleSearchInputOverrides = function (highlightedIndex, selectItemAtIndex, toggleMenu, accessibilityComboboxProps, getInputProps) { return function (predefinedProps) {
        var handleInputBlur = function (e, searchInputProps) {
            if (!disabled) {
                setFocused(false);
                setIsFromKeyboard(utils_1.isFromKeyboard());
                e.nativeEvent['preventDownshiftDefault'] = true;
            }
            _.invoke(predefinedProps, 'onInputBlur', e, searchInputProps);
        };
        var handleInputKeyDown = function (e, searchInputProps) {
            if (!disabled) {
                switch (accessibility_1.getCode(e)) {
                    // https://github.com/downshift-js/downshift/issues/1097
                    // Downshift skips Home/End if Deopdown is opened
                    case accessibility_1.keyboardKey.Home:
                        e.nativeEvent['preventDownshiftDefault'] = filteredItems.length === 0;
                        break;
                    case accessibility_1.keyboardKey.End:
                        e.nativeEvent['preventDownshiftDefault'] = filteredItems.length === 0;
                        break;
                    case accessibility_1.keyboardKey.Tab:
                        e.stopPropagation();
                        handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);
                        break;
                    case accessibility_1.keyboardKey.ArrowLeft:
                        e.stopPropagation();
                        if (!context.rtl) {
                            trySetLastSelectedItemAsActive();
                        }
                        break;
                    case accessibility_1.keyboardKey.ArrowRight:
                        e.stopPropagation();
                        if (context.rtl) {
                            trySetLastSelectedItemAsActive();
                        }
                        break;
                    case accessibility_1.keyboardKey.Backspace:
                        e.stopPropagation();
                        tryRemoveItemFromValue();
                        break;
                    case accessibility_1.keyboardKey.Escape:
                        // If dropdown list is open ESC should close it and not propagate to the parent
                        // otherwise event should propagate
                        if (open) {
                            e.stopPropagation();
                        }
                    default:
                        break;
                }
            }
            _.invoke(predefinedProps, 'onInputKeyDown', e, __assign(__assign({}, searchInputProps), { highlightedIndex: highlightedIndex, selectItemAtIndex: selectItemAtIndex }));
        };
        return {
            // getInputProps adds Downshift handlers. We also add our own by passing them as params to that function.
            // user handlers were also added to our handlers previously, at the beginning of this function.
            accessibilityInputProps: __assign({}, getInputProps({
                disabled: disabled,
                onBlur: function (e) {
                    handleInputBlur(e, predefinedProps);
                },
                onKeyDown: function (e) {
                    handleInputKeyDown(e, predefinedProps);
                },
                onChange: function (e) {
                    // we prevent the onChange input event to bubble up to our Dropdown handler,
                    // since in Dropdown it gets handled as onSearchQueryChange.
                    e.stopPropagation();
                    // A state modification should be triggered there otherwise it will go to an another frame and will break
                    // cursor position:
                    // https://github.com/facebook/react/issues/955#issuecomment-469352730
                    setSearchQuery(e.target.value);
                },
                'aria-labelledby': ariaLabelledby,
            })),
            // same story as above for getRootProps.
            accessibilityComboboxProps: accessibilityComboboxProps,
            inputRef: function (node) {
                react_component_ref_1.handleRef(predefinedProps.inputRef, node);
                inputRef.current = node;
            },
            onFocus: function (e, searchInputProps) {
                if (!disabled) {
                    setFocused(true);
                    setIsFromKeyboard(utils_1.isFromKeyboard());
                }
                _.invoke(predefinedProps, 'onFocus', e, searchInputProps);
            },
            onInputBlur: function (e, searchInputProps) {
                handleInputBlur(e, searchInputProps);
            },
            onInputKeyDown: function (e, searchInputProps) {
                handleInputKeyDown(e, searchInputProps);
            },
        };
    }; };
    /**
     * Custom Tab selection logic, at least until Downshift will implement selection on blur.
     * Also keeps focus on multiple selection dropdown when selecting by Tab.
     */
    var handleTabSelection = function (e, highlightedIndex, selectItemAtIndex, toggleMenu) {
        if (open) {
            if (!_.isNil(highlightedIndex) && filteredItems.length && !items[highlightedIndex]['disabled']) {
                selectItemAtIndex(highlightedIndex);
                if (multiple && !moveFocusOnTab) {
                    e.preventDefault();
                }
            }
            else {
                toggleMenu();
            }
        }
    };
    var trySetLastSelectedItemAsActive = function () {
        if (!multiple || (inputRef.current && inputRef.current.selectionStart !== 0)) {
            return;
        }
        if (value.length > 0) {
            // If last element was already active, perform a 'reset' of activeSelectedIndex.
            if (activeSelectedIndex === value.length - 1) {
                setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                    activeSelectedIndex: value.length - 1,
                });
            }
            else {
                setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                    activeSelectedIndex: value.length - 1,
                });
            }
        }
    };
    var tryRemoveItemFromValue = function () {
        if (multiple &&
            (searchQuery === '' || (inputRef.current.selectionStart === 0 && inputRef.current.selectionEnd === 0)) &&
            value.length > 0) {
            removeItemFromValue();
        }
    };
    var handleClear = function (e) {
        setStateAndInvokeHandler(['onChange', 'onActiveSelectedIndexChange', 'onHighlightedIndexChange'], e, {
            activeSelectedIndex: multiple ? null : undefined,
            highlightedIndex: highlightFirstItemOnOpen ? 0 : null,
            open: false,
            searchQuery: search ? '' : undefined,
            value: [],
        });
        tryFocusSearchInput();
        tryFocusTriggerButton();
    };
    var handleContainerClick = function () {
        tryFocusSearchInput();
    };
    var handleTriggerButtonKeyDown = function (e) {
        switch (accessibility_1.getCode(e)) {
            case accessibility_1.keyboardKey.ArrowLeft:
                if (!context.rtl) {
                    trySetLastSelectedItemAsActive();
                }
                return;
            case accessibility_1.keyboardKey.ArrowRight:
                if (context.rtl) {
                    trySetLastSelectedItemAsActive();
                }
                return;
            default:
                return;
        }
    };
    var handleListKeyDown = function (e, highlightedIndex, accessibilityInputPropsKeyDown, toggleMenu, selectItemAtIndex) {
        var keyCode = accessibility_1.getCode(e);
        switch (keyCode) {
            case accessibility_1.keyboardKey.Tab:
                handleTabSelection(e, highlightedIndex, selectItemAtIndex, toggleMenu);
                return;
            case accessibility_1.keyboardKey.Escape:
                accessibilityInputPropsKeyDown(e);
                tryFocusTriggerButton();
                e.stopPropagation();
                return;
            default:
                var keyString = String.fromCharCode(keyCode);
                if (/[a-zA-Z0-9]/.test(keyString)) {
                    setHighlightedIndexOnCharKeyDown(keyString);
                }
                accessibilityInputPropsKeyDown(e);
                return;
        }
    };
    var handleSelectedItemKeyDown = function (e, item, predefinedProps, dropdownSelectedItemProps) {
        var previousKey = context.rtl ? accessibility_1.keyboardKey.ArrowRight : accessibility_1.keyboardKey.ArrowLeft;
        var nextKey = context.rtl ? accessibility_1.keyboardKey.ArrowLeft : accessibility_1.keyboardKey.ArrowRight;
        switch (accessibility_1.getCode(e)) {
            case accessibility_1.keyboardKey.Delete:
            case accessibility_1.keyboardKey.Backspace:
                handleSelectedItemRemove(e, item, predefinedProps, dropdownSelectedItemProps);
                break;
            case previousKey:
                if (value.length > 0 && !_.isNil(activeSelectedIndex) && activeSelectedIndex > 0) {
                    setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                        activeSelectedIndex: activeSelectedIndex - 1,
                    });
                }
                break;
            case nextKey:
                if (value.length > 0 && !_.isNil(activeSelectedIndex)) {
                    if (activeSelectedIndex < value.length - 1) {
                        setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                            activeSelectedIndex: activeSelectedIndex + 1,
                        });
                    }
                    else {
                        setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
                            activeSelectedIndex: null,
                        });
                        if (search) {
                            e.preventDefault(); // prevents caret to forward one position in input.
                            inputRef.current.focus();
                        }
                        else {
                            buttonRef.current.focus();
                        }
                    }
                }
                break;
            default:
                break;
        }
        _.invoke(predefinedProps, 'onKeyDown', e, dropdownSelectedItemProps);
    };
    var handleTriggerButtonOrListFocus = function () {
        setFocused(true);
        setIsFromKeyboard(utils_1.isFromKeyboard());
    };
    var handleTriggerButtonBlur = function (e) {
        if (listRef.current !== e.relatedTarget) {
            setFocused(false);
            setIsFromKeyboard(utils_1.isFromKeyboard());
        }
    };
    var handleListBlur = function (e) {
        if (buttonRef.current !== e.relatedTarget) {
            setFocused(false);
            setIsFromKeyboard(utils_1.isFromKeyboard());
        }
    };
    /**
     * Sets highlightedIndex to be the item that starts with the character keys the
     * user has typed. Only used in non-search dropdowns.
     *
     * @param keystring - The string the item needs to start with. It is composed by typing keys in fast succession.
     */
    var setHighlightedIndexOnCharKeyDown = function (keyString) {
        var newStartingString = "" + startingString + keyString.toLowerCase();
        var newHighlightedIndex = -1;
        setStartingString(newStartingString);
        clearStartingString();
        if (_.isNumber(highlightedIndex)) {
            newHighlightedIndex = _.findIndex(filteredItemStrings, function (item) { return item.startsWith(newStartingString); }, highlightedIndex + (startingString.length > 0 ? 0 : 1));
        }
        if (newHighlightedIndex < 0) {
            newHighlightedIndex = _.findIndex(filteredItemStrings, function (item) { return item.startsWith(newStartingString); });
        }
        if (newHighlightedIndex >= 0) {
            setStateAndInvokeHandler(['onHighlightedIndexChange'], null, {
                highlightedIndex: newHighlightedIndex,
            });
        }
    };
    var handleSelectedItemRemove = function (e, item, predefinedProps, dropdownSelectedItemProps) {
        setStateAndInvokeHandler(['onActiveSelectedIndexChange'], null, {
            activeSelectedIndex: null,
        });
        removeItemFromValue(item);
        tryFocusSearchInput();
        tryFocusTriggerButton();
        _.invoke(predefinedProps, 'onRemove', e, dropdownSelectedItemProps);
    };
    var removeItemFromValue = function (item) {
        var poppedItem = item;
        var newValue = __spreadArray([], value);
        if (poppedItem) {
            newValue = newValue.filter(function (currentElement) { return currentElement !== item; });
        }
        else {
            poppedItem = newValue.pop();
        }
        if (getA11ySelectionMessage && getA11ySelectionMessage.onRemove) {
            setA11ySelectionMessage(getA11ySelectionMessage.onRemove(poppedItem));
        }
        setStateAndInvokeHandler(['onChange'], null, { value: newValue });
    };
    /**
     * Calls setState and invokes event handler exposed to user.
     * We don't have the event object for most events coming from Downshift se we send an empty event
     * because we want to keep the event handling interface
     */
    var setStateAndInvokeHandler = function (handlerNames, event, newState) {
        var proposedValue = _.isNil(newState.value) ? value : newState.value;
        // `proposedValue` should be normalized for single/multiple variations, `null` condition is
        // required as first item can be undefined
        var newValue = multiple ? proposedValue : proposedValue[0] || null;
        if (newState.hasOwnProperty('activeSelectedIndex')) {
            setActiveSelectedIndex(newState.activeSelectedIndex);
        }
        if (newState.hasOwnProperty('highlightedIndex')) {
            setHighlightedIndex(newState.highlightedIndex);
        }
        if (newState.hasOwnProperty('itemIsFromKeyboard')) {
            setItemIsFromKeyboard(newState.itemIsFromKeyboard);
        }
        if (newState.hasOwnProperty('open')) {
            setOpen(newState.open);
        }
        if (newState.hasOwnProperty('searchQuery')) {
            setSearchQuery(newState.searchQuery);
        }
        if (newState.hasOwnProperty('value')) {
            setValue(newState.value);
        }
        handlerNames.forEach(function (handlerName) {
            _.invoke(props, handlerName, event, __assign(__assign(__assign({}, props), newState), { value: newValue }));
        });
    };
    var tryFocusTriggerButton = function () {
        if (!search && buttonRef.current) {
            buttonRef.current.focus();
        }
    };
    var tryFocusSearchInput = function () {
        if (search && inputRef.current) {
            inputRef.current.focus();
        }
    };
    /**
     * If there is no value we use the placeholder value
     * otherwise, for single selection we convert the value with itemToString
     * and for multiple selection we return empty string, the values are rendered by renderSelectedItems
     */
    var getSelectedItemAsString = function (value) {
        if (!value) {
            return search ? '' : placeholder;
        }
        if (multiple) {
            return '';
        }
        return itemToString(value);
    };
    var getHighlightedIndexOnArrowKeyOpen = function (changes) {
        var isArrowUp = changes.type === downshift_1.default.stateChangeTypes.keyDownArrowUp;
        var isArrowDown = changes.type === downshift_1.default.stateChangeTypes.keyDownArrowDown;
        var itemsLength = filteredItems.length;
        if (highlightedIndex) {
            return highlightedIndex;
        }
        if (highlightFirstItemOnOpen) {
            // otherwise, if highlightFirstItemOnOpen prop is provied, highlight first item.
            return 0;
        }
        if (!multiple && !search && value.length > 0) {
            // in single selection, if there is a selected item, highlight it.
            var offset_1 = isArrowUp ? -1 : isArrowDown ? 1 : 0;
            var newHighlightedIndex = items.indexOf(value[0]) + offset_1;
            if (newHighlightedIndex >= itemsLength) {
                return 0;
            }
            if (newHighlightedIndex < 0) {
                return itemsLength - 1;
            }
            return newHighlightedIndex;
        }
        if (isArrowDown) {
            return 0;
        }
        if (isArrowUp) {
            return itemsLength - 1;
        }
        return null;
    };
    /**
     * Function that sets and cleans the selection message after it has been set,
     * so it is not read anymore via virtual cursor.
     */
    var setA11ySelectionMessage = function (a11ySelectionStatus) {
        setA11ySelectionStatus(a11ySelectionStatus);
        clearA11ySelectionMessage();
    };
    React.useEffect(function () {
        return function () {
            clearStartingString.cancel();
            clearA11ySelectionMessage.cancel();
        };
    }, [clearA11ySelectionMessage, clearStartingString]);
    var element = (React.createElement(ElementType, __assign({ className: classes.root, onBlur: handleOnBlur, onChange: handleChange, ref: ref }, unhandledProps, (process.env.NODE_ENV === 'test' && { 'data-test-focused': focused })),
        React.createElement(downshift_1.default, { isOpen: open, inputValue: search ? searchQuery : null, stateReducer: downshiftStateReducer, itemToString: itemToString, 
            // downshift does not work with arrays as selectedItem.
            selectedItem: multiple || !value.length ? null : value[0], scrollIntoView: function (node, menu) {
                if (node) {
                    var children = menu.children;
                    var nodeToScroll = node;
                    /**
                     * If it's loading downshift doesn't take the last node with loadingMessage
                     * in consideration to scrolld so we need to check if the current is the
                     * antepenultimate and is so scroll the loading into view, same for headerMessage
                     */
                    if (loading && children[children.length - 2] === node) {
                        nodeToScroll = children[children.length - 1];
                    }
                    else if (headerMessage && children[1] === node) {
                        nodeToScroll = children[0];
                    }
                    // Replicating same config that Downshift uses
                    var actions = compute_scroll_into_view_1.default(nodeToScroll, {
                        boundary: menu,
                        scrollMode: 'if-needed',
                        block: 'nearest',
                        inline: 'nearest',
                    });
                    actions.forEach(function (_a) {
                        var el = _a.el, top = _a.top, left = _a.left;
                        el.scrollTop = top;
                        el.scrollLeft = left;
                    });
                }
            }, getA11yStatusMessage: getA11yStatusMessage, highlightedIndex: highlightedIndex, onStateChange: handleStateChange, onInputValueChange: handleInputValueChange, labelId: ariaLabelledby, environment: (_a = context.target) === null || _a === void 0 ? void 0 : _a.defaultView, inputId: searchInput && searchInput['id'] ? searchInput['id'] : undefined }, function (_a) {
            var getInputProps = _a.getInputProps, getItemProps = _a.getItemProps, getMenuProps = _a.getMenuProps, getRootProps = _a.getRootProps, getToggleButtonProps = _a.getToggleButtonProps, toggleMenu = _a.toggleMenu, highlightedIndex = _a.highlightedIndex, selectItemAtIndex = _a.selectItemAtIndex;
            var _b = getRootProps({ refKey: 'innerRef' }, { suppressRefError: true }), innerRef = _b.innerRef, accessibilityRootPropsRest = __rest(_b, ["innerRef"]);
            var showClearIndicator = clearable && value.length > 0;
            return (React.createElement(react_component_ref_1.Ref, { innerRef: innerRef },
                React.createElement("div", { ref: containerRef, className: classnames_1.default(exports.dropdownSlotClassNames.container, classes.container), onClick: search && !open ? handleContainerClick : undefined },
                    React.createElement("div", { ref: selectedItemsRef, className: classnames_1.default(exports.dropdownSlotClassNames.selectedItems, classes.selectedItems) },
                        !search && renderTriggerButton(getToggleButtonProps),
                        multiple && renderSelectedItems(),
                        search &&
                            renderSearchInput(accessibilityRootPropsRest, highlightedIndex, getInputProps, selectItemAtIndex, toggleMenu, variables)),
                    showClearIndicator
                        ? Box_1.Box.create(clearIndicator, {
                            defaultProps: function () { return (__assign({ className: exports.dropdownSlotClassNames.clearIndicator, styles: resolvedStyles.clearIndicator, accessibility: accessibility_1.indicatorBehavior }, (!search && { tabIndex: 0, role: 'button' }))); },
                            overrideProps: function (predefinedProps) { return ({
                                onClick: function (e) {
                                    _.invoke(predefinedProps, 'onClick', e);
                                    handleClear(e);
                                },
                            }); },
                        })
                        : Box_1.Box.create(toggleIndicator, {
                            defaultProps: function () { return ({
                                className: exports.dropdownSlotClassNames.toggleIndicator,
                                styles: resolvedStyles.toggleIndicator,
                                accessibility: accessibility_1.indicatorBehavior,
                            }); },
                            overrideProps: function (predefinedProps) { return ({
                                onClick: function (e) {
                                    if (!disabled) {
                                        getToggleButtonProps({ disabled: disabled }).onClick(e);
                                    }
                                    _.invoke(predefinedProps, 'onClick', e);
                                },
                            }); },
                        }),
                    renderItemsList(highlightedIndex, toggleMenu, selectItemAtIndex, getMenuProps, getItemProps, getInputProps))));
        }),
        React.createElement(Portal_1.Portal, { open: !!getA11ySelectionMessage },
            React.createElement("div", { role: "status", "aria-live": "polite", "aria-relevant": "additions text", style: accessibilityStyles_1.screenReaderContainerStyles }, a11ySelectionStatus))));
    setEnd();
    return element;
});
exports.Dropdown.displayName = 'Dropdown';
exports.Dropdown.propTypes = __assign(__assign({}, utils_1.commonPropTypes.createCommon({
    accessibility: false,
    children: false,
    content: false,
})), { activeSelectedIndex: PropTypes.number, checkable: PropTypes.bool, checkableIndicator: customPropTypes.shorthandAllowingChildren, clearable: PropTypes.bool, clearIndicator: customPropTypes.shorthandAllowingChildren, defaultActiveSelectedIndex: PropTypes.number, defaultOpen: PropTypes.bool, defaultHighlightedIndex: PropTypes.number, defaultSearchQuery: PropTypes.string, defaultValue: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), disabled: PropTypes.bool, error: PropTypes.bool, fluid: PropTypes.bool, getA11ySelectionMessage: PropTypes.object, getA11yStatusMessage: PropTypes.func, highlightFirstItemOnOpen: PropTypes.bool, highlightedIndex: PropTypes.number, inline: PropTypes.bool, inverted: PropTypes.bool, items: customPropTypes.collectionShorthand, itemToString: PropTypes.func, itemToValue: PropTypes.func, headerMessage: customPropTypes.itemShorthand, list: customPropTypes.itemShorthand, loading: PropTypes.bool, loadingMessage: customPropTypes.itemShorthand, moveFocusOnTab: PropTypes.bool, multiple: PropTypes.bool, noResultsMessage: customPropTypes.itemShorthand, onOpenChange: PropTypes.func, onSearchQueryChange: PropTypes.func, onBlur: PropTypes.func, onChange: PropTypes.func, onActiveSelectedIndexChange: PropTypes.func, onHighlightedIndexChange: PropTypes.func, open: PropTypes.bool, placeholder: PropTypes.string, renderItem: PropTypes.func, renderSelectedItem: PropTypes.func, search: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]), searchQuery: PropTypes.string, searchInput: customPropTypes.itemShorthand, toggleIndicator: customPropTypes.shorthandAllowingChildren, triggerButton: customPropTypes.itemShorthand, value: PropTypes.oneOfType([customPropTypes.itemShorthand, customPropTypes.collectionShorthand]), 'aria-labelledby': PropTypes.string, 'aria-invalid': PropTypes.bool, a11ySelectedItemsMessage: PropTypes.string, 
    // positioning props
    align: PropTypes.oneOf(positioner_1.ALIGNMENTS), flipBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), overflowBoundary: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.arrayOf(PropTypes.object),
        PropTypes.oneOf(['clippingParents', 'window', 'scrollParent']),
    ]), popperRef: customPropTypes.ref, position: PropTypes.oneOf(positioner_1.POSITIONS), positionFixed: PropTypes.bool, offset: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.arrayOf(PropTypes.number),
    ]), unstable_disableTether: PropTypes.oneOf([true, false, 'all']), unstable_pinned: PropTypes.bool, autoSize: PropTypes.oneOf(positioner_1.AUTOSIZES) });
exports.Dropdown.handledProps = Object.keys(exports.Dropdown.propTypes);
exports.Dropdown.defaultProps = {
    align: 'start',
    clearIndicator: React.createElement(react_icons_northstar_1.CloseIcon, { outline: true }),
    itemToString: function (item) {
        if (!item || React.isValidElement(item)) {
            return '';
        }
        // targets DropdownItem shorthand objects
        return item.header || String(item);
    },
    itemToValue: function (item) {
        if (!item || React.isValidElement(item)) {
            return '';
        }
        // targets DropdownItem shorthand objects
        return item.header || String(item);
    },
    list: {},
    position: 'below',
    toggleIndicator: React.createElement(react_icons_northstar_1.ChevronDownIcon, { outline: true }),
    triggerButton: {},
};
exports.Dropdown.Item = DropdownItem_1.DropdownItem;
exports.Dropdown.SearchInput = DropdownSearchInput_1.DropdownSearchInput;
exports.Dropdown.SelectedItem = DropdownSelectedItem_1.DropdownSelectedItem;
