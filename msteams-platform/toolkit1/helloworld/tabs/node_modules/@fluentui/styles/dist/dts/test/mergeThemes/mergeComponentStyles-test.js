"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var styles_1 = require("@fluentui/styles");
var debugEnabled = require("../../src/debugEnabled");
var mergeThemes_1 = require("../../src/mergeThemes");
var styleParam = {
    disableAnimations: false,
    props: {},
    rtl: false,
    theme: styles_1.emptyTheme,
    variables: {},
};
describe('mergeComponentStyles', function () {
    var originalDebugEnabled;
    beforeEach(function () {
        originalDebugEnabled = debugEnabled.isEnabled;
    });
    afterEach(function () {
        Object.defineProperty(debugEnabled, 'isEnabled', {
            get: function () { return originalDebugEnabled; },
        });
    });
    function mockIsDebugEnabled(enabled) {
        Object.defineProperty(debugEnabled, 'isEnabled', {
            get: jest.fn(function () { return enabled; }),
        });
    }
    function testMergeComponentStyles(mergeComponentStyles) {
        test("always returns an object", function () {
            expect(mergeComponentStyles({}, {})).toMatchObject({});
            expect(mergeComponentStyles(null, null)).toMatchObject({});
            expect(mergeComponentStyles(undefined, undefined)).toMatchObject({});
            expect(mergeComponentStyles(null, undefined)).toMatchObject({});
            expect(mergeComponentStyles(undefined, null)).toMatchObject({});
            expect(mergeComponentStyles({}, undefined)).toMatchObject({});
            expect(mergeComponentStyles(undefined, {})).toMatchObject({});
            expect(mergeComponentStyles({}, null)).toMatchObject({});
            expect(mergeComponentStyles(null, {})).toMatchObject({});
        });
        test('gracefully handles null and undefined', function () {
            var styles = { root: { color: 'black' } };
            var stylesWithNull = { root: { color: null }, icon: null };
            var stylesWithUndefined = { root: { color: undefined }, icon: undefined };
            expect(function () { return mergeComponentStyles(styles, null); }).not.toThrow();
            expect(function () { return mergeComponentStyles(styles, stylesWithNull); }).not.toThrow();
            expect(function () { return mergeComponentStyles(null, styles); }).not.toThrow();
            expect(function () { return mergeComponentStyles(stylesWithNull, styles); }).not.toThrow();
            expect(function () { return mergeComponentStyles(styles, undefined); }).not.toThrow();
            expect(function () { return mergeComponentStyles(styles, stylesWithUndefined); }).not.toThrow();
            expect(function () { return mergeComponentStyles(undefined, styles); }).not.toThrow();
            expect(function () { return mergeComponentStyles(stylesWithUndefined, styles); }).not.toThrow();
        });
        test('component parts with style properties are merged', function () {
            var target = { root: { color: 'red' } };
            var source = { icon: { color: 'red' } };
            var merged = mergeComponentStyles(target, source);
            expect(merged).toHaveProperty('root');
            expect(merged).toHaveProperty('icon');
        });
        test('converts merged component parts to functions', function () {
            var target = { root: { color: 'red' } };
            var source = { root: { color: 'red' } };
            var merged = mergeComponentStyles(target, source);
            expect(merged.root).toBeInstanceOf(Function);
        });
        test('converts target only component parts to functions', function () {
            var target = { root: { color: 'red' } };
            var merged = mergeComponentStyles(target);
            expect(merged.root).toBeInstanceOf(Function);
        });
        test('component part styles are deeply merged', function () {
            var target = {
                root: {
                    display: 'inline-block',
                    color: 'green',
                    '::before': {
                        content: 'before content',
                    },
                },
            };
            var source = {
                root: {
                    color: 'blue',
                    '::before': {
                        color: 'red',
                    },
                },
            };
            var merged = mergeComponentStyles(target, source);
            expect(merged.root()).toMatchObject({
                display: 'inline-block',
                color: 'blue',
                '::before': {
                    content: 'before content',
                    color: 'red',
                },
            });
        });
        test('functions can accept and apply params', function () {
            var target = { root: function (param) { return (__assign({ target: true }, param)); } };
            var source = { root: function (param) { return (__assign({ source: true }, param)); } };
            var merged = mergeComponentStyles(target, source);
            var styleParam = {
                variables: { iconSize: 'large' },
                props: { primary: true },
            };
            expect(merged.root(styleParam)).toMatchObject(__assign({ source: true, target: true }, styleParam));
        });
    }
    describe('prod version', function () {
        beforeEach(function () {
            mockIsDebugEnabled(true); // it is not possible to enable debug in prod
        });
        testMergeComponentStyles(mergeThemes_1.mergeComponentStyles__PROD);
        test('debug frames are not saved', function () {
            var target = { root: { a: 'tA', b: 'tB' } };
            var source = { root: { a: 'sA', c: { deep: 'c' } } };
            var merged = mergeThemes_1.mergeComponentStyles__PROD(target, source);
            var resolvedRoot = merged.root(styleParam);
            expect(resolvedRoot._debug).toBe(undefined);
        });
        test('keeps references if possible', function () {
            var styleRoot = jest.fn();
            var firstMerge = mergeThemes_1.mergeComponentStyles__PROD({ root: styleRoot }, { root: styleRoot });
            var secondMerge = mergeThemes_1.mergeComponentStyles__PROD(firstMerge, { root: styleRoot });
            expect(secondMerge.root).toBe(styleRoot);
            secondMerge.root(styleParam);
            expect(styleRoot).toHaveBeenCalledTimes(1);
        });
    });
    describe('dev version, debug disabled', function () {
        beforeEach(function () {
            mockIsDebugEnabled(false);
        });
        testMergeComponentStyles(mergeThemes_1.mergeComponentStyles__DEV);
        test('debug frames are not saved', function () {
            var target = { root: { a: 'tA', b: 'tB' } };
            var source = { root: { a: 'sA', c: { deep: 'c' } } };
            var merged = mergeThemes_1.mergeComponentStyles__DEV(target, source);
            var resolvedRoot = merged.root(styleParam);
            expect(resolvedRoot._debug).toBe(undefined);
        });
    });
    describe('dev version, debug enabled', function () {
        beforeEach(function () {
            mockIsDebugEnabled(true);
        });
        testMergeComponentStyles(mergeThemes_1.mergeComponentStyles__DEV);
        describe('debug frames', function () {
            test('are saved', function () {
                var target = { root: { a: 'tA', b: 'tB' } };
                var source = {
                    root: function (_a) {
                        var variables = _a.variables;
                        return ({ a: 'sA', c: { deep: variables.varC } });
                    },
                    icon: { d: 'sD' },
                };
                var merged = mergeThemes_1.mergeComponentStyles__DEV(target, source);
                var resolvedRoot = merged.root({ variables: { varC: 'vC' } });
                expect(resolvedRoot).toMatchObject({
                    _debug: [{ styles: { a: 'tA', b: 'tB' } }, { styles: { a: 'sA', c: { deep: 'vC' } } }],
                });
                var resolvedIcon = merged.icon(styleParam);
                expect(resolvedIcon).toMatchObject({
                    _debug: [{ styles: { d: 'sD' } }],
                });
            });
            test('contain debugId', function () {
                var target = styles_1.withDebugId({ root: { a: 'tA', b: 'tB' } }, 'target');
                var source = styles_1.withDebugId({ root: { a: 'sA', c: { deep: 'c' } } }, 'source');
                var merged = mergeThemes_1.mergeComponentStyles__DEV(target, source);
                var resolvedRoot = merged.root(styleParam);
                expect(resolvedRoot).toMatchObject({
                    _debug: [{ debugId: 'target' }, { debugId: 'source' }],
                });
            });
            test('are flat for recursive merge', function () {
                var target = styles_1.withDebugId({ root: { a: 'tA' } }, 'target');
                var source = styles_1.withDebugId({ root: { a: 'tB' } }, 'source');
                var merged1 = mergeThemes_1.mergeComponentStyles__DEV(target, source);
                var resolvedRoot1 = merged1.root(styleParam);
                expect(resolvedRoot1).toMatchObject({
                    _debug: [{ debugId: 'target' }, { debugId: 'source' }],
                });
                var merged2 = mergeThemes_1.mergeComponentStyles__DEV(mergeThemes_1.mergeComponentStyles__DEV(target, source), source);
                var resolvedRoot2 = merged2.root(styleParam);
                expect(resolvedRoot2).toMatchObject({
                    _debug: [{ debugId: 'target' }, { debugId: 'source' }, { debugId: 'source' }],
                });
                var merged3 = mergeThemes_1.mergeComponentStyles__DEV(target, mergeThemes_1.mergeComponentStyles__DEV(source, source));
                var resolvedRoot3 = merged3.root(styleParam);
                expect(resolvedRoot3).toMatchObject({
                    _debug: [{ debugId: 'target' }, { debugId: 'source' }, { debugId: 'source' }],
                });
            });
        });
    });
});
