"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ref = exports.design = exports.animation = exports.align = exports.size = exports.accessibility = exports.deprecate = exports.collectionShorthandWithKindProp = exports.collectionShorthand = exports.collectionObjectShorthand = exports.itemShorthandWithoutJSX = exports.itemShorthandWithKindProp = exports.itemShorthand = exports.objectItemShorthand = exports.shorthandObjectAllowingChildren = exports.shorthandAllowingChildren = exports.wrapperShorthand = exports.nodeContent = exports.multipleProp = exports.demand = exports.givenProps = exports.some = exports.every = exports.disallow = exports.never = exports.suggest = exports.domNode = void 0;
var _ = require("lodash");
var PropTypes = require("prop-types");
var leven_1 = require("./leven");
var typeOf = function (x) { return Object.prototype.toString.call(x); };
/**
 * Ensure a prop is a valid DOM node.
 */
var domNode = function (props, propName) {
    // skip if prop is undefined
    if (props[propName] === undefined)
        return undefined;
    // skip if prop is null
    if (props[propName] === null)
        return null;
    // skip if prop is valid
    if (props[propName] instanceof Element)
        return undefined;
    return new Error("Invalid prop \"" + propName + "\" supplied, expected a DOM node.");
};
exports.domNode = domNode;
/**
 * Similar to PropTypes.oneOf but shows closest matches.
 * Word order is ignored allowing `left chevron` to match `chevron left`.
 * Useful for very large lists of options (e.g. Icon name, Flag name, etc.)
 * @param suggestions - An array of allowed values.
 */
var suggest = function (suggestions) {
    if (!Array.isArray(suggestions)) {
        throw new Error('Invalid argument supplied to suggest, expected an instance of array.');
    }
    var findBestSuggestions = _.memoize(function (str) {
        var propValueWords = str.split(' ');
        return _.take(_.sortBy(_.map(suggestions, function (suggestion) {
            var suggestionWords = suggestion.split(' ');
            var propValueScore = _.sum(_.map(_.map(propValueWords, function (x) { return _.map(suggestionWords, function (y) { return leven_1.default(x, y); }); }), _.min));
            var suggestionScore = _.sum(_.map(_.map(suggestionWords, function (x) { return _.map(propValueWords, function (y) { return leven_1.default(x, y); }); }), _.min));
            return { suggestion: suggestion, score: propValueScore + suggestionScore };
        }), ['score', 'suggestion']), 3);
    });
    // Convert the suggestions list into a hash map for O(n) lookup times. Ensure
    // the words in each key are sorted alphabetically so that we have a consistent
    // way of looking up a value in the map, i.e. we can sort the words in the
    // incoming propValue and look that up without having to check all permutations.
    var suggestionsLookup = suggestions.reduce(function (acc, key) {
        acc[key.split(' ').sort().join(' ')] = true;
        return acc;
    }, {});
    return function (props, propName, componentName) {
        var propValue = props[propName];
        // skip if prop is undefined or is included in the suggestions
        if (!propValue || suggestionsLookup[propValue])
            return undefined;
        // check if the words were correct but ordered differently.
        // Since we're matching for classNames we need to allow any word order
        // to pass validation, e.g. `left chevron` vs `chevron left`.
        var propValueSorted = propValue.split(' ').sort().join(' ');
        if (suggestionsLookup[propValueSorted])
            return undefined;
        // find best suggestions
        var bestMatches = findBestSuggestions(propValue);
        // skip if a match scored 0
        if (bestMatches.some(function (x) { return x.score === 0; }))
            return undefined;
        return new Error([
            "Invalid prop `" + propName + "` of value `" + propValue + "` supplied to `" + componentName + "`.",
            "\n\nInstead of `" + propValue + "`, did you mean:",
            bestMatches.map(function (x) { return "\n  - " + x.suggestion; }).join(''),
            '\n',
        ].join(''));
    };
};
exports.suggest = suggest;
/**
 * The prop cannot be used.
 * Similar to `deprecate` but with different error message.
 */
var never = function (props, propName, componentName) {
    if (_.isNil(props[propName]) || props[propName] === false)
        return undefined;
    return new Error("Prop `" + propName + "` in `" + componentName + "` cannot be used.");
};
exports.never = never;
/**
 * Disallow other props from being defined with this prop.
 * @param disallowedProps - An array of props that cannot be used with this prop.
 */
var disallow = function (disallowedProps) { return function (props, propName, componentName) {
    if (!Array.isArray(disallowedProps)) {
        throw new Error([
            'Invalid argument supplied to disallow, expected an instance of array.',
            " See `" + propName + "` prop in `" + componentName + "`.",
        ].join(''));
    }
    // skip if prop is undefined
    if (_.isNil(props[propName]) || props[propName] === false)
        return undefined;
    // find disallowed props with values
    var disallowed = disallowedProps.reduce(function (acc, disallowedProp) {
        if (!_.isNil(props[disallowedProp]) && props[disallowedProp] !== false) {
            return __spreadArray(__spreadArray([], acc), [disallowedProp]);
        }
        return acc;
    }, []);
    if (disallowed.length > 0) {
        return new Error([
            "Prop `" + propName + "` in `" + componentName + "` conflicts with props: `" + disallowed.join('`, `') + "`.",
            'They cannot be defined together, choose one or the other.',
        ].join(' '));
    }
    return undefined;
}; };
exports.disallow = disallow;
/**
 * Ensure a prop adherers to multiple prop type validators.
 * @param validators - An array of propType functions.
 */
var every = function (validators) { return function (props, propName, componentName) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    if (!Array.isArray(validators)) {
        throw new Error([
            'Invalid argument supplied to every, expected an instance of array.',
            "See `" + propName + "` prop in `" + componentName + "`.",
        ].join(' '));
    }
    return _.first(_.compact(_.map(validators, function (validator) {
        if (typeof validator !== 'function') {
            throw new Error("every() argument \"validators\" should contain functions, found: " + typeOf(validator) + ".");
        }
        return validator.apply(void 0, __spreadArray([props, propName, componentName], args));
    }))); // we can only return one error at a time
}; };
exports.every = every;
/**
 * Ensure a prop adherers to at least one of the given prop type validators.
 * @param validators - An array of propType functions.
 */
var some = function (validators) { return function (props, propName, componentName) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    if (!Array.isArray(validators)) {
        throw new Error([
            'Invalid argument supplied to some, expected an instance of array.',
            "See `" + propName + "` prop in `" + componentName + "`.",
        ].join(' '));
    }
    var errors = _.compact(_.map(validators, function (validator) {
        if (!_.isFunction(validator)) {
            throw new Error("some() argument \"validators\" should contain functions, found: " + typeOf(validator) + ".");
        }
        return validator.apply(void 0, __spreadArray([props, propName, componentName], args));
    }));
    // fail only if all validators failed
    if (errors.length === validators.length) {
        var error = new Error('One of these validators must pass:');
        error.message += "\n" + _.map(errors, function (err) { return "- " + err.message; }).join('\n');
        return error;
    }
    return undefined;
}; };
exports.some = some;
/**
 * Ensure a validator passes only when a component has a given propsShape.
 * @param propsShape - An object describing the prop shape.
 * @param validator - A propType function.
 */
var givenProps = function (propsShape, validator) { return function (props, propName, componentName) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    if (!_.isPlainObject(propsShape)) {
        throw new Error([
            'Invalid argument supplied to givenProps, expected an object.',
            "See `" + propName + "` prop in `" + componentName + "`.",
        ].join(' '));
    }
    if (typeof validator !== 'function') {
        throw new Error([
            'Invalid argument supplied to givenProps, expected a function.',
            "See `" + propName + "` prop in `" + componentName + "`.",
        ].join(' '));
    }
    var shouldValidate = _.keys(propsShape).every(function (key) {
        var val = propsShape[key];
        // require propShape validators to pass or prop values to match
        return typeof val === 'function' ? !val.apply(void 0, __spreadArray([props, key, componentName], args)) : val === props[propName];
    });
    if (!shouldValidate)
        return undefined;
    var error = validator.apply(void 0, __spreadArray([props, propName, componentName], args));
    if (error) {
        // poor mans shallow pretty print, prevents JSON circular reference errors
        var prettyProps = "{ " + _.keys(_.pick(props, _.keys(propsShape)))
            .map(function (key) {
            var val = props[key];
            var renderedValue = val;
            if (typeof val === 'string')
                renderedValue = "\"" + val + "\"";
            else if (Array.isArray(val))
                renderedValue = "[" + val.join(', ') + "]";
            else if (_.isObject(val))
                renderedValue = '{...}';
            return key + ": " + renderedValue;
        })
            .join(', ') + " }";
        error.message = "Given props " + prettyProps + ": " + error.message;
        return error;
    }
}; };
exports.givenProps = givenProps;
/**
 * Define prop dependencies by requiring other props.
 * @param requiredProps - An array of required prop names.
 */
var demand = function (requiredProps) { return function (props, propName, componentName) {
    if (!Array.isArray(requiredProps)) {
        throw new Error([
            'Invalid `requiredProps` argument supplied to require, expected an instance of array.',
            " See `" + propName + "` prop in `" + componentName + "`.",
        ].join(''));
    }
    // skip if prop is undefined
    if (props[propName] === undefined)
        return undefined;
    var missingRequired = requiredProps.filter(function (requiredProp) { return props[requiredProp] === undefined; });
    if (missingRequired.length > 0) {
        return new Error("`" + propName + "` prop in `" + componentName + "` requires props: `" + missingRequired.join('`, `') + "`.");
    }
    return undefined;
}; };
exports.demand = demand;
/**
 * Ensure an multiple prop contains a string with only possible values.
 * @param possible - An array of possible values to prop.
 */
var multipleProp = function (possible) { return function (props, propName, componentName) {
    if (!Array.isArray(possible)) {
        throw new Error([
            'Invalid argument supplied to some, expected an instance of array.',
            "See `" + propName + "` prop in `" + componentName + "`.",
        ].join(' '));
    }
    var propValue = props[propName];
    // skip if prop is undefined
    if (_.isNil(propValue) || propValue === false)
        return undefined;
    var values = propValue
        .replace('large screen', 'large-screen')
        .replace(/ vertically/g, '-vertically')
        .split(' ')
        .map(function (val) { return _.trim(val).replace('-', ' '); });
    var invalid = _.difference(values, possible);
    // fail only if there are invalid values
    if (invalid.length > 0) {
        return new Error("`" + propName + "` prop in `" + componentName + "` has invalid values: `" + invalid.join('`, `') + "`.");
    }
    return undefined;
}; };
exports.multipleProp = multipleProp;
/**
 * Ensure a component can render as a node passed as a prop value in place of children.
 */
exports.nodeContent = exports.every([exports.disallow(['children']), PropTypes.node]);
exports.wrapperShorthand = PropTypes.oneOfType([
    PropTypes.node,
    PropTypes.object,
    PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.node, PropTypes.object])),
]);
/**
 * A shorthand prop which can be used together with `children`.
 */
exports.shorthandAllowingChildren = PropTypes.oneOfType([PropTypes.node, PropTypes.object, PropTypes.func]);
exports.shorthandObjectAllowingChildren = PropTypes.oneOfType([PropTypes.object, PropTypes.func]);
/**
 * ObjectItemShorthand is a description of a component that can be
 * a props object or a render function.
 */
exports.objectItemShorthand = exports.every([exports.disallow(['children']), exports.shorthandAllowingChildren]);
/**
 * Item shorthand is a description of a component that can be a literal,
 * a props object, an element or a render function.
 */
exports.itemShorthand = exports.every([exports.disallow(['children']), exports.shorthandAllowingChildren]);
var itemShorthandWithKindProp = function (kindPropValues) {
    return exports.every([
        exports.disallow(['children']),
        PropTypes.oneOfType([
            PropTypes.node,
            PropTypes.shape({
                kind: PropTypes.oneOf(kindPropValues),
            }),
            PropTypes.func,
        ]),
    ]);
};
exports.itemShorthandWithKindProp = itemShorthandWithKindProp;
exports.itemShorthandWithoutJSX = exports.every([
    exports.disallow(['children']),
    PropTypes.oneOfType([PropTypes.func, PropTypes.number, PropTypes.object, PropTypes.string, PropTypes.oneOf([false])]),
]);
/**
 * Collection shorthand ensures a prop is an array of item shorthand.
 */
exports.collectionObjectShorthand = exports.every([exports.disallow(['children']), PropTypes.arrayOf(exports.objectItemShorthand)]);
/**
 * Collection shorthand ensures a prop is an array of item shorthand.
 */
exports.collectionShorthand = exports.every([exports.disallow(['children']), PropTypes.arrayOf(exports.itemShorthand)]);
var collectionShorthandWithKindProp = function (kindPropValues) {
    return exports.every([exports.disallow(['children']), PropTypes.arrayOf(exports.itemShorthandWithKindProp(kindPropValues))]);
};
exports.collectionShorthandWithKindProp = collectionShorthandWithKindProp;
/**
 * Show a deprecated warning for component props with a help message and optional validator.
 * @param help - A help message to display with the deprecation warning.
 * @param validator - A propType function.
 */
var deprecate = function (help, validator) { return function (props, propName, componentName) {
    var args = [];
    for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
    }
    if (typeof help !== 'string') {
        throw new Error([
            'Invalid `help` argument supplied to deprecate, expected a string.',
            "See `" + propName + "` prop in `" + componentName + "`.",
        ].join(' '));
    }
    // skip if prop is undefined
    if (props[propName] === undefined)
        return undefined;
    // deprecation error and help
    var error = new Error("The `" + propName + "` prop in `" + componentName + "` is deprecated.");
    if (help)
        error.message += " " + help;
    // add optional validation error message
    if (validator) {
        if (typeof validator === 'function') {
            var validationError = validator.apply(void 0, __spreadArray([props, propName, componentName], args));
            if (validationError) {
                error.message = error.message + " " + validationError.message;
            }
        }
        else {
            throw new Error([
                'Invalid argument supplied to deprecate, expected a function.',
                "See `" + propName + "` prop in `" + componentName + "`.",
            ].join(' '));
        }
    }
    return error;
}; };
exports.deprecate = deprecate;
exports.accessibility = PropTypes.func;
exports.size = PropTypes.oneOf([
    'smallest',
    'smaller',
    'small',
    'medium',
    'large',
    'larger',
    'largest',
]);
exports.align = PropTypes.oneOf(['start', 'end', 'center', 'justify']);
exports.animation = PropTypes.oneOfType([
    // Validator is broken in the latest @react/types
    PropTypes.shape({
        name: PropTypes.string.isRequired,
        delay: PropTypes.string,
        direction: PropTypes.string,
        duration: PropTypes.string,
        fillMode: PropTypes.string,
        iterationCount: PropTypes.string,
        playState: PropTypes.string,
        timingFunction: PropTypes.string,
    }),
    PropTypes.string,
]);
// Heads Up!
// Keep in sync with packages/react/src/themes/types.ts
exports.design = PropTypes.shape({
    position: PropTypes.string,
    display: PropTypes.string,
    top: PropTypes.string,
    right: PropTypes.string,
    bottom: PropTypes.string,
    left: PropTypes.string,
    padding: PropTypes.string,
    paddingTop: PropTypes.string,
    paddingRight: PropTypes.string,
    paddingBottom: PropTypes.string,
    paddingLeft: PropTypes.string,
    margin: PropTypes.string,
    marginTop: PropTypes.string,
    marginRight: PropTypes.string,
    marginBottom: PropTypes.string,
    marginLeft: PropTypes.string,
    width: PropTypes.string,
    height: PropTypes.string,
    minWidth: PropTypes.string,
    maxWidth: PropTypes.string,
    minHeight: PropTypes.string,
    maxHeight: PropTypes.string,
});
/** A checker that matches the React.Ref type. */
exports.ref = PropTypes.oneOfType([PropTypes.func, PropTypes.object]);
