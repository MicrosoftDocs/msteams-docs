import * as React from 'react';
import * as PropTypes from 'prop-types';
import { FocusZoneProps, IFocusZone } from './FocusZone.types';
interface Point {
    left: number;
    top: number;
}
export declare class FocusZone extends React.Component<FocusZoneProps> implements IFocusZone {
    static propTypes: {
        className: PropTypes.Requireable<string>;
        direction: PropTypes.Requireable<number>;
        defaultTabbableElement: PropTypes.Requireable<(...args: any[]) => any>;
        shouldFocusOnMount: PropTypes.Requireable<boolean>;
        shouldResetActiveElementWhenTabFromZone: PropTypes.Requireable<boolean>;
        shouldRaiseClicks: PropTypes.Requireable<boolean>;
        shouldFocusInnerElementWhenReceivedFocus: PropTypes.Requireable<boolean>;
        disabled: PropTypes.Requireable<boolean>;
        as: PropTypes.Requireable<React.ElementType<any>>;
        isCircularNavigation: PropTypes.Requireable<boolean>;
        shouldEnterInnerZone: PropTypes.Requireable<(...args: any[]) => any>;
        onActiveElementChanged: PropTypes.Requireable<(...args: any[]) => any>;
        shouldReceiveFocus: PropTypes.Requireable<(...args: any[]) => any>;
        handleTabKey: PropTypes.Requireable<number>;
        shouldInputLoseFocusOnArrowKey: PropTypes.Requireable<(...args: any[]) => any>;
        stopFocusPropagation: PropTypes.Requireable<boolean>;
        onFocus: PropTypes.Requireable<(...args: any[]) => any>;
        preventDefaultWhenHandled: PropTypes.Requireable<boolean>;
        isRtl: PropTypes.Requireable<boolean>;
        preventFocusRestoration: PropTypes.Requireable<boolean>;
        pagingSupportDisabled: PropTypes.Requireable<boolean>;
        shouldIgnoreNotFocusable: PropTypes.Requireable<boolean>;
        innerRef: PropTypes.Requireable<any>;
    };
    static defaultProps: FocusZoneProps;
    static displayName: string;
    static className: string;
    static outerZones: {
        _windowToOuterZoneMap: Map<Window, Set<FocusZone>>;
        register(window: Window, FZ: FocusZone): number | undefined;
        unregister(window: Window, FZ: FocusZone): void;
        getOutZone(window: Window): Set<FocusZone> | undefined;
    };
    _root: {
        current: HTMLElement | null;
    };
    _id: string;
    /** The most recently focused child element. */
    _activeElement: HTMLElement | null;
    /**
     * The index path to the last focused child element.
     */
    _lastIndexPath: number[] | undefined;
    /**
     * Flag to define when we've intentionally parked focus on the root element to temporarily
     * hold focus until items appear within the zone.
     */
    _isParked: boolean;
    _parkedTabIndex: string | null | undefined;
    /** The child element with tabindex=0. */
    _defaultFocusElement: HTMLElement | null;
    _focusAlignment: Point;
    _isInnerZone: boolean;
    /** Used to allow us to move to next focusable element even when we're focusing on a input element when pressing tab */
    _processingTabKey: boolean;
    windowElement: Window | null;
    constructor(props: FocusZoneProps);
    componentDidMount(): void;
    componentDidUpdate(): void;
    componentWillUnmount(): void;
    render(): JSX.Element;
    /**
     * Sets focus to the first tabbable item in the zone.
     * @param forceIntoFirstElement - If true, focus will be forced into the first element, even if focus is already in the focus zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focus(forceIntoFirstElement?: boolean): boolean;
    /**
     * Sets focus to the last tabbable item in the zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focusLast(): boolean;
    /**
     * Sets focus to a specific child element within the zone. This can be used in conjunction with
     * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct
     * location and then focus.)
     * @param element - The child element within the zone to focus.
     * @param forceAlignment - If true, focus alignment will be set according to the element provided.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    focusElement(element: HTMLElement, forceAlignment?: boolean): boolean;
    setRef: (elem: HTMLElement) => void;
    evaluateFocusBeforeRender(): void;
    /**
     * When focus is in the zone at render time but then all focusable elements are removed,
     * we "park" focus temporarily on the root. Once we update with focusable children, we restore
     * focus to the closest path from previous. If the user tabs away from the parked container,
     * we restore focusability to the pre-parked state.
     */
    setParkedFocus(isParked: boolean): void;
    _onBlur: () => void;
    _onFocus: (ev: React.FocusEvent<HTMLElement>) => void;
    _onMouseDown: (ev: React.MouseEvent<HTMLElement>) => void;
    setActiveElement(element: HTMLElement, forceAlignment?: boolean): void;
    preventDefaultWhenHandled(ev: React.KeyboardEvent<HTMLElement>): void;
    /**
     * Handle the keystrokes.
     */
    _onKeyDown: (ev: React.KeyboardEvent<HTMLElement>) => boolean | undefined;
    /**
     * Walk up the dom try to find a focusable element.
     */
    tryInvokeClickForFocusable(targetElement: HTMLElement): boolean;
    /**
     * Traverse to find first child zone.
     */
    getFirstInnerZone(forRootElement?: HTMLElement | null): FocusZone | null;
    moveFocus(isForward: boolean, getDistanceFromCenter: (activeRect: ClientRect, targetRect: ClientRect) => number, ev?: Event, useDefaultWrap?: boolean): boolean;
    moveFocusDown(): boolean;
    moveFocusUp(): boolean;
    moveFocusLeft(): boolean;
    moveFocusRight(): boolean;
    getHorizontalDistanceFromCenter: (isForward: boolean, activeRect: ClientRect, targetRect: ClientRect) => number;
    moveFocusPaging(isForward: boolean, useDefaultWrap?: boolean): boolean;
    setFocusAlignment(element: HTMLElement, isHorizontal?: boolean, isVertical?: boolean): void;
    isImmediateDescendantOfZone(element?: HTMLElement): boolean;
    getOwnerZone(element?: HTMLElement): HTMLElement | null;
    updateTabIndexes(onElement?: HTMLElement): void;
    isContentEditableElement(element: HTMLElement): boolean;
    isElementInput(element: HTMLElement): boolean;
    shouldInputLoseFocus(element: HTMLInputElement, isForward?: boolean): boolean;
    shouldWrapFocus(element: HTMLElement, noWrapDataAttribute: 'data-no-vertical-wrap' | 'data-no-horizontal-wrap'): boolean;
    getDocument(): Document;
}
export {};
