"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_bindings_1 = require("@fluentui/react-bindings");
var state_1 = require("@fluentui/state");
var enzyme_1 = require("enzyme");
var React = require("react");
var ReactTestUtils = require("react-dom/test-utils");
var createTestManager = function (config) {
    return state_1.createManager(__assign(__assign({}, config), { actions: {
            change: function (value) { return function () { return ({ value: value }); }; },
            toggle: function () { return function (state) { return ({ open: !state.open }); }; },
        }, state: __assign({ open: false, value: '' }, config.state) }));
};
var TestComponent = function (props) {
    var _a = react_bindings_1.useStateManager(createTestManager, {
        mapPropsToInitialState: function () { return ({
            open: props.defaultOpen,
            value: props.defaultValue,
        }); },
        mapPropsToState: function () { return ({
            open: props.open,
            value: props.value,
        }); },
    }), state = _a.state, actions = _a.actions;
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: "open-" + state.open }),
        React.createElement("input", { onChange: function (e) {
                // Is used in UTs to check that state values is not changed
                if (props.onChange)
                    props.onChange(state.value);
                actions.change(e.target.value);
                if (props.onChange)
                    props.onChange(state.value);
            }, value: state.value }),
        React.createElement("button", { className: props.color, onClick: function () { return actions.toggle(); } })));
};
var ActionsComponent = function (props) {
    var onRender = props.onRender, onUpdate = props.onUpdate;
    var _a = react_bindings_1.useStateManager(createTestManager), actions = _a.actions, state = _a.state;
    var handleClick = React.useCallback(function () { return actions.toggle(); }, [actions]);
    onRender();
    React.useEffect(function () {
        onUpdate();
    }, [actions, onUpdate]);
    return React.createElement("div", { "data-open": state.open, onClick: handleClick });
};
describe('useStateManager', function () {
    it('uses default values from state manager', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        expect(wrapper.find('div').prop('className')).toBe('open-false');
        expect(wrapper.find('input').prop('value')).toBe('');
    });
    it('sets default values of controlled props to the state', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, { defaultOpen: true, defaultValue: "foo" }));
        expect(wrapper.find('div').prop('className')).toBe('open-true');
        expect(wrapper.find('input').prop('value')).toBe('foo');
    });
    it('sets values of controlled props to the state', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, { open: true, value: "foo" }));
        expect(wrapper.find('div').prop('className')).toBe('open-true');
        expect(wrapper.find('input').prop('value')).toBe('foo');
    });
    it('handles state updates via actions', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        ReactTestUtils.act(function () {
            wrapper.find('button').simulate('click');
        });
        ReactTestUtils.act(function () {
            wrapper.find('input').simulate('change', { target: { value: 'foo' } });
        });
        expect(wrapper.find('div').prop('className')).toBe('open-true');
        expect(wrapper.find('input').prop('value')).toBe('foo');
    });
    it('update of non controlled props will not affect the state', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        ReactTestUtils.act(function () {
            wrapper.setProps({ color: 'red' });
        });
        expect(wrapper.find('div').prop('className')).toBe('open-false');
    });
    it('sets values of controlled props to the state on updates', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        ReactTestUtils.act(function () {
            wrapper.setProps({ open: false });
        });
        expect(wrapper.find('div').prop('className')).toBe('open-false');
        ReactTestUtils.act(function () {
            wrapper.setProps({ open: true });
        });
        expect(wrapper.find('div').prop('className')).toBe('open-true');
    });
    it('keeps last value of controlled prop in the state if value gets "undefined"', function () {
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, null));
        ReactTestUtils.act(function () {
            wrapper.setProps({ open: true });
        });
        expect(wrapper.find('div').prop('className')).toBe('open-true');
        ReactTestUtils.act(function () {
            wrapper.setProps({ open: undefined });
        });
        expect(wrapper.find('div').prop('className')).toBe('open-true');
    });
    it('state values are immutable as in React', function () {
        var onChange = jest.fn();
        var wrapper = enzyme_1.shallow(React.createElement(TestComponent, { onChange: onChange, value: "foo" }));
        ReactTestUtils.act(function () {
            wrapper.find('input').simulate('change', { target: { value: 'baz' } });
        });
        expect(onChange).toHaveBeenCalledTimes(2);
        expect(onChange).toHaveBeenNthCalledWith(1, 'foo');
        expect(onChange).toHaveBeenNthCalledWith(2, 'foo');
    });
    it('actions are referentially equal between renders', function () {
        var onRender = jest.fn();
        var onUpdate = jest.fn();
        var wrapper = enzyme_1.mount(React.createElement(ActionsComponent, { onRender: onRender, onUpdate: onUpdate }));
        expect(wrapper.find('div').prop('data-open')).toBe(false);
        ReactTestUtils.act(function () {
            wrapper.find('div').simulate('click');
        });
        wrapper.update();
        expect(wrapper.find('div').prop('data-open')).toBe(true);
        expect(onRender).toHaveBeenCalledTimes(2);
        expect(onUpdate).toHaveBeenCalledTimes(1);
        ReactTestUtils.act(function () {
            wrapper.find('div').simulate('click');
        });
        wrapper.update();
        expect(wrapper.find('div').prop('data-open')).toBe(false);
        expect(onRender).toHaveBeenCalledTimes(3);
        expect(onUpdate).toHaveBeenCalledTimes(1);
    });
});
