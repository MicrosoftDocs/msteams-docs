"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FocusTrapZone = void 0;
var react_component_event_listener_1 = require("@fluentui/react-component-event-listener");
var React = require("react");
var ReactDOM = require("react-dom");
var PropTypes = require("prop-types");
var _ = require("lodash");
var getElementType_1 = require("../utils/getElementType");
var getUnhandledProps_1 = require("../utils/getUnhandledProps");
var focusUtilities_1 = require("./focusUtilities");
var react_component_ref_1 = require("@fluentui/react-component-ref");
/** FocusTrapZone is used to trap the focus in any html element placed in body
 *  and hide other elements outside of Focus Trap Zone from accessibility tree.
 *  Pressing tab will circle focus within the inner focusable elements of the FocusTrapZone. */
var FocusTrapZone = /** @class */ (function (_super) {
    __extends(FocusTrapZone, _super);
    function FocusTrapZone() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._root = { current: null };
        _this._firstBumper = React.createRef();
        _this._lastBumper = React.createRef();
        _this._hasFocus = false;
        _this.windowRef = React.createRef();
        // @ts-ignore
        _this.createRef = function (elem) {
            _this._root.current = ReactDOM.findDOMNode(elem);
            // @ts-ignore
            _this.windowRef.current = focusUtilities_1.getWindow(_this._root.current);
        };
        _this.shouldHandleOutsideClick = function () { return !_this.props.isClickableOutsideFocusTrap || !_this.props.focusTriggerOnOutsideClick; };
        _this._onRootFocus = function (ev) {
            if (_this.props.onFocus) {
                _this.props.onFocus(ev);
            }
            _this._hasFocus = true;
        };
        _this._onRootBlur = function (ev) {
            if (_this.props.onBlur) {
                _this.props.onBlur(ev);
            }
            var relatedTarget = ev.relatedTarget;
            if (ev.relatedTarget === null) {
                // In IE11, due to lack of support, event.relatedTarget is always
                // null making every onBlur call to be "outside" of the ComboBox
                // even when it's not. Using document.activeElement is another way
                // for us to be able to get what the relatedTarget without relying
                // on the event
                var doc = focusUtilities_1.getDocument(_this._root.current);
                // @ts-ignore
                relatedTarget = doc.activeElement;
            }
            // @ts-ignore
            if (!_this._root.current.contains(relatedTarget)) {
                _this._hasFocus = false;
            }
        };
        _this._onFirstBumperFocus = function () {
            _this._onBumperFocus(true);
        };
        _this._onLastBumperFocus = function () {
            _this._onBumperFocus(false);
        };
        _this._onBumperFocus = function (isFirstBumper) {
            if (!_this._root.current) {
                return;
            }
            var currentBumper = (isFirstBumper === _this._hasFocus
                ? _this._lastBumper.current
                : _this._firstBumper.current);
            var nextFocusable = isFirstBumper === _this._hasFocus
                ? focusUtilities_1.getLastTabbable(_this._root.current, currentBumper, true, false)
                : focusUtilities_1.getFirstTabbable(_this._root.current, currentBumper, true, false);
            if (nextFocusable) {
                if (_this._isBumper(nextFocusable)) {
                    // This can happen when FTZ contains no tabbable elements. Focus will take care of finding a focusable element in FTZ.
                    _this._findElementAndFocusAsync();
                }
                else {
                    nextFocusable.focus();
                }
            }
        };
        _this._enableFocusTrapZone = function () {
            var _a = _this.props.disabled, disabled = _a === void 0 ? false : _a;
            if (disabled) {
                return;
            }
            FocusTrapZone._focusStack.push(_this);
            _this._bringFocusIntoZone();
            _this._hideContentFromAccessibilityTree();
        };
        _this._bringFocusIntoZone = function () {
            var _a = _this.props.disableFirstFocus, disableFirstFocus = _a === void 0 ? false : _a;
            _this._previouslyFocusedElementOutsideTrapZone = _this._getPreviouslyFocusedElementOutsideTrapZone();
            if (
            // @ts-ignore
            !_this._root.current.contains(_this._previouslyFocusedElementOutsideTrapZone) &&
                !disableFirstFocus) {
                _this._findElementAndFocusAsync();
            }
        };
        _this._releaseFocusTrapZone = function () {
            var ignoreExternalFocusing = _this.props.ignoreExternalFocusing;
            FocusTrapZone._focusStack = FocusTrapZone._focusStack.filter(function (value) {
                return _this !== value;
            });
            // try to focus element which triggered FocusTrapZone - prviously focused element outside trap zone
            var doc = focusUtilities_1.getDocument(_this._root.current);
            // @ts-ignore
            var activeElement = doc.activeElement;
            if (!ignoreExternalFocusing &&
                _this._previouslyFocusedElementOutsideTrapZone &&
                // @ts-ignore
                (_this._root.current.contains(activeElement) || activeElement === doc.body)) {
                _this._focusAsync(_this._previouslyFocusedElementOutsideTrapZone);
            }
            // if last active focus trap zone is going to be released - show previously hidden content in accessibility tree
            var lastActiveFocusTrap = FocusTrapZone._focusStack.length && FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1];
            if (!lastActiveFocusTrap) {
                _this._showContentInAccessibilityTree();
            }
            else if (lastActiveFocusTrap._root.current &&
                lastActiveFocusTrap._root.current.hasAttribute(focusUtilities_1.HIDDEN_FROM_ACC_TREE)) {
                lastActiveFocusTrap._root.current.removeAttribute(focusUtilities_1.HIDDEN_FROM_ACC_TREE);
                lastActiveFocusTrap._root.current.removeAttribute('aria-hidden');
            }
        };
        _this._findElementAndFocusAsync = function () {
            if (!_this._root.current) {
                return;
            }
            var _a = _this.props, focusPreviouslyFocusedInnerElement = _a.focusPreviouslyFocusedInnerElement, firstFocusableSelector = _a.firstFocusableSelector;
            if (focusPreviouslyFocusedInnerElement &&
                _this._previouslyFocusedElementInTrapZone &&
                _this._root.current.contains(_this._previouslyFocusedElementInTrapZone)) {
                // focus on the last item that had focus in the zone before we left the zone
                _this._focusAsync(_this._previouslyFocusedElementInTrapZone);
                return;
            }
            var focusSelector = firstFocusableSelector &&
                (typeof firstFocusableSelector === 'string' ? firstFocusableSelector : firstFocusableSelector());
            var firstFocusableChild = null;
            if (focusSelector) {
                firstFocusableChild = _this._root.current.querySelector(focusSelector);
            }
            // Fall back to first element if query selector did not match any elements.
            if (!firstFocusableChild) {
                firstFocusableChild = focusUtilities_1.getNextElement(_this._root.current, _this._root.current.firstChild, false, false, false, true);
            }
            firstFocusableChild && _this._focusAsync(firstFocusableChild);
        };
        _this._onFocusCapture = function (ev) {
            _this.props.onFocusCapture && _this.props.onFocusCapture(ev);
            if (ev.target !== ev.currentTarget && !_this._isBumper(ev.target)) {
                // every time focus changes within the trap zone, remember the focused element so that
                // it can be restored if focus leaves the pane and returns via keystroke (i.e. via a call to this.focus(true))
                _this._previouslyFocusedElementInTrapZone = ev.target;
            }
        };
        _this._forceFocusInTrap = function (ev, triggeredElement) {
            if (FocusTrapZone._focusStack.length && _this === FocusTrapZone._focusStack[FocusTrapZone._focusStack.length - 1]) {
                // @ts-ignore
                if (!_this._root.current.contains(triggeredElement)) {
                    _this._findElementAndFocusAsync();
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
        };
        _this._handleOutsideFocus = function (ev) {
            var doc = focusUtilities_1.getDocument(_this._root.current);
            // @ts-ignore
            var focusedElement = doc.activeElement;
            focusedElement && _this._forceFocusInTrap(ev, focusedElement);
        };
        _this._handleOutsideClick = function (ev) {
            var clickedElement = ev.target;
            var _a = _this.props, isClickableOutsideFocusTrap = _a.isClickableOutsideFocusTrap, focusTriggerOnOutsideClick = _a.focusTriggerOnOutsideClick;
            if (!isClickableOutsideFocusTrap) {
                clickedElement && _this._forceFocusInTrap(ev, clickedElement);
            }
            else if (!focusTriggerOnOutsideClick) {
                var isOutsideFocusTrapZone = _this._root.current && !_this._root.current.contains(clickedElement);
                var isOutsideTriggerElement = _this._previouslyFocusedElementOutsideTrapZone &&
                    !_this._previouslyFocusedElementOutsideTrapZone.contains(clickedElement);
                if (isOutsideFocusTrapZone && isOutsideTriggerElement) {
                    // set it to NULL, so the trigger will not be focused on componentWillUnmount
                    // @ts-ignore
                    _this._previouslyFocusedElementOutsideTrapZone = null;
                }
            }
        };
        _this._onKeyboardHandler = function (ev) {
            if (_this.props.onKeyDown) {
                _this.props.onKeyDown(ev);
            }
            // do not propogate keyboard events outside focus trap zone
            // https://github.com/microsoft/fluent-ui-react/pull/1180
            ev.stopPropagation();
        };
        _this._getPreviouslyFocusedElementOutsideTrapZone = function () {
            var elementToFocusOnDismiss = _this.props.elementToFocusOnDismiss;
            var previouslyFocusedElement = _this._previouslyFocusedElementOutsideTrapZone;
            if (elementToFocusOnDismiss && previouslyFocusedElement !== elementToFocusOnDismiss) {
                previouslyFocusedElement = elementToFocusOnDismiss;
            }
            else if (!previouslyFocusedElement) {
                var doc = focusUtilities_1.getDocument(_this._root.current);
                // @ts-ignore
                previouslyFocusedElement = doc.activeElement;
            }
            return previouslyFocusedElement;
        };
        _this._hideContentFromAccessibilityTree = function () {
            var doc = focusUtilities_1.getDocument(_this._root.current);
            // @ts-ignore
            var bodyChildren = (doc.body && doc.body.children) || [];
            // @ts-ignore
            if (bodyChildren.length && !doc.body.contains(_this._root.current)) {
                // In case popup render options will change
                /* eslint-disable-next-line no-console */
                console.warn('Body element does not contain trap zone element. Please, ensure the trap zone element is placed inside body, so it will work properly.');
            }
            for (var index = 0; index < bodyChildren.length; index++) {
                var currentChild = bodyChildren[index];
                var isOrHasFocusTrapZone = currentChild === _this._root.current || currentChild.contains(_this._root.current);
                var isAriaLiveRegion = currentChild.hasAttribute('aria-live');
                if (!isOrHasFocusTrapZone && !isAriaLiveRegion && currentChild.getAttribute('aria-hidden') !== 'true') {
                    currentChild.setAttribute('aria-hidden', 'true');
                    currentChild.setAttribute(focusUtilities_1.HIDDEN_FROM_ACC_TREE, 'true');
                }
            }
        };
        _this._showContentInAccessibilityTree = function () {
            var doc = focusUtilities_1.getDocument(_this._root.current);
            // @ts-ignore
            var hiddenElements = doc.querySelectorAll("[" + focusUtilities_1.HIDDEN_FROM_ACC_TREE + "=\"true\"]");
            for (var index = 0; index < hiddenElements.length; index++) {
                var element = hiddenElements[index];
                element.removeAttribute('aria-hidden');
                element.removeAttribute(focusUtilities_1.HIDDEN_FROM_ACC_TREE);
            }
        };
        return _this;
    }
    FocusTrapZone.prototype.componentDidMount = function () {
        this._enableFocusTrapZone();
    };
    FocusTrapZone.prototype.componentDidUpdate = function (prevProps) {
        var _a = this.props, forceFocusInsideTrapOnComponentUpdate = _a.forceFocusInsideTrapOnComponentUpdate, forceFocusInsideTrapOnOutsideFocus = _a.forceFocusInsideTrapOnOutsideFocus, disabled = _a.disabled;
        var doc = focusUtilities_1.getDocument(this._root.current);
        // @ts-ignore
        var activeElement = doc.activeElement;
        // if after componentDidUpdate focus is not inside the focus trap, bring it back
        if (!disabled &&
            // @ts-ignore
            !this._root.current.contains(activeElement) &&
            forceFocusInsideTrapOnComponentUpdate) {
            this._bringFocusIntoZone();
            return;
        }
        var prevForceFocusInsideTrap = prevProps.forceFocusInsideTrapOnOutsideFocus !== undefined ? prevProps.forceFocusInsideTrapOnOutsideFocus : true;
        var newForceFocusInsideTrap = forceFocusInsideTrapOnOutsideFocus !== undefined ? forceFocusInsideTrapOnOutsideFocus : true;
        var prevDisabled = prevProps.disabled !== undefined ? prevProps.disabled : false;
        var newDisabled = disabled !== undefined ? disabled : false;
        if ((!prevForceFocusInsideTrap && newForceFocusInsideTrap) || (prevDisabled && !newDisabled)) {
            // Transition from forceFocusInsideTrap / FTZ disabled to enabled.
            // Emulate what happens when a FocusTrapZone gets mounted.
            this._enableFocusTrapZone();
        }
        else if ((prevForceFocusInsideTrap && !newForceFocusInsideTrap) || (!prevDisabled && newDisabled)) {
            // Transition from forceFocusInsideTrap / FTZ enabled to disabled.
            // Emulate what happens when a FocusTrapZone gets unmounted.
            this._releaseFocusTrapZone();
        }
    };
    FocusTrapZone.prototype.componentWillUnmount = function () {
        // don't handle return focus unless forceFocusInsideTrapOnOutsideFocus is true or focus is still within FocusTrapZone
        var doc = focusUtilities_1.getDocument(this._root.current);
        if (!this.props.disabled ||
            this.props.forceFocusInsideTrapOnOutsideFocus ||
            // @ts-ignore
            !this._root.current.contains(doc.activeElement)) {
            this._releaseFocusTrapZone();
        }
        // Dispose of element references so the DOM Nodes can be garbage-collected
        delete this._previouslyFocusedElementInTrapZone;
        delete this._previouslyFocusedElementOutsideTrapZone;
    };
    FocusTrapZone.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, forceFocusInsideTrapOnOutsideFocus = _a.forceFocusInsideTrapOnOutsideFocus, ariaLabelledBy = _a.ariaLabelledBy, _b = _a.disabled, disabled = _b === void 0 ? false : _b;
        var unhandledProps = getUnhandledProps_1.getUnhandledProps(_.keys(FocusTrapZone.propTypes), this.props);
        var ElementType = getElementType_1.getElementType(this.props);
        var bumperProps = {
            'aria-hidden': true,
            style: {
                pointerEvents: 'none',
                position: 'fixed', // 'fixed' prevents browsers from scrolling to bumpers when viewport does not contain them
            },
            tabIndex: disabled ? -1 : 0,
            'data-is-visible': true,
        };
        return (React.createElement(React.Fragment, null,
            React.createElement(ElementType, __assign({}, unhandledProps, { className: className, ref: function (element) {
                    _this.createRef(element);
                    react_component_ref_1.handleRef(_this.props.innerRef, element);
                }, "aria-labelledby": ariaLabelledBy, onKeyDown: this._onKeyboardHandler, onFocusCapture: this._onFocusCapture, onFocus: this._onRootFocus, onBlur: this._onRootBlur }),
                React.createElement("div", __assign({}, bumperProps, { ref: this._firstBumper, onFocus: this._onFirstBumperFocus })),
                this.props.children,
                React.createElement("div", __assign({}, bumperProps, { ref: this._lastBumper, onFocus: this._onLastBumperFocus }))),
            forceFocusInsideTrapOnOutsideFocus && (React.createElement(react_component_event_listener_1.EventListener, { capture: true, listener: this._handleOutsideFocus, targetRef: this.windowRef, type: "focus" })),
            this.shouldHandleOutsideClick() && (React.createElement(react_component_event_listener_1.EventListener, { capture: true, listener: this._handleOutsideClick, targetRef: this.windowRef, type: "click" }))));
    };
    FocusTrapZone.prototype._isBumper = function (element) {
        return element === this._firstBumper.current || element === this._lastBumper.current;
    };
    FocusTrapZone.prototype._focusAsync = function (element) {
        if (!this._isBumper(element)) {
            focusUtilities_1.focusAsync(element);
        }
    };
    FocusTrapZone._focusStack = [];
    FocusTrapZone.propTypes = {
        as: PropTypes.elementType,
        className: PropTypes.string,
        elementToFocusOnDismiss: PropTypes.object,
        ariaLabelledBy: PropTypes.string,
        isClickableOutsideFocusTrap: PropTypes.bool,
        ignoreExternalFocusing: PropTypes.bool,
        forceFocusInsideTrapOnOutsideFocus: PropTypes.bool,
        forceFocusInsideTrapOnComponentUpdate: PropTypes.bool,
        firstFocusableSelector: PropTypes.string,
        disableFirstFocus: PropTypes.bool,
        focusPreviouslyFocusedInnerElement: PropTypes.bool,
        focusTriggerOnOutsideClick: PropTypes.bool,
        innerRef: PropTypes.any,
    };
    FocusTrapZone.defaultProps = {
        as: 'div',
        isClickableOutsideFocusTrap: true,
        forceFocusInsideTrapOnOutsideFocus: false,
    };
    return FocusTrapZone;
}(React.Component));
exports.FocusTrapZone = FocusTrapZone;
