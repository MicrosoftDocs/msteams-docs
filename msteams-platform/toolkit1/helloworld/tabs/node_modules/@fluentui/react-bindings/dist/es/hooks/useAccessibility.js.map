{"version":3,"sources":["hooks/useAccessibility.ts"],"names":["React","getAccessibility","FocusZone","useIsomorphicLayoutEffect","useAccessibility","behavior","options","actionHandlers","debugName","mapPropsToBehavior","rtl","definition","latestDefinition","useRef","slotHandlers","slotProps","current","getA11yProps","slotName","userProps","hasKeyDownHandlers","Boolean","keyHandlers","onKeyDown","childBehavior","childBehaviors","undefined","e","accessibilityHandler","userHandler","args","finalProps","accessibility","attributes","unstable_wrapWithFocusZone","element","focusZone","child","process","env","NODE_ENV","Children","only","createElement","props","innerRef","ref","as","type","isRtl","unstable_behaviorDefinition"],"mappings":"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","sourcesContent":["import { Accessibility, AccessibilityAttributesBySlot } from '@fluentui/accessibility';\nimport * as React from 'react';\n\nimport { getAccessibility } from '../accessibility/getAccessibility';\nimport { AccessibilityActionHandlers, KeyboardEventHandler, ReactAccessibilityBehavior } from '../accessibility/types';\nimport { FocusZone } from '../FocusZone/FocusZone';\nimport { useIsomorphicLayoutEffect } from './useIsomorphicLayoutEffect';\n\ntype UseAccessibilityOptions<Props> = {\n  actionHandlers?: AccessibilityActionHandlers;\n  debugName?: string;\n  mapPropsToBehavior?: () => Props;\n  rtl?: boolean;\n};\n\ntype UseAccessibilityResult = (<SlotProps extends Record<string, any> & UserProps>(\n  slotName: string,\n  slotProps: SlotProps,\n) => MergedProps<SlotProps>) & {\n  unstable_wrapWithFocusZone: (children: React.ReactElement) => React.ReactElement;\n  unstable_behaviorDefinition: () => ReactAccessibilityBehavior;\n};\n\ntype UserProps = {\n  onKeyDown?: KeyboardEventHandler;\n};\n\ntype MergedProps<SlotProps extends Record<string, any> = any> = SlotProps &\n  Partial<AccessibilityAttributesBySlot> &\n  UserProps;\n\nexport const useAccessibility = <Props>(\n  behavior: Accessibility<Props>,\n  options: UseAccessibilityOptions<Props> = {},\n) => {\n  const { actionHandlers, debugName = 'Undefined', mapPropsToBehavior = () => ({}), rtl = false } = options;\n\n  const definition = getAccessibility(debugName, behavior, mapPropsToBehavior(), rtl, actionHandlers);\n\n  const latestDefinition = React.useRef<ReactAccessibilityBehavior>();\n  const slotHandlers = React.useRef<Record<string, KeyboardEventHandler>>({});\n  const slotProps = React.useRef<Record<string, UserProps>>({});\n\n  useIsomorphicLayoutEffect(() => {\n    latestDefinition.current = definition;\n  });\n\n  const getA11yProps: UseAccessibilityResult = (slotName, userProps) => {\n    const hasKeyDownHandlers = Boolean(definition.keyHandlers[slotName] || userProps.onKeyDown);\n    const childBehavior = definition.childBehaviors ? definition.childBehaviors[slotName] : undefined;\n    slotProps.current[slotName] = userProps;\n\n    // We want to avoid adding event handlers until it's really needed\n    if (hasKeyDownHandlers) {\n      if (!slotHandlers.current[slotName]) {\n        slotHandlers.current[slotName] = (e, ...args) => {\n          const accessibilityHandler = latestDefinition.current?.keyHandlers[slotName]?.onKeyDown;\n          const userHandler = slotProps.current[slotName].onKeyDown;\n\n          if (accessibilityHandler) accessibilityHandler(e);\n          if (userHandler) userHandler(e, ...args);\n        };\n      }\n    } else {\n      delete slotHandlers.current[slotName];\n    }\n\n    const finalProps: MergedProps = {\n      ...(childBehavior && { accessibility: childBehavior }),\n      ...definition.attributes[slotName],\n      ...userProps,\n      onKeyDown: slotHandlers.current[slotName],\n    };\n\n    return finalProps;\n  };\n\n  // Provides an experimental handling for FocusZone definition in behaviors\n  getA11yProps.unstable_wrapWithFocusZone = (element: React.ReactElement & React.RefAttributes<any>) => {\n    if (definition.focusZone) {\n      let child: React.ReactElement & React.RefAttributes<any> = element;\n\n      if (process.env.NODE_ENV !== 'production') {\n        child = React.Children.only(element);\n      }\n\n      return React.createElement(FocusZone, {\n        ...definition.focusZone.props,\n        ...child.props,\n        innerRef: child.ref,\n        as: child.type,\n        isRtl: rtl,\n      });\n    }\n\n    return element;\n  };\n\n  getA11yProps.unstable_behaviorDefinition = () => definition;\n\n  return getA11yProps;\n};\n"],"file":"useAccessibility.js"}