"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAccessibility = void 0;
var React = require("react");
var getAccessibility_1 = require("../accessibility/getAccessibility");
var FocusZone_1 = require("../FocusZone/FocusZone");
var useIsomorphicLayoutEffect_1 = require("./useIsomorphicLayoutEffect");
var useAccessibility = function (behavior, options) {
    if (options === void 0) { options = {}; }
    var actionHandlers = options.actionHandlers, _a = options.debugName, debugName = _a === void 0 ? 'Undefined' : _a, _b = options.mapPropsToBehavior, mapPropsToBehavior = _b === void 0 ? function () { return ({}); } : _b, _c = options.rtl, rtl = _c === void 0 ? false : _c;
    var definition = getAccessibility_1.getAccessibility(debugName, behavior, mapPropsToBehavior(), rtl, actionHandlers);
    var latestDefinition = React.useRef();
    var slotHandlers = React.useRef({});
    var slotProps = React.useRef({});
    useIsomorphicLayoutEffect_1.useIsomorphicLayoutEffect(function () {
        latestDefinition.current = definition;
    });
    var getA11yProps = function (slotName, userProps) {
        var hasKeyDownHandlers = Boolean(definition.keyHandlers[slotName] || userProps.onKeyDown);
        var childBehavior = definition.childBehaviors ? definition.childBehaviors[slotName] : undefined;
        slotProps.current[slotName] = userProps;
        // We want to avoid adding event handlers until it's really needed
        if (hasKeyDownHandlers) {
            if (!slotHandlers.current[slotName]) {
                slotHandlers.current[slotName] = function (e) {
                    var _a, _b;
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    var accessibilityHandler = (_b = (_a = latestDefinition.current) === null || _a === void 0 ? void 0 : _a.keyHandlers[slotName]) === null || _b === void 0 ? void 0 : _b.onKeyDown;
                    var userHandler = slotProps.current[slotName].onKeyDown;
                    if (accessibilityHandler)
                        accessibilityHandler(e);
                    if (userHandler)
                        userHandler.apply(void 0, __spreadArray([e], args));
                };
            }
        }
        else {
            delete slotHandlers.current[slotName];
        }
        var finalProps = __assign(__assign(__assign(__assign({}, (childBehavior && { accessibility: childBehavior })), definition.attributes[slotName]), userProps), { onKeyDown: slotHandlers.current[slotName] });
        return finalProps;
    };
    // Provides an experimental handling for FocusZone definition in behaviors
    getA11yProps.unstable_wrapWithFocusZone = function (element) {
        if (definition.focusZone) {
            var child = element;
            if (process.env.NODE_ENV !== 'production') {
                child = React.Children.only(element);
            }
            return React.createElement(FocusZone_1.FocusZone, __assign(__assign(__assign({}, definition.focusZone.props), child.props), { innerRef: child.ref, as: child.type, isRtl: rtl }));
        }
        return element;
    };
    getA11yProps.unstable_behaviorDefinition = function () { return definition; };
    return getA11yProps;
};
exports.useAccessibility = useAccessibility;
