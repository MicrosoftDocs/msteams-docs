"use strict";

exports.__esModule = true;
exports.useStateManager = void 0;

var React = _interopRequireWildcard(require("react"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var getDefinedProps = function getDefinedProps(props) {
  var definedProps = {};
  Object.keys(props).forEach(function (propName) {
    if (props[propName] !== undefined) {
      definedProps[propName] = props[propName];
    }
  });
  return definedProps;
};

var useStateManager = function useStateManager(managerFactory, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$mapPropsToIn = _options.mapPropsToInitialState,
      mapPropsToInitialState = _options$mapPropsToIn === void 0 ? function () {
    return {};
  } : _options$mapPropsToIn,
      _options$mapPropsToSt = _options.mapPropsToState,
      mapPropsToState = _options$mapPropsToSt === void 0 ? function () {
    return {};
  } : _options$mapPropsToSt,
      _options$sideEffects = _options.sideEffects,
      sideEffects = _options$sideEffects === void 0 ? [] : _options$sideEffects;
  var latestActions = React.useMemo(function () {
    return {};
  }, // The change of `managerFactory` should trigger recreation of `latestActions` as they can be different between
  // managers
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [managerFactory]);
  var latestManager = React.useRef(null); // Heads up! forceUpdate() is used only for triggering rerenders, stateManager is SSOT

  var _ref = React.useReducer(function (c) {
    return c + 1;
  }, 0),
      forceUpdate = _ref[1]; // If manager exists, the current state will be used


  var initialState = latestManager.current ? latestManager.current.state : getDefinedProps(mapPropsToInitialState());
  latestManager.current = managerFactory({
    // Factory has already configured actions
    actions: {},
    state: Object.assign({}, initialState, getDefinedProps(mapPropsToState())),
    sideEffects: [].concat(sideEffects, [// `sideEffect` is called with two arguments, but hooks don't support the second callback
    // argument
    function () {
      return forceUpdate();
    }])
  }); // We need to keep the same reference to an object with actions to allow usage them as
  // a dependency in useCallback() hook

  Object.assign(latestActions, latestManager.current.actions); // For development environments we disallow ability to extend object with other properties to
  // avoid misusage

  if (process.env.NODE_ENV !== 'production') {
    if (Object.isExtensible(latestActions)) Object.preventExtensions(latestActions);
  } // We need to pass exactly `manager.state` to provide the same state object during the same render
  // frame.
  // It keeps behavior consistency between React state tools and our managers
  // https://github.com/facebook/react/issues/11527#issuecomment-360199710
  // Object.freeze() is used only in dev-mode to avoid usage mistakes


  return {
    state: process.env.NODE_ENV === 'production' ? latestManager.current.state : Object.freeze(latestManager.current.state),
    actions: latestActions
  };
};

exports.useStateManager = useStateManager;
//# sourceMappingURL=useStateManager.js.map
