"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveStyles = void 0;
var styles_1 = require("@fluentui/styles");
var classnames_1 = require("classnames");
var _ = require("lodash");
// this weak map is used as cache for the classes
var classesCache = new WeakMap();
// this weak map is used as cache for the styles
var stylesCache = new WeakMap();
/**
 * Both resolvedStyles and classes are objects of getters with lazy evaluation
 *
 * Additionally if the cacheEnabled option is provided, than the resolved styles
 * and classes are caching the results in WeakMaps. The key of the maps contains the following:
 * - theme
 * - displayName
 * - slot name
 * - styling props
 * - rtl mode
 * - disable animations mode
 */
var resolveStyles = function (options, resolvedVariables) {
    var allDisplayNames = options.allDisplayNames, componentClassName = options.className, theme = options.theme, primaryDisplayName = options.primaryDisplayName, componentProps = options.componentProps, inlineStylesProps = options.inlineStylesProps, rtl = options.rtl, disableAnimations = options.disableAnimations, renderer = options.renderer, performanceFlags = options.performance, telemetry = options.telemetry;
    var className = inlineStylesProps.className, design = inlineStylesProps.design, styles = inlineStylesProps.styles, variables = inlineStylesProps.variables;
    var noInlineStylesOverrides = !(design || styles);
    var noVariableOverrides = performanceFlags.enableBooleanVariablesCaching || !variables;
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
        if (!performanceFlags.enableStylesCaching && performanceFlags.enableBooleanVariablesCaching) {
            throw new Error('@fluentui/react-northstar: Please check your "performance" settings on "Provider", to enable "enableBooleanVariablesCaching" you need to enable "enableStylesCaching"');
        }
    }
    if (performanceFlags.enableBooleanVariablesCaching) {
        if (_.isPlainObject(variables)) {
            var hasOnlyBooleanVariables = Object.keys(variables).every(function (variableName) {
                return variables[variableName] === null ||
                    typeof variables[variableName] === 'undefined' ||
                    typeof variables[variableName] === 'boolean';
            });
            if (!hasOnlyBooleanVariables) {
                noVariableOverrides = false;
            }
        }
        else if (!_.isNil(variables)) {
            noVariableOverrides = false;
        }
    }
    var cacheEnabled = performanceFlags.enableStylesCaching && noInlineStylesOverrides && noVariableOverrides;
    // Merge theme styles with inline overrides if any
    var mergedStyles;
    if (allDisplayNames.length === 1) {
        mergedStyles = theme.componentStyles[allDisplayNames[0]] || { root: function () { return ({}); } };
    }
    else {
        var styles_2 = allDisplayNames.map(function (displayName) { return theme.componentStyles[displayName]; }).filter(Boolean);
        if (styles_2.length > 0) {
            mergedStyles = styles_2.reduce(function (acc, styles) {
                return styles_1.mergeComponentStyles(acc, styles);
            }, {});
        }
        else {
            mergedStyles = { root: function () { return ({}); } };
        }
    }
    if (!noInlineStylesOverrides) {
        mergedStyles = styles_1.mergeComponentStyles(mergedStyles, styles_1.mergeComponentStyles(design && styles_1.withDebugId({ root: design }, 'props.design'), styles && styles_1.withDebugId({ root: styles }, 'props.styles')));
    }
    var styleParam = {
        props: componentProps,
        variables: resolvedVariables,
        theme: theme,
        rtl: rtl,
        disableAnimations: disableAnimations,
    };
    // Heads Up! Keep in sync with Design.tsx render logic
    var rendererParam = {
        direction: rtl ? 'rtl' : 'ltr',
        disableAnimations: disableAnimations,
        displayName: allDisplayNames.join(':'),
        sanitizeCss: performanceFlags.enableSanitizeCssPlugin,
    };
    var resolvedStylesDebug = {};
    if (cacheEnabled && theme) {
        if (!stylesCache.has(theme)) {
            stylesCache.set(theme, {});
        }
        if (!classesCache.has(theme)) {
            classesCache.set(theme, {});
        }
    }
    var propsCacheKey = cacheEnabled ? JSON.stringify(componentProps) : '';
    var variablesCacheKey = cacheEnabled && performanceFlags.enableBooleanVariablesCaching ? JSON.stringify(variables) : '';
    var componentCacheKey = cacheEnabled
        ? allDisplayNames.join(':') + ":" + propsCacheKey + ":" + variablesCacheKey + ":" + styleParam.rtl + styleParam.disableAnimations
        : '';
    if (typeof Proxy === 'undefined') {
        //
        //
        // IE11 branch of code, feel free to remove later.
        // Keep it sync with another branch below!
        //
        //
        var resolvedStyles_1 = {};
        var classes_1 = {};
        Object.keys(mergedStyles).forEach(function (slotName) {
            // resolve/render slot styles once and cache
            var lazyEvaluationKey = slotName + "__return";
            var slotCacheKey = componentCacheKey + slotName;
            Object.defineProperty(resolvedStyles_1, slotName, {
                enumerable: false,
                configurable: false,
                set: function (val) {
                    var _a;
                    // Add to the cache if it's enabled
                    if (cacheEnabled && theme) {
                        stylesCache.set(theme, __assign(__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = val, _a)));
                    }
                    resolvedStyles_1[lazyEvaluationKey] = val;
                },
                get: function () {
                    var _a;
                    var _b, _c;
                    // If caching enabled and entry exists, get from cache, avoid lazy evaluation
                    if (cacheEnabled && theme) {
                        var stylesThemeCache = stylesCache.get(theme) || {};
                        if (stylesThemeCache[slotCacheKey]) {
                            return stylesThemeCache[slotCacheKey];
                        }
                    }
                    if (resolvedStyles_1[lazyEvaluationKey]) {
                        return resolvedStyles_1[lazyEvaluationKey];
                    }
                    var telemetryPartStart = (telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) ? performance.now() : 0;
                    // resolve/render slot styles once and cache
                    resolvedStyles_1[lazyEvaluationKey] = mergedStyles[slotName](styleParam);
                    if (cacheEnabled && theme) {
                        stylesCache.set(theme, __assign(__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = resolvedStyles_1[lazyEvaluationKey], _a)));
                    }
                    if (process.env.NODE_ENV !== 'production' && styles_1.isDebugEnabled) {
                        resolvedStylesDebug[slotName] = (_b = resolvedStyles_1[slotName]) === null || _b === void 0 ? void 0 : _b['_debug'];
                        (_c = resolvedStyles_1[slotName]) === null || _c === void 0 ? true : delete _c['_debug'];
                    }
                    if ((telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) && telemetry.performance[primaryDisplayName]) {
                        telemetry.performance[primaryDisplayName].msResolveStylesTotal += performance.now() - telemetryPartStart;
                    }
                    return resolvedStyles_1[lazyEvaluationKey];
                },
            });
            Object.defineProperty(classes_1, slotName, {
                enumerable: false,
                configurable: false,
                set: function (val) {
                    var _a;
                    if (cacheEnabled && theme) {
                        classesCache.set(theme, __assign(__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = val, _a)));
                    }
                    classes_1[lazyEvaluationKey] = val;
                },
                get: function () {
                    var _a;
                    if (cacheEnabled && theme) {
                        var classesThemeCache = classesCache.get(theme) || {};
                        //
                        // Cached styles
                        //
                        if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
                            if (telemetry === null || telemetry === void 0 ? void 0 : telemetry.performance[primaryDisplayName]) {
                                if (slotName === 'root') {
                                    telemetry.performance[primaryDisplayName].stylesRootCacheHits++;
                                }
                                else {
                                    telemetry.performance[primaryDisplayName].stylesSlotsCacheHits++;
                                }
                            }
                            return slotName === 'root'
                                ? classnames_1.default(componentClassName, classesThemeCache[slotCacheKey], className)
                                : classesThemeCache[slotCacheKey];
                        }
                    }
                    //
                    // Lazy eval
                    //
                    if (classes_1[lazyEvaluationKey]) {
                        return slotName === 'root'
                            ? classnames_1.default(componentClassName, classes_1[lazyEvaluationKey], className)
                            : classes_1[lazyEvaluationKey];
                    }
                    // this resolves the getter magic
                    var styleObj = resolvedStyles_1[slotName];
                    var telemetryPartStart = (telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) ? performance.now() : 0;
                    if (styleObj) {
                        classes_1[lazyEvaluationKey] = renderer.renderRule(styleObj, rendererParam);
                        if (cacheEnabled && theme) {
                            classesCache.set(theme, __assign(__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = classes_1[lazyEvaluationKey], _a)));
                        }
                    }
                    var resultClassName = slotName === 'root'
                        ? classnames_1.default(componentClassName, classes_1[lazyEvaluationKey], className)
                        : classes_1[lazyEvaluationKey];
                    if ((telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) && telemetry.performance[primaryDisplayName]) {
                        telemetry.performance[primaryDisplayName].msRenderStylesTotal += performance.now() - telemetryPartStart;
                    }
                    return resultClassName;
                },
            });
        });
        return {
            resolvedStyles: resolvedStyles_1,
            resolvedStylesDebug: resolvedStylesDebug,
            classes: classes_1,
        };
    }
    var resolvedStyles = new Proxy({}, {
        get: function (target, slotName) {
            var _a;
            var _b, _c, _d;
            var slotCacheKey = componentCacheKey + slotName;
            // If caching enabled and entry exists, get from cache, avoid lazy evaluation
            if (cacheEnabled && theme) {
                var stylesThemeCache = stylesCache.get(theme) || {};
                if (stylesThemeCache[slotCacheKey]) {
                    return stylesThemeCache[slotCacheKey];
                }
            }
            if (target[slotName]) {
                return target[slotName];
            }
            var telemetryPartStart = (telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) ? performance.now() : 0;
            // resolve/render slot styles once and cache
            target[slotName] = (_b = mergedStyles[slotName]) === null || _b === void 0 ? void 0 : _b.call(mergedStyles, styleParam);
            if (cacheEnabled && theme) {
                stylesCache.set(theme, __assign(__assign({}, stylesCache.get(theme)), (_a = {}, _a[slotCacheKey] = target[slotName], _a)));
            }
            if (process.env.NODE_ENV !== 'production' && styles_1.isDebugEnabled) {
                resolvedStylesDebug[slotName] = (_c = target[slotName]) === null || _c === void 0 ? void 0 : _c['_debug'];
                (_d = target[slotName]) === null || _d === void 0 ? true : delete _d['_debug'];
            }
            if ((telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) && telemetry.performance[primaryDisplayName]) {
                telemetry.performance[primaryDisplayName].msResolveStylesTotal += performance.now() - telemetryPartStart;
            }
            return target[slotName];
        },
    });
    var classes = new Proxy({}, {
        get: function (target, slotName) {
            var _a;
            var slotCacheKey = componentCacheKey + slotName;
            if (cacheEnabled && theme) {
                var classesThemeCache = classesCache.get(theme) || {};
                //
                // Cached styles
                //
                if (classesThemeCache[slotCacheKey] || classesThemeCache[slotCacheKey] === '') {
                    if (telemetry === null || telemetry === void 0 ? void 0 : telemetry.performance[primaryDisplayName]) {
                        if (slotName === 'root') {
                            telemetry.performance[primaryDisplayName].stylesRootCacheHits++;
                        }
                        else {
                            telemetry.performance[primaryDisplayName].stylesSlotsCacheHits++;
                        }
                    }
                    return slotName === 'root'
                        ? classnames_1.default(componentClassName, classesThemeCache[slotCacheKey], className)
                        : classesThemeCache[slotCacheKey];
                }
            }
            //
            // Lazy eval
            //
            if (target[slotName]) {
                return slotName === 'root' ? classnames_1.default(componentClassName, target[slotName], className) : target[slotName];
            }
            // this resolves the getter magic
            var styleObj = resolvedStyles[slotName];
            var telemetryPartStart = (telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) ? performance.now() : 0;
            if (styleObj) {
                target[slotName] = renderer.renderRule(styleObj, rendererParam);
                if (cacheEnabled && theme) {
                    classesCache.set(theme, __assign(__assign({}, classesCache.get(theme)), (_a = {}, _a[slotCacheKey] = target[slotName], _a)));
                }
            }
            var resultClassName = slotName === 'root' ? classnames_1.default(componentClassName, target[slotName], className) : target[slotName];
            if ((telemetry === null || telemetry === void 0 ? void 0 : telemetry.enabled) && telemetry.performance[primaryDisplayName]) {
                telemetry.performance[primaryDisplayName].msRenderStylesTotal += performance.now() - telemetryPartStart;
            }
            return resultClassName;
        },
    });
    return {
        resolvedStyles: resolvedStyles,
        resolvedStylesDebug: resolvedStylesDebug,
        classes: classes,
    };
};
exports.resolveStyles = resolveStyles;
