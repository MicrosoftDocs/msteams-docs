"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.useTriggerElement = useTriggerElement;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _reactComponentRef = require("@fluentui/react-component-ref");

var React = _interopRequireWildcard(require("react"));

var ReactIs = _interopRequireWildcard(require("react-is"));

var _childrenExist = require("../utils/childrenExist");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// https://github.com/facebook/react/blob/c4e0768d7487a9359b74986e3b07841d2520f593/packages/react-dom/src/events/getListener.js#L15-L22
function isDisabledInteractive(node) {
  return (node.nodeName === 'BUTTON' || node.nodeName === 'INPUT' || node.nodeName === 'SELECT' || node.nodeName === 'TEXTAREA') && node.disabled;
}

function isInteractiveFilter(node) {
  return isDisabledInteractive(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
}
/**
 * Performs consistent checks for components that are using `trigger` pattern (`Tooltip`, `Popup`). Ensures that
 * `children` or `trigger` props will always pass a valid React element to what additional props and handlers can
 * be applied.
 */


function useTriggerElement(props) {
  var trigger = (0, _childrenExist.childrenExist)(props.children) ? props.children : props.trigger;
  var element = trigger ? React.Children.only(trigger) : null; // An exception should not be thrown in tests as components might be rendered without styles

  if (process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test') {
    if (ReactIs.isFragment(element)) {
      throw new Error('useTriggerElement(): A "React.Fragment" cannot be used as a "trigger" as it will be impossible to spread props on it');
    } // Hooks are used only for dev mode validations and will be removed in production builds

    /* eslint-disable react-hooks/rules-of-hooks */


    var ref = React.useRef();
    React.useEffect(function () {
      if (ref.current) {
        var _ref$current$ownerDoc;

        if (isDisabledInteractive(ref.current)) {
          // eslint-disable-next-line no-console
          console.warn(['useTriggerElement(): Disabled elements should used as a "trigger" accurately as it may lead to ', 'unexpected behavior as pointer events are ignored on disabled elements. Please wrap your "trigger" with', 'an additional element like a "div" if you need to show tooltips or popups on disabled elements, an', 'example is available in docs:', 'https://fluentsite.z22.web.core.windows.net/components/tooltip/definition#usage-disabled-trigger'].join(' '));
        }

        var treeWalker = (_ref$current$ownerDoc = ref.current.ownerDocument) == null ? void 0 : _ref$current$ownerDoc.createTreeWalker(ref.current, NodeFilter.SHOW_ELEMENT, {
          acceptNode: isInteractiveFilter
        });

        while (treeWalker != null && treeWalker.nextNode()) {
          var _node$ownerDocument, _node$ownerDocument$d;

          var node = treeWalker.currentNode;
          var nodeStyles = (_node$ownerDocument = node.ownerDocument) == null ? void 0 : (_node$ownerDocument$d = _node$ownerDocument.defaultView) == null ? void 0 : _node$ownerDocument$d.getComputedStyle(node);

          if ((nodeStyles == null ? void 0 : nodeStyles.pointerEvents) !== 'none') {
            throw new Error(['useTriggerElement(): A disabled element should have explicit "pointer-events: "none" in its styles', 'due a bug in Chrome that breaks "onMouseLeave" event in React:', 'https://github.com/facebook/react/issues/19692'].join(' '));
          }
        }
      }
    }, []);
    return element ?
    /*#__PURE__*/

    /* Required as components may call handlers via `trigger.props`, Ref will pass unhandled props down */
    React.createElement(_reactComponentRef.Ref, (0, _extends2.default)({}, element.props, {
      innerRef: ref
    }), element) : null;
  }

  return element;
}
//# sourceMappingURL=useTriggerElement.js.map
