"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var react_northstar_styles_renderer_1 = require("@fluentui/react-northstar-styles-renderer");
var styles_1 = require("@fluentui/styles");
var resolveStyles_1 = require("../../src/styles/resolveStyles");
var testComponentStyles = {
    root: function (_a) {
        var v = _a.variables, rtl = _a.rtl;
        return ({
            color: v.color,
            content: "\"rtl:" + rtl.toString() + "\"",
        });
    },
};
var resolvedVariables = {
    color: 'red',
};
var defaultPerformanceOptions = {
    enableSanitizeCssPlugin: true,
    enableStylesCaching: true,
    enableVariablesCaching: true,
    enableBooleanVariablesCaching: false,
};
var resolveStylesOptions = function (options) {
    var _a;
    var _b = options || {}, componentStyles = _b.componentStyles, _c = _b.displayNames, displayNames = _c === void 0 ? ['Test'] : _c, performance = _b.performance, _d = _b.componentProps, componentProps = _d === void 0 ? {} : _d, _e = _b.inlineStylesProps, inlineStylesProps = _e === void 0 ? {} : _e, _f = _b.renderRule, renderRule = _f === void 0 ? function () { return ''; } : _f, _g = _b.rtl, rtl = _g === void 0 ? false : _g;
    var theme = __assign(__assign({}, styles_1.emptyTheme), { componentStyles: __assign((_a = {}, _a[displayNames[0]] = testComponentStyles, _a), componentStyles) });
    return {
        theme: theme,
        allDisplayNames: displayNames,
        primaryDisplayName: displayNames[0],
        componentProps: componentProps,
        inlineStylesProps: inlineStylesProps,
        rtl: rtl,
        disableAnimations: false,
        renderer: __assign(__assign({}, react_northstar_styles_renderer_1.noopRenderer), { renderRule: renderRule }),
        performance: __assign(__assign({}, defaultPerformanceOptions), performance),
        saveDebug: function () { },
        telemetry: undefined,
    };
};
describe('resolveStyles', function () {
    test('resolves styles', function () {
        var resolvedStyles = resolveStyles_1.resolveStyles(resolveStylesOptions(), resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject({ color: 'red' });
    });
    test('caches resolved styles', function () {
        spyOn(testComponentStyles, 'root').and.callThrough();
        var resolvedStyles = resolveStyles_1.resolveStyles(resolveStylesOptions(), resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject({ color: 'red' });
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
        expect(resolvedStyles.root).toMatchObject({ color: 'red' });
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
    });
    test('does not render classes if not fetched', function () {
        var renderRule = jest.fn();
        var resolvedStyles = resolveStyles_1.resolveStyles(resolveStylesOptions({ renderRule: renderRule }), resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject({ color: 'red' });
        expect(renderRule).not.toBeCalled();
    });
    test('renders classes when slot classes getter is accessed', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var classes = resolveStyles_1.resolveStyles(resolveStylesOptions({ renderRule: renderRule }), resolvedVariables).classes;
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledWith(expect.objectContaining({ color: 'red' }), expect.anything());
    });
    test('caches rendered classes', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var classes = resolveStyles_1.resolveStyles(resolveStylesOptions({ renderRule: renderRule }), resolvedVariables).classes;
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledWith(expect.objectContaining({ color: 'red' }), expect.anything());
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledTimes(1);
    });
    test('caches resolved styles for no props', function () {
        spyOn(testComponentStyles, 'root').and.callThrough();
        var options = resolveStylesOptions();
        var resolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        var secondResolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
        expect(secondResolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
    });
    test('caches classes for no props', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var options = resolveStylesOptions({ displayNames: ['Test1'], renderRule: renderRule });
        var classes = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        var secondClasses = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledWith(expect.objectContaining({ color: 'red' }), expect.anything());
        expect(secondClasses['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledTimes(1);
    });
    test('caches resolved styles for the same props', function () {
        spyOn(testComponentStyles, 'root').and.callThrough();
        var options = resolveStylesOptions({
            displayNames: ['Test2'],
            componentProps: { primary: true },
        });
        var resolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        var secondResolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
        expect(secondResolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
    });
    test('caches classes for the same props', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var options = resolveStylesOptions({
            displayNames: ['Test3'],
            componentProps: { primary: true },
            renderRule: renderRule,
        });
        var classes = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        var secondClasses = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledWith(expect.objectContaining({ color: 'red' }), expect.anything());
        expect(secondClasses['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledTimes(1);
    });
    test('handles multiple displayNames', function () {
        var options = resolveStylesOptions({
            displayNames: ['Test', 'Other'],
            componentStyles: {
                Other: { root: function () { return ({ background: 'pink' }); } },
            },
        });
        expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root', expect.objectContaining({
            color: 'red',
            background: 'pink',
        }));
    });
    test('considers props when caching resolved styles', function () {
        spyOn(testComponentStyles, 'root').and.callThrough();
        var options = resolveStylesOptions({
            displayNames: ['Test4'],
            componentProps: { primary: true },
        });
        var resolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        var secondResolvedStyles = resolveStyles_1.resolveStyles(__assign(__assign({}, options), { componentProps: { primary: false } }), resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
        expect(secondResolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(2);
    });
    test('considers props when caching classes', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var options = resolveStylesOptions({
            displayNames: ['Test5'],
            componentProps: { primary: true },
            renderRule: renderRule,
        });
        var classes = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        options.componentProps = { primary: false };
        var secondClasses = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledWith(expect.objectContaining({ color: 'red' }), expect.anything());
        expect(secondClasses['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledTimes(2);
    });
    test('does not cache styles if caching is disabled', function () {
        spyOn(testComponentStyles, 'root').and.callThrough();
        var options = resolveStylesOptions({
            performance: { enableStylesCaching: false },
        });
        var resolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        var secondResolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
        expect(resolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(secondResolvedStyles.root).toMatchObject(expect.objectContaining({ color: 'red' }));
        expect(testComponentStyles.root).toHaveBeenCalledTimes(2);
    });
    test('does not cache classes if caching is disabled', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var options = resolveStylesOptions({
            performance: { enableStylesCaching: false },
            renderRule: renderRule,
        });
        var classes = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        var secondClasses = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
        expect(classes['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledWith(expect.objectContaining({ color: 'red' }), expect.anything());
        expect(secondClasses['root']).toBeDefined();
        expect(renderRule).toHaveBeenCalledTimes(2);
    });
    test('does not cache styles if there are inline overrides', function () {
        spyOn(testComponentStyles, 'root').and.callThrough();
        var propsInlineOverrides = [
            { styles: { fontSize: '10px' } },
            { design: { left: '10px' } },
            { variables: { backgroundColor: 'yellow' } },
        ];
        var propsInlineOverridesResolvedStyles = [
            { color: 'red', fontSize: '10px' },
            { color: 'red', left: '10px' },
            { color: 'red' },
        ];
        var propsInlineOverridesSize = propsInlineOverrides.length;
        _.forEach(propsInlineOverrides, function (inlineStylesProps, idx) {
            var options = resolveStylesOptions({
                inlineStylesProps: inlineStylesProps,
                performance: { enableStylesCaching: false },
            });
            var resolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
            var secondResolvedStyles = resolveStyles_1.resolveStyles(options, resolvedVariables).resolvedStyles;
            expect(resolvedStyles.root).toMatchObject(propsInlineOverridesResolvedStyles[idx]);
            expect(secondResolvedStyles.root).toMatchObject(propsInlineOverridesResolvedStyles[idx]);
            resolveStyles_1.resolveStyles(options, resolvedVariables);
        });
        expect(testComponentStyles.root).toHaveBeenCalledTimes(propsInlineOverridesSize * 2);
    });
    test('does not cache classes if there are inline overrides', function () {
        var renderRule = jest.fn().mockReturnValue('a');
        var propsInlineOverrides = [
            { styles: { fontSize: '10px' } },
            { design: { left: '10px' } },
            { variables: { backgroundColor: 'yellow' } },
        ];
        var propsInlineOverridesSize = propsInlineOverrides.length;
        _.forEach(propsInlineOverrides, function (inlineStylesProps) {
            var options = resolveStylesOptions({
                inlineStylesProps: inlineStylesProps,
                performance: { enableStylesCaching: false },
                renderRule: renderRule,
            });
            var classes = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
            var secondClasses = resolveStyles_1.resolveStyles(options, resolvedVariables).classes;
            expect(classes['root']).toBeDefined();
            expect(secondClasses['root']).toBeDefined();
        });
        expect(renderRule).toHaveBeenCalledTimes(propsInlineOverridesSize * 2);
    });
    test('computes new styles when "rtl" changes', function () {
        var renderRule = jest.fn().mockImplementation(function (style) { return style.content; });
        var ltrOptions = resolveStylesOptions({ rtl: false, renderRule: renderRule });
        var rtlOptions = resolveStylesOptions({ rtl: true, renderRule: renderRule });
        var ltrStyles = resolveStyles_1.resolveStyles(ltrOptions, resolvedVariables);
        var rtlStyles = resolveStyles_1.resolveStyles(rtlOptions, resolvedVariables);
        expect(ltrStyles).toHaveProperty('resolvedStyles.root.content', expect.stringMatching(/rtl:false/));
        expect(ltrStyles).toHaveProperty('classes.root', expect.stringMatching(/rtl:false/));
        expect(renderRule).toHaveBeenCalledTimes(1);
        expect(rtlStyles).toHaveProperty('resolvedStyles.root.content', expect.stringMatching(/rtl:true/));
        expect(rtlStyles).toHaveProperty('classes.root', expect.stringMatching(/rtl:true/));
        expect(renderRule).toHaveBeenCalledTimes(2);
    });
    describe('enableBooleanVariablesCaching', function () {
        test('avoids "classes" computation when enabled', function () {
            var renderRule = jest.fn().mockReturnValue('a');
            var options = resolveStylesOptions({
                inlineStylesProps: { variables: { isFoo: true, isBar: null, isBaz: undefined } },
                performance: { enableBooleanVariablesCaching: true },
                renderRule: renderRule,
            });
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('classes.root', 'a');
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('classes.root', 'a');
            expect(renderRule).toHaveBeenCalledTimes(1);
        });
        test('avoids "classes" computation when enabled and there is no variables', function () {
            var renderRule = jest.fn().mockReturnValue('a');
            var options = resolveStylesOptions({
                performance: { enableBooleanVariablesCaching: true },
                renderRule: renderRule,
            });
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('classes.root', 'a');
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('classes.root', 'a');
            expect(renderRule).toHaveBeenCalledTimes(1);
        });
        test('forces "classes" computation when disabled', function () {
            var renderRule = jest.fn().mockReturnValue('a');
            var options = resolveStylesOptions({
                inlineStylesProps: { variables: { isFoo: true, isBar: null, isBaz: undefined } },
                performance: { enableBooleanVariablesCaching: false },
                renderRule: renderRule,
            });
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('classes.root', 'a');
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('classes.root', 'a');
            expect(renderRule).toHaveBeenCalledTimes(2);
        });
        test('avoids "styles" computation when enabled', function () {
            spyOn(testComponentStyles, 'root').and.callThrough();
            var options = resolveStylesOptions({
                inlineStylesProps: { variables: { isFoo: true, isBar: null, isBaz: undefined } },
                performance: { enableBooleanVariablesCaching: true },
            });
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root');
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root');
            expect(testComponentStyles.root).toHaveBeenCalledTimes(1);
        });
        test('requires "enableStylesCaching" to be enabled', function () {
            var options = resolveStylesOptions({
                performance: { enableStylesCaching: false, enableBooleanVariablesCaching: true },
            });
            expect(function () { return resolveStyles_1.resolveStyles(options, resolvedVariables); }).toThrowError(/Please check your "performance" settings on "Provider"/);
        });
        test('when enabled only "variables" as plain objects can be cached', function () {
            spyOn(testComponentStyles, 'root').and.callThrough();
            var options = resolveStylesOptions({
                inlineStylesProps: { variables: function () { } },
                performance: { enableBooleanVariablesCaching: true },
            });
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root');
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root');
            expect(testComponentStyles.root).toHaveBeenCalledTimes(2);
        });
        test('when enabled only "variables" as boolean or nil properties can be cached', function () {
            spyOn(testComponentStyles, 'root').and.callThrough();
            var options = resolveStylesOptions({
                inlineStylesProps: { variables: { foo: 'bar' } },
                performance: { enableBooleanVariablesCaching: true },
            });
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root');
            expect(resolveStyles_1.resolveStyles(options, resolvedVariables)).toHaveProperty('resolvedStyles.root');
            expect(testComponentStyles.root).toHaveBeenCalledTimes(2);
        });
    });
});
