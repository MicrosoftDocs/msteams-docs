"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_bindings_1 = require("@fluentui/react-bindings");
var react_northstar_styles_renderer_1 = require("@fluentui/react-northstar-styles-renderer");
var styles_1 = require("@fluentui/styles");
var classnames_1 = require("classnames");
var enzyme_1 = require("enzyme");
var React = require("react");
var TestProvider = function (props) {
    var value = {
        disableAnimations: false,
        renderer: __assign(__assign({}, react_northstar_styles_renderer_1.noopRenderer), { renderRule: function (props) {
                return classnames_1.default(props.color && "color-" + props.color, props.hidden && "hidden-" + props.hidden, props.visible && "visible-" + props.visible);
            } }),
        performance: {
            enableStylesCaching: false,
            enableVariablesCaching: false,
            enableSanitizeCssPlugin: false,
            enableBooleanVariablesCaching: false,
        },
        rtl: false,
        telemetry: undefined,
        target: undefined,
        theme: __assign(__assign({}, styles_1.emptyTheme), { 
            // Noop to pass all props as styles to `renderRule()`
            componentStyles: new Proxy({}, { get: function () { return ({ root: function (_a) {
                        var props = _a.props;
                        return props;
                    } }); } }) }),
    };
    return React.createElement(react_bindings_1.Unstable_FluentContextProvider, { value: value }, props.children);
};
var BaseComponent = react_bindings_1.compose(function (props, ref, composeOptions) {
    var color = props.color;
    var _a = React.useState(false), open = _a[0], setOpen = _a[1];
    var classes = react_bindings_1.useStyles(composeOptions.displayName, {
        className: composeOptions.className,
        composeOptions: composeOptions,
        mapPropsToStyles: function () { return ({ color: color, open: open }); },
        unstable_props: props,
    }).classes;
    var unhandledProps = react_bindings_1.useUnhandledProps(composeOptions.handledProps, props);
    return (React.createElement("button", __assign({ className: classes.root, "data-display-name": composeOptions.slots.__self.displayName, onClick: function () { return setOpen(!open); }, ref: ref }, unhandledProps)));
}, {
    className: 'ui-base',
    displayName: 'BaseComponent',
    handledProps: ['className', 'color'],
});
var ComposedComponent = react_bindings_1.compose(BaseComponent, {
    className: 'ui-composed',
    displayName: 'ComposedComponent',
    mapPropsToStylesProps: function (props) { return ({ visible: props.open && props.visible }); },
    handledProps: ['hidden', 'visible'],
});
var MultipleComposedComponent = react_bindings_1.compose(ComposedComponent, {
    displayName: 'MultipleComposedComponent',
    mapPropsToStylesProps: function (props) { return ({ hidden: props.hidden, visible: undefined }); },
});
var BaseComponentWithSlots = react_bindings_1.compose(function (props, ref, composeOptions) {
    var classes = react_bindings_1.useStyles(composeOptions.displayName, {
        className: composeOptions.className,
        composeOptions: composeOptions,
        unstable_props: props,
    }).classes;
    var unhandledProps = react_bindings_1.useUnhandledProps(composeOptions.handledProps, props);
    var Start = composeOptions.slots.start;
    var Main = composeOptions.slots.main;
    var End = composeOptions.slots.end;
    var slotProps = composeOptions.resolveSlotProps(props);
    return (React.createElement("button", __assign({ className: classes.root }, unhandledProps, { ref: ref }),
        React.createElement(Start, __assign({ className: classes.root, id: "start" }, slotProps.start)),
        React.createElement(Main, __assign({ className: classes.root, id: "main" }, slotProps.main)),
        React.createElement(End, __assign({ className: classes.root, id: "end" }, slotProps.end))));
}, {
    className: 'ui-base-with-slots',
    displayName: 'BaseComponentWithSlots',
    handledProps: ['className', 'data-start', 'data-end', 'data-main'],
    slots: {
        start: 'span',
        main: 'b',
        end: 'i',
    },
    slotProps: function (props) { return ({
        start: {
            'data-attr': props['data-start'],
        },
        main: {
            'data-attr': props['data-main'],
        },
        end: {
            'data-attr': props['data-end'],
        },
    }); },
});
describe('useCompose', function () {
    it('applies props on base component', function () {
        var wrapper = enzyme_1.mount(React.createElement(BaseComponent, { color: "red" }), { wrappingComponent: TestProvider });
        expect(wrapper.find('button').prop('className')).toContain('ui-base');
        expect(wrapper.find('button').prop('className')).toContain('color-red');
    });
    it('applies props on composed component', function () {
        var wrapper = enzyme_1.mount(React.createElement(ComposedComponent, { hidden: true, color: "red", visible: true }), { wrappingComponent: TestProvider });
        expect(wrapper.find('button').prop('hidden')).toBeUndefined();
        expect(wrapper.find('button').prop('visible')).toBeUndefined();
        expect(wrapper.find('button').prop('className')).toContain('ui-composed');
        expect(wrapper.find('button').prop('className')).toContain('color-red');
        expect(wrapper.find('button').prop('className')).not.toContain('visible-true');
        wrapper.find('button').simulate('click');
        expect(wrapper.find('button').prop('className')).toContain('visible-true');
    });
    it('applies props on multiple times composed component', function () {
        var wrapper = enzyme_1.mount(React.createElement(MultipleComposedComponent, { hidden: true, color: "red", visible: true }), {
            wrappingComponent: TestProvider,
        });
        expect(wrapper.find('button').prop('hidden')).toBeUndefined();
        expect(wrapper.find('button').prop('visible')).toBeUndefined();
        expect(wrapper.find('button').prop('className')).toContain('ui-composed');
        expect(wrapper.find('button').prop('className')).toContain('color-red');
        expect(wrapper.find('button').prop('className')).toContain('hidden-true');
        expect(wrapper.find('button').prop('className')).not.toContain('visible-true');
    });
    it('applies correct slots in the structure', function () {
        var wrapper = enzyme_1.shallow(React.createElement(BaseComponentWithSlots, null));
        expect(wrapper.find('#start').name()).toEqual('span');
        expect(wrapper.find('#main').name()).toEqual('b');
        expect(wrapper.find('#end').name()).toEqual('i');
    });
    it('passes component definition as "__self"', function () {
        var wrapper = enzyme_1.shallow(React.createElement(BaseComponent, null));
        expect(wrapper.find('button').prop('data-display-name')).toEqual('BaseComponent');
    });
    it('applies mapped props to correct slots', function () {
        var wrapper = enzyme_1.shallow(React.createElement(BaseComponentWithSlots, { "data-main": true, "data-end": false }));
        var startDataAttr = wrapper.find('#start').prop('data-attr');
        expect(startDataAttr).toEqual(undefined);
        var mainDataAttr = wrapper.find('#main').prop('data-attr');
        expect(mainDataAttr).toEqual(true);
        var endDataAttr = wrapper.find('#end').prop('data-attr');
        expect(endDataAttr).toEqual(false);
    });
    it('merges mapped props to slot props along the chain', function () {
        var ComposedComponentWithSlots = react_bindings_1.compose(BaseComponentWithSlots, {
            className: 'ui-composed-with-slots',
            displayName: 'ComposedComponentWithSlots',
            slotProps: function (props) { return ({
                start: { 'data-attr': false },
                main: { 'data-main-composed': props['data-main-composed'] },
            }); },
            handledProps: ['data-main-composed'],
        });
        var wrapper = enzyme_1.shallow(React.createElement(ComposedComponentWithSlots, { "data-start": true, "data-main": true, "data-main-composed": true }));
        var startDataAttr = wrapper.find('#start').prop('data-attr');
        expect(startDataAttr).toEqual(false);
        var mainComposedDataAttr = wrapper.find('#main').prop('data-main-composed');
        expect(mainComposedDataAttr).toEqual(true);
        var mainDataAttr = wrapper.find('#main').prop('data-attr');
        expect(mainDataAttr).toEqual(true);
    });
});
