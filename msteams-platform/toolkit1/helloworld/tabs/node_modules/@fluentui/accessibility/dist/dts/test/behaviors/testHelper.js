"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestHelper = void 0;
var _ = require("lodash");
var skipSpecChecksForFiles = [
    'menuButtonBehavior.ts',
    'popupBehavior.ts',
    'buttonBehavior.ts',
    'buttonGroupBehavior.ts',
    'toggleButtonBehavior.ts',
    'listBehavior.ts',
    'listItemBehavior.ts',
    'alertBehavior.ts',
    'alertBaseBehavior.ts',
    'sliderBehavior.ts',
    'treeItemAsListItemBehavior.ts',
    'treeTitleAsListItemTitleBehavior.ts',
    'treeItemAsOptionBehavior.ts',
    'treeTitleAsOptionBehavior.ts',
    'gridRowBehavior.ts',
    'pillBehavior.ts',
    'pillGroupBehavior.ts',
    'pillOptionBehavior.ts',
    'pillActionBehavior.ts',
    'pillImageBehavior.ts',
    'pillIconBehavior.ts', // tests are written in pillIconBehaviorDefinition.ts
];
var TestHelper = /** @class */ (function () {
    function TestHelper() {
        this.behaviors = new Map();
        this.testDefinitions = [];
        this.filteredSpecificationWithAssignedTestMethod = [];
    }
    TestHelper.prototype.addBehavior = function (name, behavior) {
        this.behaviors.set(name, behavior);
    };
    TestHelper.prototype.addTest = function (regexp, testMethod) {
        this.testDefinitions.push({ regexp: regexp, testMethod: testMethod });
    };
    TestHelper.prototype.addTests = function (testDefinitions) {
        var _this = this;
        testDefinitions.forEach(function (testDefinition) {
            _this.testDefinitions.push(testDefinition);
        });
    };
    TestHelper.prototype.run = function (behaviorMenuItems) {
        var _this = this;
        this.findRegexAndAssingCorrespondingInfoToArray(behaviorMenuItems);
        var groupedByBehavior = _.groupBy(this.filteredSpecificationWithAssignedTestMethod, 'behaviorName');
        _.each(groupedByBehavior, function (value, key) {
            describe(key, function () {
                value.forEach(function (singleTest) {
                    test(singleTest.params[0], function () {
                        singleTest.testMethod({
                            behavior: _this.getBehavior(singleTest.behaviorName),
                            props: singleTest.params.slice(1),
                        });
                    });
                });
            });
        });
    };
    TestHelper.prototype.findRegexAndAssingCorrespondingInfoToArray = function (behaviorMenuItems) {
        var _this = this;
        behaviorMenuItems.forEach(function (behavior) {
            behavior.variations.forEach(function (variant) {
                if (!variant.specification && !variant.description) {
                    _this.failDescriptionPresenceTest(variant.name);
                }
                // should not continue when behavior is skipped/exluded
                if (skipSpecChecksForFiles.find(function (item) { return item === variant.name; })) {
                    return;
                }
                if (!variant.specification) {
                    _this.failSpecificationPresenceTest(variant.name);
                }
                else {
                    variant.specification.split('\n').forEach(function (specLine) {
                        if (specLine) {
                            _this.iterateRegexDefinitions(specLine, variant.name);
                        }
                    });
                }
            });
        });
    };
    TestHelper.prototype.iterateRegexDefinitions = function (specLine, behaviorName) {
        var _this = this;
        var regexMatched = false;
        this.testDefinitions.forEach(function (testDefinition) {
            var regex = new RegExp(testDefinition.regexp);
            var result = regex.exec(specLine);
            if (result) {
                regexMatched = true;
                _this.filteredSpecificationWithAssignedTestMethod.push({
                    behaviorName: behaviorName,
                    testMethod: testDefinition.testMethod,
                    params: result,
                });
            }
        });
        if (!regexMatched) {
            test(behaviorName + " \n LINE: " + specLine + " ", function () {
                fail("Line mentioned in **behavior specification** doesn't match any regex expression of validation tests.");
            });
        }
    };
    TestHelper.prototype.getBehavior = function (behaviorName) {
        var baseBehaviorName = behaviorName.replace('.ts', '');
        var importedBehavior = this.behaviors.get(baseBehaviorName);
        if (!importedBehavior) {
            throw 'Accessibility behavior file was not found, probably was not imported. Import file and add behavior.';
        }
        return importedBehavior;
    };
    TestHelper.prototype.convertToMatchingTypeIfApplicable = function (stringToConvert) {
        if (stringToConvert === 'true') {
            return true;
        }
        if (stringToConvert === 'false') {
            return false;
        }
        if (typeof stringToConvert === 'string' && !Number.isNaN(Number(stringToConvert))) {
            return Number(stringToConvert);
        }
        return stringToConvert;
    };
    TestHelper.prototype.failSpecificationPresenceTest = function (behaviorFileName) {
        test(behaviorFileName + " : Accessibility behavior is missing specification tag.", function () {
            fail("Accessibility behavior should have specification tag. If tests are written in separate file then add behavior file name into 'skipSpecChecksForFiles'.");
        });
    };
    TestHelper.prototype.failDescriptionPresenceTest = function (behaviorFileName) {
        test(behaviorFileName + " : Accessibility behavior is missing description.", function () {
            fail('Accessibility behavior should have description.');
        });
    };
    return TestHelper;
}());
exports.TestHelper = TestHelper;
