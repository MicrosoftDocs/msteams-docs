"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketServer = void 0;
/**
 * @module botframework-streaming
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const protocolAdapter_1 = require("../protocolAdapter");
const payloads_1 = require("../payloads");
const payloadTransport_1 = require("../payloadTransport");
const webSocketTransport_1 = require("./webSocketTransport");
/**
 * Web socket based server to be used as streaming transport.
 */
class WebSocketServer {
    /**
     * Creates a new instance of the [WebSocketServer](xref:botframework-streaming.WebSocketServer) class.
     *
     * @param socket The underlying web socket.
     * @param requestHandler Optional [RequestHandler](xref:botframework-streaming.RequestHandler) to process incoming messages received by this server.
     */
    constructor(socket, requestHandler) {
        if (!socket) {
            throw new TypeError('WebSocketServer: Missing socket parameter');
        }
        this._socket = socket;
        this._webSocketTransport = new webSocketTransport_1.WebSocketTransport(socket);
        this._requestHandler = requestHandler;
        this._requestManager = new payloads_1.RequestManager();
        this._sender = new payloadTransport_1.PayloadSender();
        this._sender.disconnected = this.onConnectionDisconnected.bind(this);
        this._receiver = new payloadTransport_1.PayloadReceiver();
        this._receiver.disconnected = this.onConnectionDisconnected.bind(this);
        this._protocolAdapter = new protocolAdapter_1.ProtocolAdapter(this._requestHandler, this._requestManager, this._sender, this._receiver);
        this._closedSignal = (x) => {
            return x;
        };
    }
    /**
     * Examines the stored [ISocket](xref:botframework-streaming.ISocket) and returns `true` if the socket connection is open.
     *
     * @returns `true` if the underlying websocket is ready and availble to send messages, otherwise `false`.
     */
    get isConnected() {
        return this._socket.isConnected;
    }
    /**
     * Used to establish the connection used by this server and begin listening for incoming messages.
     *
     * @returns A promise to handle the server listen operation. This task will not resolve as long as the server is running.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this._sender.connect(this._webSocketTransport);
            this._receiver.connect(this._webSocketTransport);
            return this._closedSignal;
        });
    }
    /**
     * Task used to send data over this server connection.
     *
     * @param request The streaming request to send.
     * @returns A promise that will produce an instance of receive response on completion of the send operation.
     */
    send(request) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._protocolAdapter.sendRequest(request);
        });
    }
    /**
     * Stop this server.
     */
    disconnect() {
        this._sender.disconnect(new payloadTransport_1.TransportDisconnectedEvent('Disconnect was called.'));
        this._receiver.disconnect(new payloadTransport_1.TransportDisconnectedEvent('Disconnect was called.'));
    }
    /**
     * @param sender The PayloadReceiver or PayloadSender that triggered or received a disconnect.
     * @param e TransportDisconnectedEvent
     */
    onConnectionDisconnected(sender, e) {
        if (this._closedSignal) {
            this._closedSignal('close');
            this._closedSignal = null;
        }
        if (sender === this._sender) {
            this._receiver.disconnect(e);
        }
        if (sender === this._receiver) {
            this._sender.disconnect(e);
        }
    }
}
exports.WebSocketServer = WebSocketServer;
//# sourceMappingURL=webSocketServer.js.map