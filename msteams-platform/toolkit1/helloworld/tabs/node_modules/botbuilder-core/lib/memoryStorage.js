"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoryStorage = void 0;
/**
 * Memory based storage provider for a bot.
 *
 * @remarks
 * This provider is most useful for simulating production storage when running locally against the
 * emulator or as part of a unit test. It has the following characteristics:
 *
 * - Starts off completely empty when the bot is run.
 * - Anything written to the store will be forgotten when the process exits.
 * - Objects that are read and written to the store are cloned to properly simulate network based
 *   storage providers.
 * - Cloned objects are serialized using `JSON.stringify()` to catch any possible serialization
 *   related issues that might occur when using a network based storage provider.
 *
 * ```JavaScript
 * const { MemoryStorage } = require('botbuilder');
 *
 * const storage = new MemoryStorage();
 * ```
 */
class MemoryStorage {
    /**
     * Creates a new MemoryStorage instance.
     * @param memory (Optional) memory to use for storing items. By default it will create an empty JSON object `{}`.
     */
    constructor(memory = {}) {
        this.memory = memory;
        this.etag = 1;
    }
    /**
     * Reads storage items from storage.
     * @param keys Keys of the [StoreItems](xref:botbuilder-core.StoreItems) objects to read.
     * @returns The read items.
     */
    read(keys) {
        return new Promise((resolve, reject) => {
            if (!keys) {
                throw new ReferenceError(`Keys are required when reading.`);
            }
            const data = {};
            keys.forEach((key) => {
                const item = this.memory[key];
                if (item) {
                    data[key] = JSON.parse(item);
                }
            });
            resolve(data);
        });
    }
    /**
     * Writes storage items to storage.
     * @param changes The [StoreItems](xref:botbuilder-core.StoreItems) to write, indexed by key.
     */
    write(changes) {
        const that = this;
        function saveItem(key, item) {
            const clone = Object.assign({}, item);
            clone.eTag = (that.etag++).toString();
            that.memory[key] = JSON.stringify(clone);
        }
        return new Promise((resolve, reject) => {
            if (!changes) {
                throw new ReferenceError(`Changes are required when writing.`);
            }
            Object.keys(changes).forEach((key) => {
                const newItem = changes[key];
                const old = this.memory[key];
                if (!old || newItem.eTag === '*' || !newItem.eTag) {
                    saveItem(key, newItem);
                }
                else {
                    const oldItem = JSON.parse(old);
                    if (newItem.eTag === oldItem.eTag) {
                        saveItem(key, newItem);
                    }
                    else {
                        reject(new Error(`Storage: error writing "${key}" due to eTag conflict.`));
                    }
                }
            });
            resolve();
        });
    }
    /**
     * Deletes storage items from storage.
     * @param keys Keys of the [StoreItems](xref:botbuilder-core.StoreItems) objects to delete.
     */
    delete(keys) {
        return new Promise((resolve, reject) => {
            keys.forEach((key) => (this.memory[key] = undefined));
            resolve();
        });
    }
}
exports.MemoryStorage = MemoryStorage;
//# sourceMappingURL=memoryStorage.js.map