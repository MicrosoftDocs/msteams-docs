{"version":3,"file":"cryptographyClient.js","sourceRoot":"","sources":["../../../src/cryptographyClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { OperationOptions, TokenCredential } from \"@azure/core-http\";\nimport {\n  JsonWebKey,\n  KeyVaultKey,\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyOperation,\n  KnownKeyOperations,\n} from \"./keysModels\";\nimport {\n  EncryptionAlgorithm,\n  KeyWrapAlgorithm,\n  WrapResult,\n  UnwrapResult,\n  DecryptResult,\n  SignatureAlgorithm,\n  SignResult,\n  VerifyResult,\n  EncryptResult,\n  EncryptOptions,\n  DecryptOptions,\n  WrapKeyOptions,\n  UnwrapKeyOptions,\n  EncryptParameters,\n  SignOptions,\n  VerifyOptions,\n  DecryptParameters,\n  CryptographyClientKey,\n  AesCbcEncryptParameters,\n  AesCbcEncryptionAlgorithm,\n} from \"./cryptographyClientModels\";\nimport { RemoteCryptographyProvider } from \"./cryptography/remoteCryptographyProvider\";\nimport { randomBytes } from \"./cryptography/crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./cryptography/models\";\nimport { RsaCryptographyProvider } from \"./cryptography/rsaCryptographyProvider\";\nimport { AesCryptographyProvider } from \"./cryptography/aesCryptographyProvider\";\nimport { createTraceFunction } from \"../../keyvault-common/src\";\n\nconst withTrace = createTraceFunction(\"Azure.KeyVault.Keys.CryptographyClient\");\n\n/**\n * A client used to perform cryptographic operations on an Azure Key vault key\n * or a local {@link JsonWebKey}.\n */\nexport class CryptographyClient {\n  /**\n   * The key the CryptographyClient currently holds.\n   */\n  private key: CryptographyClientKey;\n\n  /**\n   * The remote provider, which would be undefined if used in local mode.\n   */\n  private remoteProvider?: RemoteCryptographyProvider;\n\n  /**\n   * Constructs a new instance of the Cryptography client for the given key\n   *\n   * Example usage:\n   * ```ts\n   * import { KeyClient, CryptographyClient } from \"@azure/keyvault-keys\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let keyClient = new KeyClient(vaultUrl, credentials);\n   * let keyVaultKey = await keyClient.getKey(\"MyKey\");\n   *\n   * let client = new CryptographyClient(keyVaultKey.id, credentials);\n   * // or\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * ```\n   * @param key - The key to use during cryptography tasks. You can also pass the identifier of the key i.e its url here.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions?: CryptographyClientOptions\n  );\n  /**\n   * Constructs a new instance of the Cryptography client for the given key in local mode.\n   *\n   * Example usage:\n   * ```ts\n   * import { CryptographyClient } from \"@azure/keyvault-keys\";\n   *\n   * const jsonWebKey: JsonWebKey = {\n   *   // ...\n   * };\n   * const client = new CryptographyClient(jsonWebKey);\n   * ```\n   * @param key - The JsonWebKey to use during cryptography operations.\n   */\n  constructor(key: JsonWebKey);\n  /**\n   * Internal constructor implementation for either local or Key Vault backed keys.\n   * @param key - The key to use during cryptography tasks.\n   * @param credential - Teh credential to use when constructing a Key Vault Cryptography client.\n   */\n  constructor(\n    key: string | KeyVaultKey | JsonWebKey,\n    credential?: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    if (typeof key === \"string\") {\n      // Key URL for remote-local operations.\n      this.key = {\n        kind: \"identifier\",\n        value: key,\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else if (\"name\" in key) {\n      // KeyVault key for remote-local operations.\n      this.key = {\n        kind: \"KeyVaultKey\",\n        value: key,\n      };\n      this.remoteProvider = new RemoteCryptographyProvider(key, credential!, pipelineOptions);\n    } else {\n      // JsonWebKey for local-only operations.\n      this.key = {\n        kind: \"JsonWebKey\",\n        value: key,\n      };\n    }\n  }\n\n  /**\n   * The base URL to the vault. If a local {@link JsonWebKey} is used vaultUrl will be empty.\n   */\n  get vaultUrl(): string {\n    return this.remoteProvider?.vaultUrl || \"\";\n  }\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyID(): string | undefined {\n    if (this.key.kind === \"identifier\") {\n      return this.key.value;\n    } else if (this.key.kind === \"KeyVaultKey\") {\n      return this.key.value.id;\n    } else {\n      return this.key.value.kid;\n    }\n  }\n\n  /**\n   * Encrypts the given plaintext with the specified encryption parameters.\n   * Depending on the algorithm set in the encryption parameters, the set of possible encryption parameters will change.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt({ algorithm: \"RSA1_5\", plaintext: Buffer.from(\"My Message\")});\n   * let result = await client.encrypt({ algorithm: \"A256GCM\", plaintext: Buffer.from(\"My Message\"), additionalAuthenticatedData: Buffer.from(\"My authenticated data\")});\n   * ```\n   * @param encryptParameters - The encryption parameters, keyed on the encryption algorithm chosen.\n   * @param options - Additional options.\n   */\n  public encrypt(\n    encryptParameters: EncryptParameters,\n    options?: EncryptOptions\n  ): Promise<EncryptResult>;\n  /**\n   * Encrypts the given plaintext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.encrypt(\"RSA1_5\", Buffer.from(\"My Message\"));\n   * ```\n   * @param algorithm - The algorithm to use.\n   * @param plaintext - The text to encrypt.\n   * @param options - Additional options.\n   * @deprecated Use `encrypt({ algorithm, plaintext }, options)` instead.\n   */\n  public encrypt(\n    algorithm: EncryptionAlgorithm,\n    plaintext: Uint8Array,\n    options?: EncryptOptions\n  ): Promise<EncryptResult>;\n  public encrypt(\n    ...args:\n      | [EncryptParameters, EncryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, EncryptOptions?]\n  ): Promise<EncryptResult> {\n    const [parameters, options] = this.disambiguateEncryptArguments(args);\n    return withTrace(\"encrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Encrypt);\n      this.initializeIV(parameters);\n      const provider = await this.getProvider(\"encrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.encrypt(parameters, updatedOptions);\n      } catch (error) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.encrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  private initializeIV(parameters: EncryptParameters): void {\n    // For AES-GCM the service **must** generate the IV, so we only populate it for AES-CBC\n    const algorithmsRequiringIV: AesCbcEncryptionAlgorithm[] = [\n      \"A128CBC\",\n      \"A128CBCPAD\",\n      \"A192CBC\",\n      \"A192CBCPAD\",\n      \"A256CBC\",\n      \"A256CBCPAD\",\n    ];\n\n    if (parameters.algorithm in algorithmsRequiringIV) {\n      try {\n        const cbcParams = parameters as AesCbcEncryptParameters;\n        if (!cbcParams.iv) {\n          cbcParams.iv = randomBytes(16);\n        }\n      } catch (e) {\n        throw new Error(\n          `Unable to initialize IV for algorithm ${parameters.algorithm}. You may pass a valid IV to avoid this error. Error: ${e.message}`\n        );\n      }\n    }\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The encrypt arguments\n   */\n  private disambiguateEncryptArguments(\n    args: [EncryptParameters, EncryptOptions?] | [string, Uint8Array, EncryptOptions?]\n  ): [EncryptParameters, EncryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", buffer, options]\n      return [\n        {\n          algorithm: args[0],\n          plaintext: args[1],\n        } as EncryptParameters,\n        args[2] || {},\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", plaintext: buffer }, options]\n      return [args[0], (args[1] || {}) as EncryptOptions];\n    }\n  }\n\n  /**\n   * Decrypts the given ciphertext with the specified decryption parameters.\n   * Depending on the algorithm used in the decryption parameters, the set of possible decryption parameters will change.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt({ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer });\n   * let result = await client.decrypt({ algorithm: \"A256GCM\", iv: ivFromEncryptResult, authenticationTag: tagFromEncryptResult });\n   * ```\n   * @param decryptParameters - The decryption parameters.\n   * @param options - Additional options.\n   */\n  public async decrypt(\n    decryptParameters: DecryptParameters,\n    options?: DecryptOptions\n  ): Promise<DecryptResult>;\n  /**\n   * Decrypts the given ciphertext with the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.decrypt(\"RSA1_5\", encryptedBuffer);\n   * ```\n   * @param algorithm - The algorithm to use.\n   * @param ciphertext - The text to decrypt.\n   * @param options - Additional options.\n   * @deprecated Use `decrypt({ algorithm, ciphertext }, options)` instead.\n   */\n  public decrypt(\n    algorithm: EncryptionAlgorithm,\n    ciphertext: Uint8Array,\n    options?: DecryptOptions\n  ): Promise<DecryptResult>;\n  public decrypt(\n    ...args:\n      | [DecryptParameters, DecryptOptions?]\n      | [EncryptionAlgorithm, Uint8Array, DecryptOptions?]\n  ): Promise<DecryptResult> {\n    const [parameters, options] = this.disambiguateDecryptArguments(args);\n\n    return withTrace(\"decrypt\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Decrypt);\n      const provider = await this.getProvider(\"decrypt\", parameters.algorithm, updatedOptions);\n      try {\n        return provider.decrypt(parameters, updatedOptions);\n      } catch (error) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.decrypt(parameters, updatedOptions);\n        }\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Standardizes the arguments of multiple overloads into a single shape.\n   * @param args - The decrypt arguments\n   */\n  private disambiguateDecryptArguments(\n    args: [DecryptParameters, DecryptOptions?] | [string, Uint8Array, DecryptOptions?]\n  ): [DecryptParameters, DecryptOptions] {\n    if (typeof args[0] === \"string\") {\n      // Sample shape: [\"RSA1_5\", encryptedBuffer, options]\n      return [\n        {\n          algorithm: args[0],\n          ciphertext: args[1],\n        } as DecryptParameters,\n        args[2] || {},\n      ];\n    } else {\n      // Sample shape: [{ algorithm: \"RSA1_5\", ciphertext: encryptedBuffer }, options]\n      return [args[0], (args[1] || {}) as DecryptOptions];\n    }\n  }\n\n  /**\n   * Wraps the given key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.wrapKey(\"RSA1_5\", keyToWrap);\n   * ```\n   * @param algorithm - The encryption algorithm to use to wrap the given key.\n   * @param key - The key to wrap.\n   * @param options - Additional options.\n   */\n  public wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    key: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    return withTrace(\"wrapKey\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.WrapKey);\n      const provider = await this.getProvider(\"wrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.wrapKey(algorithm, key, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.wrapKey(algorithm, key, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Unwraps the given wrapped key using the specified cryptography algorithm\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.unwrapKey(\"RSA1_5\", keyToUnwrap);\n   * ```\n   * @param algorithm - The decryption algorithm to use to unwrap the key.\n   * @param encryptedKey - The encrypted key to unwrap.\n   * @param options - Additional options.\n   */\n  public unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    return withTrace(\"unwrapKey\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.UnwrapKey);\n      const provider = await this.getProvider(\"unwrapKey\", algorithm, updatedOptions);\n      try {\n        return provider.unwrapKey(algorithm, encryptedKey, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.unwrapKey(algorithm, encryptedKey, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Cryptographically sign the digest of a message\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.sign(\"RS256\", digest);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param digest - The digest of the data to sign.\n   * @param options - Additional options.\n   */\n  public sign(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    return withTrace(\"sign\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"sign\", algorithm, updatedOptions);\n      try {\n        return provider.sign(algorithm, digest, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.sign(algorithm, digest, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Verify the signed message digest\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verify(\"RS256\", signedDigest, signature);\n   * ```\n   * @param algorithm - The signing algorithm to use to verify with.\n   * @param digest - The digest to verify.\n   * @param signature - The signature to verify the digest against.\n   * @param options - Additional options.\n   */\n  public verify(\n    algorithm: SignatureAlgorithm,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verify\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verify\", algorithm, updatedOptions);\n      try {\n        return provider.verify(algorithm, digest, signature, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verify(algorithm, digest, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Cryptographically sign a block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.signData(\"RS256\", message);\n   * ```\n   * @param algorithm - The signing algorithm to use.\n   * @param data - The data to sign.\n   * @param options - Additional options.\n   */\n  public signData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    options: SignOptions = {}\n  ): Promise<SignResult> {\n    return withTrace(\"signData\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Sign);\n      const provider = await this.getProvider(\"signData\", algorithm, updatedOptions);\n      try {\n        return provider.signData(algorithm, data, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.signData(algorithm, data, options);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Verify the signed block of data\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.verifyData(\"RS256\", signedMessage, signature);\n   * ```\n   * @param algorithm - The algorithm to use to verify with.\n   * @param data - The signed block of data to verify.\n   * @param signature - The signature to verify the block against.\n   * @param options - Additional options.\n   */\n  public verifyData(\n    algorithm: SignatureAlgorithm,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verifyData\", options, async (updatedOptions) => {\n      this.ensureValid(await this.fetchKey(updatedOptions), KnownKeyOperations.Verify);\n      const provider = await this.getProvider(\"verifyData\", algorithm, updatedOptions);\n      try {\n        return provider.verifyData(algorithm, data, signature, updatedOptions);\n      } catch (err) {\n        if (this.remoteProvider) {\n          return this.remoteProvider.verifyData(algorithm, data, signature, updatedOptions);\n        }\n        throw err;\n      }\n    });\n  }\n\n  /**\n   * Retrieves the {@link JsonWebKey} from the Key Vault.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new CryptographyClient(keyVaultKey, credentials);\n   * let result = await client.getKeyMaterial();\n   * ```\n   */\n  private async getKeyMaterial(options: GetKeyOptions): Promise<JsonWebKey> {\n    const key = await this.fetchKey(options);\n\n    switch (key.kind) {\n      case \"JsonWebKey\":\n        return key.value;\n      case \"KeyVaultKey\":\n        return key.value.key!;\n      default:\n        throw new Error(\"Failed to exchange Key ID for an actual KeyVault Key.\");\n    }\n  }\n\n  /**\n   * Returns the underlying key used for cryptographic operations.\n   * If needed, fetches the key from KeyVault and exchanges the ID for the actual key.\n   * @param options - The additional options.\n   */\n  private async fetchKey<T extends OperationOptions>(options: T): Promise<CryptographyClientKey> {\n    if (this.key.kind === \"identifier\") {\n      // Exchange the identifier with the actual key when needed\n      const key = await this.remoteProvider!.getKey(options);\n      this.key = { kind: \"KeyVaultKey\", value: key };\n    }\n    return this.key;\n  }\n\n  private providers?: CryptographyProvider[];\n  /**\n   * Gets the provider that support this algorithm and operation.\n   * The available providers are ordered by priority such that the first provider that supports this\n   * operation is the one we should use.\n   * @param operation - The {@link KeyOperation}.\n   * @param algorithm - The algorithm to use.\n   */\n  private async getProvider<T extends OperationOptions>(\n    operation: CryptographyProviderOperation,\n    algorithm: string,\n    options: T\n  ): Promise<CryptographyProvider> {\n    if (!this.providers) {\n      const keyMaterial = await this.getKeyMaterial(options);\n      // Add local crypto providers as needed\n      this.providers = [\n        new RsaCryptographyProvider(keyMaterial),\n        new AesCryptographyProvider(keyMaterial),\n      ];\n\n      // If the remote provider exists, we're in hybrid-mode. Otherwise we're in local-only mode.\n      // If we're in hybrid mode the remote provider is used as a catch-all and should be last in the list.\n      if (this.remoteProvider) {\n        this.providers.push(this.remoteProvider);\n      }\n    }\n\n    const providers = this.providers.filter((p) => p.isSupported(algorithm, operation));\n\n    if (providers.length === 0) {\n      throw new Error(\n        `Unable to support operation: \"${operation}\" with algorithm: \"${algorithm}\" ${\n          this.key.kind === \"JsonWebKey\" ? \"using a local JsonWebKey\" : \"\"\n        }`\n      );\n    }\n\n    // Return the first provider that supports this request\n    return providers[0];\n  }\n\n  private ensureValid(key: CryptographyClientKey, operation?: KeyOperation): void {\n    if (key.kind === \"KeyVaultKey\") {\n      const keyOps = key.value.keyOperations;\n      const { notBefore, expiresOn } = key.value.properties;\n      const now = new Date();\n\n      // Check KeyVault Key Expiration\n      if (notBefore && now < notBefore) {\n        throw new Error(`Key ${key.value.id} can't be used before ${notBefore.toISOString()}`);\n      }\n\n      if (expiresOn && now > expiresOn) {\n        throw new Error(`Key ${key.value.id} expired at ${expiresOn.toISOString()}`);\n      }\n\n      // Check Key operations\n      if (operation && keyOps && !keyOps?.includes(operation)) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.id}`);\n      }\n    } else if (key.kind === \"JsonWebKey\") {\n      // Check JsonWebKey Key operations\n      if (operation && key.value.keyOps && !key.value.keyOps?.includes(operation)) {\n        throw new Error(`Operation ${operation} is not supported on key ${key.value.kid}`);\n      }\n    }\n  }\n}\n"]}