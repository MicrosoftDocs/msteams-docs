{"version":3,"file":"remoteCryptographyProvider.js","sourceRoot":"","sources":["../../../../src/cryptography/remoteCryptographyProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  createPipelineFromOptions,\n  isTokenCredential,\n  TokenCredential,\n  signingPolicy,\n} from \"@azure/core-http\";\nimport {\n  EncryptParameters,\n  EncryptOptions,\n  EncryptResult,\n  KeyWrapAlgorithm,\n  WrapKeyOptions,\n  WrapResult,\n  VerifyOptions,\n  VerifyResult,\n  DecryptParameters,\n  DecryptOptions,\n  DecryptResult,\n  UnwrapKeyOptions,\n  SignOptions,\n  SignResult,\n} from \"../cryptographyClientModels\";\nimport { SDK_VERSION } from \"../constants\";\nimport { UnwrapResult } from \"../cryptographyClientModels\";\nimport { KeyVaultClient } from \"../generated\";\nimport { parseKeyVaultKeyIdentifier } from \"../identifier\";\nimport {\n  CryptographyClientOptions,\n  GetKeyOptions,\n  KeyVaultKey,\n  LATEST_API_VERSION,\n} from \"../keysModels\";\nimport { getKeyFromKeyBundle } from \"../transformations\";\nimport { createHash } from \"./crypto\";\nimport { CryptographyProvider, CryptographyProviderOperation } from \"./models\";\nimport { logger } from \"../log\";\nimport {\n  createTraceFunction,\n  TracedFunction,\n  challengeBasedAuthenticationPolicy,\n} from \"../../../keyvault-common/src\";\n\nconst withTrace: TracedFunction = createTraceFunction(\n  \"Azure.KeyVault.Keys.RemoteCryptographyProvider\"\n);\n\n/**\n * The remote cryptography provider is used to run crypto operations against KeyVault.\n * @internal\n */\nexport class RemoteCryptographyProvider implements CryptographyProvider {\n  constructor(\n    key: string | KeyVaultKey,\n    credential: TokenCredential,\n    pipelineOptions: CryptographyClientOptions = {}\n  ) {\n    this.client = getOrInitializeClient(credential, pipelineOptions);\n\n    this.key = key;\n\n    let keyId: string;\n    if (typeof key === \"string\") {\n      keyId = key;\n    } else {\n      keyId = key.id!;\n    }\n\n    try {\n      const parsed = parseKeyVaultKeyIdentifier(keyId);\n      if (parsed.name === \"\") {\n        throw new Error(\"Could not find 'name' of key in key URL\");\n      }\n\n      if (!parsed.vaultUrl || parsed.vaultUrl === \"\") {\n        throw new Error(\"Could not find 'vaultUrl' of key in key URL\");\n      }\n\n      this.vaultUrl = parsed.vaultUrl;\n      this.name = parsed.name;\n      this.version = parsed.version ?? \"\";\n    } catch (err) {\n      logger.error(err);\n\n      throw new Error(`${keyId} is not a valid Key Vault key ID`);\n    }\n  }\n\n  // The remote client supports all algorithms and all operations.\n  isSupported(_algorithm: string, _operation: CryptographyProviderOperation): boolean {\n    return true;\n  }\n\n  encrypt(\n    encryptParameters: EncryptParameters,\n    options: EncryptOptions = {}\n  ): Promise<EncryptResult> {\n    const { algorithm, plaintext, ...params } = encryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return withTrace(\"encrypt\", requestOptions, async (updatedOptions) => {\n      const result = await this.client.encrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        plaintext,\n        updatedOptions\n      );\n\n      return {\n        algorithm: encryptParameters.algorithm,\n        result: result.result!,\n        keyID: this.getKeyID(),\n        additionalAuthenticatedData: result.additionalAuthenticatedData,\n        authenticationTag: result.authenticationTag,\n        iv: result.iv,\n      };\n    });\n  }\n\n  decrypt(\n    decryptParameters: DecryptParameters,\n    options: DecryptOptions = {}\n  ): Promise<DecryptResult> {\n    const { algorithm, ciphertext, ...params } = decryptParameters;\n    const requestOptions = { ...options, ...params };\n\n    return withTrace(\"decrypt\", requestOptions, async (updatedOptions) => {\n      const result = await this.client.decrypt(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        ciphertext,\n        updatedOptions\n      );\n      return {\n        result: result.result!,\n        keyID: this.getKeyID(),\n        algorithm,\n      };\n    });\n  }\n\n  wrapKey(\n    algorithm: KeyWrapAlgorithm,\n    keyToWrap: Uint8Array,\n    options: WrapKeyOptions = {}\n  ): Promise<WrapResult> {\n    return withTrace(\"wrapKey\", options, async (updatedOptions) => {\n      const result = await this.client.wrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        keyToWrap,\n        updatedOptions\n      );\n\n      return {\n        result: result.result!,\n        algorithm,\n        keyID: this.getKeyID(),\n      };\n    });\n  }\n\n  unwrapKey(\n    algorithm: KeyWrapAlgorithm,\n    encryptedKey: Uint8Array,\n    options: UnwrapKeyOptions = {}\n  ): Promise<UnwrapResult> {\n    return withTrace(\"unwrapKey\", options, async (updatedOptions) => {\n      const result = await this.client.unwrapKey(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        encryptedKey,\n        updatedOptions\n      );\n\n      return {\n        result: result.result!,\n        algorithm,\n        keyID: this.getKeyID(),\n      };\n    });\n  }\n\n  sign(algorithm: string, digest: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return withTrace(\"sign\", options, async (updatedOptions) => {\n      const result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        updatedOptions\n      );\n\n      return { result: result.result!, algorithm, keyID: this.getKeyID() };\n    });\n  }\n\n  verifyData(\n    algorithm: string,\n    data: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verifyData\", options, async (updatedOptions) => {\n      const hash = await createHash(algorithm, data);\n      return this.verify(algorithm, hash, signature, updatedOptions);\n    });\n  }\n\n  verify(\n    algorithm: string,\n    digest: Uint8Array,\n    signature: Uint8Array,\n    options: VerifyOptions = {}\n  ): Promise<VerifyResult> {\n    return withTrace(\"verify\", options, async (updatedOptions) => {\n      const response = await this.client.verify(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        signature,\n        updatedOptions\n      );\n      return {\n        result: response.value ? response.value : false,\n        keyID: this.getKeyID(),\n      };\n    });\n  }\n\n  signData(algorithm: string, data: Uint8Array, options: SignOptions = {}): Promise<SignResult> {\n    return withTrace(\"signData\", options, async (updatedOptions) => {\n      const digest = await createHash(algorithm, data);\n      const result = await this.client.sign(\n        this.vaultUrl,\n        this.name,\n        this.version,\n        algorithm,\n        digest,\n        updatedOptions\n      );\n      return { result: result.result!, algorithm, keyID: this.getKeyID() };\n    });\n  }\n\n  /**\n   * The base URL to the vault.\n   */\n  readonly vaultUrl: string;\n\n  /**\n   * The ID of the key used to perform cryptographic operations for the client.\n   */\n  get keyId(): string | undefined {\n    return this.getKeyID();\n  }\n\n  /**\n   * Gets the {@link KeyVaultKey} used for cryptography operations, fetching it\n   * from KeyVault if necessary.\n   * @param options - Additional options.\n   */\n  getKey(options: GetKeyOptions = {}): Promise<KeyVaultKey> {\n    return withTrace(\"getKey\", options, async (updatedOptions) => {\n      if (typeof this.key === \"string\") {\n        if (!this.name || this.name === \"\") {\n          throw new Error(\"getKey requires a key with a name\");\n        }\n        const response = await this.client.getKey(\n          this.vaultUrl,\n          this.name,\n          options && options.version ? options.version : this.version ? this.version : \"\",\n          updatedOptions\n        );\n        this.key = getKeyFromKeyBundle(response);\n      }\n      return this.key;\n    });\n  }\n\n  /**\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private client: KeyVaultClient;\n\n  /**\n   * A reference to the key used for the cryptographic operations.\n   * Based on what was provided to the CryptographyClient constructor,\n   * it can be either a string with the URL of a Key Vault Key, or an already parsed {@link KeyVaultKey}.\n   */\n  private key: string | KeyVaultKey;\n\n  /**\n   * Name of the key the client represents\n   */\n  private name: string;\n\n  /**\n   * Version of the key the client represents\n   */\n  private version: string;\n\n  /**\n   * Attempts to retrieve the ID of the key.\n   */\n  private getKeyID(): string | undefined {\n    let kid;\n    if (typeof this.key !== \"string\") {\n      kid = this.key.id;\n    } else {\n      kid = this.key;\n    }\n\n    return kid;\n  }\n}\n\n/**\n * A helper method to either get the passed down generated client or initialize a new one.\n * An already constructed generated client may be passed down from {@link KeyClient} in which case we should reuse it.\n *\n * @internal\n * @param credential - The credential to use when initializing a new client.\n * @param options - The options for constructing a client or the underlying client if one already exists.\n * @returns - A generated client instance\n */\nfunction getOrInitializeClient(\n  credential: TokenCredential,\n  options: CryptographyClientOptions & { generatedClient?: KeyVaultClient }\n): KeyVaultClient {\n  if (options.generatedClient) {\n    return options.generatedClient;\n  }\n\n  const libInfo = `azsdk-js-keyvault-keys/${SDK_VERSION}`;\n\n  const userAgentOptions = options.userAgentOptions;\n\n  options.userAgentOptions = {\n    userAgentPrefix:\n      userAgentOptions && userAgentOptions.userAgentPrefix\n        ? `${userAgentOptions.userAgentPrefix} ${libInfo}`\n        : libInfo,\n  };\n\n  const authPolicy = isTokenCredential(credential)\n    ? challengeBasedAuthenticationPolicy(credential)\n    : signingPolicy(credential);\n\n  const internalPipelineOptions = {\n    ...options,\n    loggingOptions: {\n      logger: logger.info,\n      allowedHeaderNames: [\n        \"x-ms-keyvault-region\",\n        \"x-ms-keyvault-network-info\",\n        \"x-ms-keyvault-service-version\",\n      ],\n    },\n  };\n\n  return new KeyVaultClient(\n    options.serviceVersion || LATEST_API_VERSION,\n    createPipelineFromOptions(internalPipelineOptions, authPolicy)\n  );\n}\n"]}