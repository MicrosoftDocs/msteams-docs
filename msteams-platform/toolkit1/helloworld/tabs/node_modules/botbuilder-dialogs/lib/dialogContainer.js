"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialogContainer = void 0;
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const botbuilder_core_1 = require("botbuilder-core");
const dialog_1 = require("./dialog");
const dialogSet_1 = require("./dialogSet");
const dialogEvents_1 = require("./dialogEvents");
/**
 * A container for a set of Dialogs.
 */
class DialogContainer extends dialog_1.Dialog {
    constructor() {
        super(...arguments);
        /**
         * The containers dialog set.
         */
        this.dialogs = new dialogSet_1.DialogSet(undefined);
    }
    /**
     * Finds a child dialog that was previously added to the container.
     * @param dialogId ID of the dialog to lookup.
     */
    findDialog(dialogId) {
        return this.dialogs.find(dialogId);
    }
    /**
     * Called when an event has been raised, using `DialogContext.emitEvent()`,
     * by either the current dialog or a dialog that the current dialog started.
     *
     * @param dc The dialog context for the current turn of conversation.
     * @param e The event being raised.
     */
    onDialogEvent(dc, e) {
        const _super = Object.create(null, {
            onDialogEvent: { get: () => super.onDialogEvent }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const handled = yield _super.onDialogEvent.call(this, dc, e);
            if (!handled && e.name === dialogEvents_1.DialogEvents.versionChanged) {
                const traceMessage = `Unhandled dialog event: ${e.name}. Active Dialog: ${dc.activeDialog.id}`;
                dc.dialogs.telemetryClient.trackTrace({
                    message: traceMessage,
                    severityLevel: botbuilder_core_1.Severity.Warning,
                });
                yield dc.context.sendTraceActivity(traceMessage);
            }
            return handled;
        });
    }
    /**
     * Returns internal version identifier for this container.
     *
     * @remarks
     * DialogContainers detect changes of all sub-components in the container and map that to a `versionChanged` event.
     * Because they do this, DialogContainers "hide" the internal changes and just have the .id. This isolates changes
     * to the container level unless a container doesn't handle it.  To support this DialogContainers define a
     * protected method getInternalVersion() which computes if this dialog or child dialogs have changed
     * which is then examined via calls to checkForVersionChange().
     * @returns Version which represents the change of the internals of this container.
     */
    getInternalVersion() {
        return this.dialogs.getVersion();
    }
    /**
     * Checks to see if a containers child dialogs have changed since the current dialog instance
     * was started.
     *
     * @remarks
     * This should be called at the start of `beginDialog()`, `continueDialog()`, and `resumeDialog()`.
     * @param dc Current dialog context.
     */
    checkForVersionChange(dc) {
        return __awaiter(this, void 0, void 0, function* () {
            const current = dc.activeDialog.version;
            dc.activeDialog.version = this.getInternalVersion();
            // Check for change of previously stored hash
            if (current && current != dc.activeDialog.version) {
                // Give bot an opportunity to handle the change.
                // - If bot handles it the changeHash will have been updated as to avoid triggering the
                //   change again.
                yield dc.emitEvent(dialogEvents_1.DialogEvents.versionChanged, this.id, true, false);
            }
        });
    }
    /**
     * Set the telemetry client, and also apply it to all child dialogs.
     * Future dialogs added to the component will also inherit this client.
     */
    set telemetryClient(client) {
        this._telemetryClient = client !== null && client !== void 0 ? client : new botbuilder_core_1.NullTelemetryClient();
        if (this.dialogs.telemetryClient !== this._telemetryClient) {
            this.dialogs.telemetryClient = this._telemetryClient;
        }
    }
    /**
     * Get the current telemetry client.
     */
    get telemetryClient() {
        return this._telemetryClient;
    }
}
exports.DialogContainer = DialogContainer;
//# sourceMappingURL=dialogContainer.js.map