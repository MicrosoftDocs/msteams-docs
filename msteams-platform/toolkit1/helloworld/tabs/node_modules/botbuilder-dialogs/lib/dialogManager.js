"use strict";
/**
 * @module botbuilder-dialogs
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialogManager = void 0;
const botbuilder_core_1 = require("botbuilder-core");
const configurable_1 = require("./configurable");
const dialogContainer_1 = require("./dialogContainer");
const dialogContext_1 = require("./dialogContext");
const dialogHelper_1 = require("./dialogHelper");
const dialogSet_1 = require("./dialogSet");
const dialogTurnStateConstants_1 = require("./dialogTurnStateConstants");
const LAST_ACCESS = '_lastAccess';
const CONVERSATION_STATE = 'ConversationState';
const USER_STATE = 'UserState';
/**
 * Class which runs the dialog system.
 *
 * @obsolete This class will be deprecated.
 */
class DialogManager extends configurable_1.Configurable {
    /**
     * Creates an instance of the [DialogSet](xref:botbuilder-dialogs.DialogManager) class.
     *
     * @param rootDialog Optional, root [Dialog](xref:botbuilder-dialogs.Dialog) to use.
     * @param dialogStateProperty Optional, alternate name for the dialogState property. (Default is "DialogStateProperty")
     */
    constructor(rootDialog, dialogStateProperty) {
        super();
        this._initialTurnState = new botbuilder_core_1.TurnContextStateCollection();
        /**
         * Global dialogs that you want to have be callable.
         */
        this.dialogs = new dialogSet_1.DialogSet();
        if (rootDialog) {
            this.rootDialog = rootDialog;
        }
        this._dialogStateProperty = dialogStateProperty !== null && dialogStateProperty !== void 0 ? dialogStateProperty : 'DialogState';
        this._initialTurnState.set(dialogTurnStateConstants_1.DialogTurnStateConstants.dialogManager, this);
    }
    /**
     * Values that will be copied to the `TurnContext.turnState` at the beginning of each turn.
     */
    get initialTurnState() {
        return this._initialTurnState;
    }
    /**
     * Root dialog to start from [onTurn()](#onturn) method.
     */
    set rootDialog(value) {
        this.dialogs = new dialogSet_1.DialogSet();
        if (value) {
            this._rootDialogId = value.id;
            this.dialogs.telemetryClient = value.telemetryClient;
            this.dialogs.add(value);
            this.registerContainerDialogs(this.rootDialog, false);
        }
        else {
            this._rootDialogId = undefined;
        }
    }
    /**
     * Gets the root [Dialog](xref:botbuilder-dialogs.Dialog) ID.
     *
     * @returns The root [Dialog](xref:botbuilder-dialogs.Dialog) ID.
     */
    get rootDialog() {
        return this._rootDialogId ? this.dialogs.find(this._rootDialogId) : undefined;
    }
    /**
     * Set configuration settings.
     *
     * @param config Configuration settings to apply.
     * @returns The cofigured [DialogManager](xref:botbuilder-dialogs.DialogManager) context.
     */
    configure(config) {
        return super.configure(config);
    }
    /**
     * Runs dialog system in the context of a [TurnContext](xref:botbuilder-core.TurnContext).
     *
     * @param context [TurnContext](xref:botbuilder-core.TurnContext) for the current turn of conversation with the user.
     * @returns Result of running the logic against the activity.
     */
    onTurn(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure properly configured
            if (!this._rootDialogId) {
                throw new Error(`DialogManager.onTurn: the bot's 'rootDialog' has not been configured.`);
            }
            // Copy initial turn state to context
            this.initialTurnState.forEach((value, key) => {
                context.turnState.set(key, value);
            });
            const botStateSet = new botbuilder_core_1.BotStateSet();
            if (!this.conversationState) {
                this.conversationState = context.turnState.get(CONVERSATION_STATE);
            }
            else {
                context.turnState.set(CONVERSATION_STATE, this.conversationState);
            }
            if (!this.conversationState) {
                throw new Error(`DialogManager.onTurn: the bot's 'conversationState' has not been configured.`);
            }
            botStateSet.add(this.conversationState);
            if (!this.userState) {
                this.userState = context.turnState.get(USER_STATE);
            }
            else {
                context.turnState.set(USER_STATE, this.userState);
            }
            if (this.userState) {
                botStateSet.add(this.userState);
            }
            // Get last access
            const lastAccessProperty = this.conversationState.createProperty(LAST_ACCESS);
            const lastAccess = new Date(yield lastAccessProperty.get(context, new Date().toISOString()));
            // Check for expired conversation
            const now = new Date();
            if (this.expireAfter != undefined && now.getTime() - lastAccess.getTime() >= this.expireAfter) {
                // Clear conversation state
                yield this.conversationState.clear(context);
            }
            // Update last access time
            yield lastAccessProperty.set(context, lastAccess.toISOString());
            // get dialog stack
            const dialogsProperty = this.conversationState.createProperty(this._dialogStateProperty);
            const dialogState = yield dialogsProperty.get(context, {});
            // Create DialogContext
            const dc = new dialogContext_1.DialogContext(this.dialogs, context, dialogState);
            // Call the common dialog "continue/begin" execution pattern shared with the classic RunAsync extension method
            const turnResult = yield dialogHelper_1.internalRun(context, this._rootDialogId, dc, this.stateConfiguration);
            // Save BotState changes
            yield botStateSet.saveAllChanges(dc.context, false);
            return { turnResult };
        });
    }
    // Recursively traverses the dialog tree and registers intances of `DialogContainer` in the `DialogSet`
    // for this `DialogManager` instance.
    registerContainerDialogs(dialog, registerRoot = true) {
        if (!(dialog instanceof dialogContainer_1.DialogContainer)) {
            return;
        }
        const container = dialog;
        if (registerRoot) {
            if (this.dialogs.getDialogs().find((dlg) => dlg === container)) {
                return;
            }
            this.dialogs.add(container);
        }
        container.dialogs.getDialogs().forEach((inner) => {
            this.registerContainerDialogs(inner);
        });
    }
}
exports.DialogManager = DialogManager;
//# sourceMappingURL=dialogManager.js.map